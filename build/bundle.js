webpackJsonp([0,1],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(76);
	module.exports = __webpack_require__(78);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__resourceQuery) {var url = __webpack_require__(2);
	var stripAnsi = __webpack_require__(10);
	var socket = __webpack_require__(12);
	
	function getCurrentScriptSource() {
		// `document.currentScript` is the most accurate way to find the current script,
		// but is not supported in all browsers.
		if(document.currentScript)
			return document.currentScript.getAttribute("src");
		// Fall back to getting all scripts in the document.
		var scriptElements = document.scripts || [];
		var currentScript = scriptElements[scriptElements.length - 1];
		if(currentScript)
			return currentScript.getAttribute("src");
		// Fail as there was no script to use.
		throw new Error("[WDS] Failed to get current script source");
	}
	
	var urlParts;
	if(true) {
		// If this bundle is inlined, use the resource query to get the correct url.
		urlParts = url.parse(__resourceQuery.substr(1));
	} else {
		// Else, get the url from the <script> this file was called with.
		var scriptHost = getCurrentScriptSource();
		scriptHost = scriptHost.replace(/\/[^\/]+$/, "");
		urlParts = url.parse((scriptHost ? scriptHost : "/"), false, true);
	}
	
	var hot = false;
	var initial = true;
	var currentHash = "";
	var logLevel = "info";
	
	function log(level, msg) {
		if(logLevel === "info" && level === "info")
			return console.log(msg);
		if(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning")
			return console.warn(msg);
		if(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error")
			return console.error(msg);
	}
	
	var onSocketMsg = {
		hot: function() {
			hot = true;
			log("info", "[WDS] Hot Module Replacement enabled.");
		},
		invalid: function() {
			log("info", "[WDS] App updated. Recompiling...");
		},
		hash: function(hash) {
			currentHash = hash;
		},
		"still-ok": function() {
			log("info", "[WDS] Nothing changed.")
		},
		"log-level": function(level) {
			logLevel = level;
		},
		ok: function() {
			if(initial) return initial = false;
			reloadApp();
		},
		warnings: function(warnings) {
			log("info", "[WDS] Warnings while compiling.");
			for(var i = 0; i < warnings.length; i++)
				console.warn(stripAnsi(warnings[i]));
			if(initial) return initial = false;
			reloadApp();
		},
		errors: function(errors) {
			log("info", "[WDS] Errors while compiling.");
			for(var i = 0; i < errors.length; i++)
				console.error(stripAnsi(errors[i]));
			if(initial) return initial = false;
			reloadApp();
		},
		"proxy-error": function(errors) {
			log("info", "[WDS] Proxy error.");
			for(var i = 0; i < errors.length; i++)
				log("error", stripAnsi(errors[i]));
			if(initial) return initial = false;
		},
		close: function() {
			log("error", "[WDS] Disconnected!");
		}
	};
	
	var hostname = urlParts.hostname;
	var protocol = urlParts.protocol;
	
	if(urlParts.hostname === '0.0.0.0') {
		// why do we need this check?
		// hostname n/a for file protocol (example, when using electron, ionic)
		// see: https://github.com/webpack/webpack-dev-server/pull/384
		if(window.location.hostname && !!~window.location.protocol.indexOf('http')) {
			hostname = window.location.hostname;
		}
	}
	
	// `hostname` can be empty when the script path is relative. In that case, specifying
	// a protocol would result in an invalid URL.
	// When https is used in the app, secure websockets are always necessary
	// because the browser doesn't accept non-secure websockets.
	if(hostname && (window.location.protocol === "https:" || urlParts.hostname === '0.0.0.0')) {
		protocol = window.location.protocol;
	}
	
	var socketUrl = url.format({
		protocol: protocol,
		auth: urlParts.auth,
		hostname: hostname,
		port: (urlParts.port === '0') ? window.location.port : urlParts.port,
		pathname: urlParts.path == null || urlParts.path === '/' ? "/sockjs-node" : urlParts.path
	});
	
	socket(socketUrl, onSocketMsg);
	
	function reloadApp() {
		if(hot) {
			log("info", "[WDS] App hot update...");
			window.postMessage("webpackHotUpdate" + currentHash, "*");
		} else {
			log("info", "[WDS] App updated. Reloading...");
			window.location.reload();
		}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, "?http://0.0.0.0:1234"))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var punycode = __webpack_require__(3);
	var util = __webpack_require__(6);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	
	// Special case for a simple path URL
	simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
	
	
	// RFC 2396: characters reserved for delimiting URLs.
	// We actually just auto-escape these.
	delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	
	// RFC 2396: characters not allowed for various reasons.
	unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	
	// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	autoEscape = ['\''].concat(unwise),
	
	// Characters that are never ever allowed in a hostname.
	// Note that any invalid chars are also handled, but these
	// are the ones that are *expected* to be seen, so we fast-path
	// them.
	nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
	
	// protocols that can allow "unsafe" and "unwise" chars.
	unsafeProtocol = {
	  'javascript': true,
	  'javascript:': true
	},
	
	// protocols that never have a hostname.
	hostlessProtocol = {
	  'javascript': true,
	  'javascript:': true
	},
	
	// protocols that always contain a // bit.
	slashedProtocol = {
	  'http': true,
	  'https': true,
	  'ftp': true,
	  'gopher': true,
	  'file': true,
	  'http:': true,
	  'https:': true,
	  'ftp:': true,
	  'gopher:': true,
	  'file:': true
	},
	    querystring = __webpack_require__(7);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && util.isObject(url) && url instanceof Url) return url;
	
	  var u = new Url();
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
	  if (!util.isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + (typeof url === 'undefined' ? 'undefined' : _typeof(url)));
	  }
	
	  // Copy chrome, IE, opera backslash-handling behavior.
	  // Back slashes before the query string get converted to forward slashes
	  // See: https://code.google.com/p/chromium/issues/detail?id=25916
	  var queryIndex = url.indexOf('?'),
	      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
	      uSplit = url.split(splitter),
	      slashRegex = /\\/g;
	  uSplit[0] = uSplit[0].replace(slashRegex, '/');
	  url = uSplit.join(splitter);
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.path = rest;
	      this.href = rest;
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	        if (parseQueryString) {
	          this.query = querystring.parse(this.search.substr(1));
	        } else {
	          this.query = this.search.substr(1);
	        }
	      } else if (parseQueryString) {
	        this.search = '';
	        this.query = {};
	      }
	      return this;
	    }
	  }
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1) hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a punycoded representation of "domain".
	      // It only converts parts of the domain name that
	      // have non-ASCII characters, i.e. it doesn't matter if
	      // you call it with a domain that already is ASCII-only.
	      this.hostname = punycode.toASCII(this.hostname);
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      if (rest.indexOf(ae) === -1) continue;
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (util.isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function () {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || query && '?' + query || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function (match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function (relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function (relative) {
	  if (util.isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  var tkeys = Object.keys(this);
	  for (var tk = 0; tk < tkeys.length; tk++) {
	    var tkey = tkeys[tk];
	    result[tkey] = this[tkey];
	  }
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    var rkeys = Object.keys(relative);
	    for (var rk = 0; rk < rkeys.length; rk++) {
	      var rkey = rkeys[rk];
	      if (rkey !== 'protocol') result[rkey] = relative[rkey];
	    }
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      var keys = Object.keys(relative);
	      for (var v = 0; v < keys.length; v++) {
	        var k = keys[v];
	        result[k] = relative[k];
	      }
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift())) {}
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
	      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
	      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = relative.host || relative.host === '' ? relative.host : result.host;
	    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!util.isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especially happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last === '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especially happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || result.host && srcPath.length;
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function () {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function (root) {
	
		/** Detect free variables */
		var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
		var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
		var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
			root = freeGlobal;
		}
	
		/**
	  * The `punycode` object.
	  * @name punycode
	  * @type Object
	  */
		var punycode,
	
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647,
		    // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		    tMin = 1,
		    tMax = 26,
		    skew = 38,
		    damp = 700,
		    initialBias = 72,
		    initialN = 128,
		    // 0x80
		delimiter = '-',
		    // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		    regexNonASCII = /[^\x20-\x7E]/,
		    // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
		    // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		    floor = Math.floor,
		    stringFromCharCode = String.fromCharCode,
	
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
	  * A generic error utility function.
	  * @private
	  * @param {String} type The error type.
	  * @returns {Error} Throws a `RangeError` with the applicable error message.
	  */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
	  * A generic `Array#map` utility function.
	  * @private
	  * @param {Array} array The array to iterate over.
	  * @param {Function} callback The function that gets called for every array
	  * item.
	  * @returns {Array} A new array of values returned by the callback function.
	  */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
	  * A simple `Array#map`-like wrapper to work with domain name strings or email
	  * addresses.
	  * @private
	  * @param {String} domain The domain name or email address.
	  * @param {Function} callback The function that gets called for every
	  * character.
	  * @returns {Array} A new string of characters returned by the callback
	  * function.
	  */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
	  * Creates an array containing the numeric code points of each Unicode
	  * character in the string. While JavaScript uses UCS-2 internally,
	  * this function will convert a pair of surrogate halves (each of which
	  * UCS-2 exposes as separate characters) into a single code point,
	  * matching UTF-16.
	  * @see `punycode.ucs2.encode`
	  * @see <https://mathiasbynens.be/notes/javascript-encoding>
	  * @memberOf punycode.ucs2
	  * @name decode
	  * @param {String} string The Unicode input string (UCS-2).
	  * @returns {Array} The new array of code points.
	  */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						// low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
	  * Creates a string based on an array of numeric code points.
	  * @see `punycode.ucs2.decode`
	  * @memberOf punycode.ucs2
	  * @name encode
	  * @param {Array} codePoints The array of numeric code points.
	  * @returns {String} The new Unicode string (UCS-2).
	  */
		function ucs2encode(array) {
			return map(array, function (value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
	  * Converts a basic code point into a digit/integer.
	  * @see `digitToBasic()`
	  * @private
	  * @param {Number} codePoint The basic numeric code point value.
	  * @returns {Number} The numeric value of a basic code point (for use in
	  * representing integers) in the range `0` to `base - 1`, or `base` if
	  * the code point does not represent a value.
	  */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
	  * Converts a digit/integer into a basic code point.
	  * @see `basicToDigit()`
	  * @private
	  * @param {Number} digit The numeric value of a basic code point.
	  * @returns {Number} The basic code point whose value (when used for
	  * representing integers) is `digit`, which needs to be in the range
	  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	  * used; else, the lowercase form is used. The behavior is undefined
	  * if `flag` is non-zero and `digit` has no uppercase form.
	  */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
	  * Bias adaptation function as per section 3.4 of RFC 3492.
	  * http://tools.ietf.org/html/rfc3492#section-3.4
	  * @private
	  */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
	  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	  * symbols.
	  * @memberOf punycode
	  * @param {String} input The Punycode string of ASCII-only symbols.
	  * @returns {String} The resulting string of Unicode symbols.
	  */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
	
			/** Cached calculation results */
			baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base;; /* no condition */k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
			}
	
			return ucs2encode(output);
		}
	
		/**
	  * Converts a string of Unicode symbols (e.g. a domain name label) to a
	  * Punycode string of ASCII-only symbols.
	  * @memberOf punycode
	  * @param {String} input The string of Unicode symbols.
	  * @returns {String} The resulting Punycode string of ASCII-only symbols.
	  */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
	
			/** `inputLength` will hold the number of code points in `input`. */
			inputLength,
	
			/** Cached calculation results */
			handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base;; /* no condition */k += base) {
							t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
			}
			return output.join('');
		}
	
		/**
	  * Converts a Punycode string representing a domain name or an email address
	  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	  * it doesn't matter if you call it on a string that has already been
	  * converted to Unicode.
	  * @memberOf punycode
	  * @param {String} input The Punycoded domain name or email address to
	  * convert to Unicode.
	  * @returns {String} The Unicode representation of the given Punycode
	  * string.
	  */
		function toUnicode(input) {
			return mapDomain(input, function (string) {
				return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
			});
		}
	
		/**
	  * Converts a Unicode string representing a domain name or an email address to
	  * Punycode. Only the non-ASCII parts of the domain name will be converted,
	  * i.e. it doesn't matter if you call it with a domain that's already in
	  * ASCII.
	  * @memberOf punycode
	  * @param {String} input The domain name or email address to convert, as a
	  * Unicode string.
	  * @returns {String} The Punycode representation of the given domain name or
	  * email address.
	  */
		function toASCII(input) {
			return mapDomain(input, function (string) {
				return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
	   * A string representing the current Punycode.js version number.
	   * @memberOf punycode
	   * @type String
	   */
			'version': '1.3.2',
			/**
	   * An object of methods to convert from JavaScript's internal character
	   * representation (UCS-2) to Unicode code points, and back.
	   * @see <https://mathiasbynens.be/notes/javascript-encoding>
	   * @memberOf punycode
	   * @type Object
	   */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if ("function" == 'function' && _typeof(__webpack_require__(5)) == 'object' && __webpack_require__(5)) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) {
				// in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.punycode = punycode;
		}
	})(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module), (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = {
	  isString: function isString(arg) {
	    return typeof arg === 'string';
	  },
	  isObject: function isObject(arg) {
	    return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	  },
	  isNull: function isNull(arg) {
	    return arg === null;
	  },
	  isNullOrUndefined: function isNullOrUndefined(arg) {
	    return arg == null;
	  }
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(8);
	exports.encode = exports.stringify = __webpack_require__(9);

/***/ },
/* 8 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function (qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr,
	        vstr,
	        k,
	        v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};

/***/ },
/* 9 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var stringifyPrimitive = function stringifyPrimitive(v) {
	  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function (obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    return Object.keys(obj).map(function (k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function (v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
	};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ansiRegex = __webpack_require__(11)();
	
	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		return (/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g
		);
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var SockJS = __webpack_require__(13);
	
	var retries = 0;
	var sock = null;
	
	function socket(url, handlers) {
		sock = new SockJS(url);
	
		sock.onopen = function () {
			retries = 0;
		};
	
		sock.onclose = function () {
			if (retries === 0) handlers.close();
	
			// Try to reconnect.
			sock = null;
	
			// After 10 retries stop trying, to prevent logspam.
			if (retries <= 10) {
				// Exponentially increase timeout to reconnect.
				// Respectfully copied from the package `got`.
				var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
				retries += 1;
	
				setTimeout(function () {
					socket(url, handlers);
				}, retryInMs);
			}
		};
	
		sock.onmessage = function (e) {
			// This assumes that all data sent via the websocket is JSON.
			var msg = JSON.parse(e.data);
			if (handlers[msg.type]) handlers[msg.type](msg.data);
		};
	}
	
	module.exports = socket;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var transportList = __webpack_require__(14);
	
	module.exports = __webpack_require__(60)(transportList);
	
	// TODO can't get rid of this until all servers do
	if ('_sockjs_onload' in global) {
	  setTimeout(global._sockjs_onload, 1);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = [
	// streaming transports
	__webpack_require__(15), __webpack_require__(32), __webpack_require__(42), __webpack_require__(44), __webpack_require__(47)(__webpack_require__(44))
	
	// polling transports
	, __webpack_require__(53), __webpack_require__(47)(__webpack_require__(53)), __webpack_require__(55), __webpack_require__(56), __webpack_require__(47)(__webpack_require__(55)), __webpack_require__(57)];

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var utils = __webpack_require__(17),
	    urlUtils = __webpack_require__(20),
	    inherits = __webpack_require__(28),
	    EventEmitter = __webpack_require__(29).EventEmitter,
	    WebsocketDriver = __webpack_require__(31);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:websocket');
	}
	
	function WebSocketTransport(transUrl, ignore, options) {
	  if (!WebSocketTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	
	  EventEmitter.call(this);
	  debug('constructor', transUrl);
	
	  var self = this;
	  var url = urlUtils.addPath(transUrl, '/websocket');
	  if (url.slice(0, 5) === 'https') {
	    url = 'wss' + url.slice(5);
	  } else {
	    url = 'ws' + url.slice(4);
	  }
	  this.url = url;
	
	  this.ws = new WebsocketDriver(this.url, [], options);
	  this.ws.onmessage = function (e) {
	    debug('message event', e.data);
	    self.emit('message', e.data);
	  };
	  // Firefox has an interesting bug. If a websocket connection is
	  // created after onunload, it stays alive even when user
	  // navigates away from the page. In such situation let's lie -
	  // let's not open the ws connection at all. See:
	  // https://github.com/sockjs/sockjs-client/issues/28
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
	  this.unloadRef = utils.unloadAdd(function () {
	    debug('unload');
	    self.ws.close();
	  });
	  this.ws.onclose = function (e) {
	    debug('close event', e.code, e.reason);
	    self.emit('close', e.code, e.reason);
	    self._cleanup();
	  };
	  this.ws.onerror = function (e) {
	    debug('error event', e);
	    self.emit('close', 1006, 'WebSocket connection broken');
	    self._cleanup();
	  };
	}
	
	inherits(WebSocketTransport, EventEmitter);
	
	WebSocketTransport.prototype.send = function (data) {
	  var msg = '[' + data + ']';
	  debug('send', msg);
	  this.ws.send(msg);
	};
	
	WebSocketTransport.prototype.close = function () {
	  debug('close');
	  var ws = this.ws;
	  this._cleanup();
	  if (ws) {
	    ws.close();
	  }
	};
	
	WebSocketTransport.prototype._cleanup = function () {
	  debug('_cleanup');
	  var ws = this.ws;
	  if (ws) {
	    ws.onmessage = ws.onclose = ws.onerror = null;
	  }
	  utils.unloadDel(this.unloadRef);
	  this.unloadRef = this.ws = null;
	  this.removeAllListeners();
	};
	
	WebSocketTransport.enabled = function () {
	  debug('enabled');
	  return !!WebsocketDriver;
	};
	WebSocketTransport.transportName = 'websocket';
	
	// In theory, ws should require 1 round trip. But in chrome, this is
	// not very stable over SSL. Most likely a ws connection requires a
	// separate SSL connection, in which case 2 round trips are an
	// absolute minumum.
	WebSocketTransport.roundTrips = 2;
	
	module.exports = WebSocketTransport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var random = __webpack_require__(18);
	
	var onUnload = {},
	    afterUnload = false
	// detect google chrome packaged apps because they don't allow the 'unload' event
	,
	    isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime;
	
	module.exports = {
	  attachEvent: function attachEvent(event, listener) {
	    if (typeof global.addEventListener !== 'undefined') {
	      global.addEventListener(event, listener, false);
	    } else if (global.document && global.attachEvent) {
	      // IE quirks.
	      // According to: http://stevesouders.com/misc/test-postmessage.php
	      // the message gets delivered only to 'document', not 'window'.
	      global.document.attachEvent('on' + event, listener);
	      // I get 'window' for ie8.
	      global.attachEvent('on' + event, listener);
	    }
	  },
	
	  detachEvent: function detachEvent(event, listener) {
	    if (typeof global.addEventListener !== 'undefined') {
	      global.removeEventListener(event, listener, false);
	    } else if (global.document && global.detachEvent) {
	      global.document.detachEvent('on' + event, listener);
	      global.detachEvent('on' + event, listener);
	    }
	  },
	
	  unloadAdd: function unloadAdd(listener) {
	    if (isChromePackagedApp) {
	      return null;
	    }
	
	    var ref = random.string(8);
	    onUnload[ref] = listener;
	    if (afterUnload) {
	      setTimeout(this.triggerUnloadCallbacks, 0);
	    }
	    return ref;
	  },
	
	  unloadDel: function unloadDel(ref) {
	    if (ref in onUnload) {
	      delete onUnload[ref];
	    }
	  },
	
	  triggerUnloadCallbacks: function triggerUnloadCallbacks() {
	    for (var ref in onUnload) {
	      onUnload[ref]();
	      delete onUnload[ref];
	    }
	  }
	};
	
	var unloadTriggered = function unloadTriggered() {
	  if (afterUnload) {
	    return;
	  }
	  afterUnload = true;
	  module.exports.triggerUnloadCallbacks();
	};
	
	// 'unload' alone is not reliable in opera within an iframe, but we
	// can't use `beforeunload` as IE fires it on javascript: links.
	if (!isChromePackagedApp) {
	  module.exports.attachEvent('unload', unloadTriggered);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/* global crypto:true */
	
	var crypto = __webpack_require__(19);
	
	// This string has length 32, a power of 2, so the modulus doesn't introduce a
	// bias.
	var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
	module.exports = {
	  string: function string(length) {
	    var max = _randomStringChars.length;
	    var bytes = crypto.randomBytes(length);
	    var ret = [];
	    for (var i = 0; i < length; i++) {
	      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
	    }
	    return ret.join('');
	  },
	
	  number: function number(max) {
	    return Math.floor(Math.random() * max);
	  },
	
	  numberString: function numberString(max) {
	    var t = ('' + (max - 1)).length;
	    var p = new Array(t + 1).join('0');
	    return (p + this.number(max)).slice(-t);
	  }
	};

/***/ },
/* 19 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	if (global.crypto && global.crypto.getRandomValues) {
	  module.exports.randomBytes = function (length) {
	    var bytes = new Uint8Array(length);
	    global.crypto.getRandomValues(bytes);
	    return bytes;
	  };
	} else {
	  module.exports.randomBytes = function (length) {
	    var bytes = new Array(length);
	    for (var i = 0; i < length; i++) {
	      bytes[i] = Math.floor(Math.random() * 256);
	    }
	    return bytes;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var URL = __webpack_require__(21);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:utils:url');
	}
	
	module.exports = {
	  getOrigin: function getOrigin(url) {
	    if (!url) {
	      return null;
	    }
	
	    var p = new URL(url);
	    if (p.protocol === 'file:') {
	      return null;
	    }
	
	    var port = p.port;
	    if (!port) {
	      port = p.protocol === 'https:' ? '443' : '80';
	    }
	
	    return p.protocol + '//' + p.hostname + ':' + port;
	  },
	
	  isOriginEqual: function isOriginEqual(a, b) {
	    var res = this.getOrigin(a) === this.getOrigin(b);
	    debug('same', a, b, res);
	    return res;
	  },
	
	  isSchemeEqual: function isSchemeEqual(a, b) {
	    return a.split(':')[0] === b.split(':')[0];
	  },
	
	  addPath: function addPath(url, path) {
	    var qs = url.split('?');
	    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
	  },
	
	  addQuery: function addQuery(url, q) {
	    return url + (url.indexOf('?') === -1 ? '?' + q : '&' + q);
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var required = __webpack_require__(22),
	    lolcation = __webpack_require__(23),
	    qs = __webpack_require__(24),
	    protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i;
	
	/**
	 * These are the parse rules for the URL parser, it informs the parser
	 * about:
	 *
	 * 0. The char it Needs to parse, if it's a string it should be done using
	 *    indexOf, RegExp using exec and NaN means set as current value.
	 * 1. The property we should set when parsing this value.
	 * 2. Indication if it's backwards or forward parsing, when set as number it's
	 *    the value of extra chars that should be split off.
	 * 3. Inherit from location if non existing in the parser.
	 * 4. `toLowerCase` the resulting value.
	 */
	var rules = [['#', 'hash'], // Extract from the back.
	['?', 'query'], // Extract from the back.
	['/', 'pathname'], // Extract from the back.
	['@', 'auth', 1], // Extract from the front.
	[NaN, 'host', undefined, 1, 1], // Set left over value.
	[/:(\d+)$/, 'port', undefined, 1], // RegExp the back.
	[NaN, 'hostname', undefined, 1, 1] // Set left over.
	];
	
	/**
	 * @typedef ProtocolExtract
	 * @type Object
	 * @property {String} protocol Protocol matched in the URL, in lowercase.
	 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
	 * @property {String} rest Rest of the URL that is not part of the protocol.
	 */
	
	/**
	 * Extract protocol information from a URL with/without double slash ("//").
	 *
	 * @param {String} address URL we want to extract from.
	 * @return {ProtocolExtract} Extracted information.
	 * @api private
	 */
	function extractProtocol(address) {
	  var match = protocolre.exec(address);
	
	  return {
	    protocol: match[1] ? match[1].toLowerCase() : '',
	    slashes: !!match[2],
	    rest: match[3]
	  };
	}
	
	/**
	 * Resolve a relative URL pathname against a base URL pathname.
	 *
	 * @param {String} relative Pathname of the relative URL.
	 * @param {String} base Pathname of the base URL.
	 * @return {String} Resolved pathname.
	 * @api private
	 */
	function resolve(relative, base) {
	  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),
	      i = path.length,
	      last = path[i - 1],
	      unshift = false,
	      up = 0;
	
	  while (i--) {
	    if (path[i] === '.') {
	      path.splice(i, 1);
	    } else if (path[i] === '..') {
	      path.splice(i, 1);
	      up++;
	    } else if (up) {
	      if (i === 0) unshift = true;
	      path.splice(i, 1);
	      up--;
	    }
	  }
	
	  if (unshift) path.unshift('');
	  if (last === '.' || last === '..') path.push('');
	
	  return path.join('/');
	}
	
	/**
	 * The actual URL instance. Instead of returning an object we've opted-in to
	 * create an actual constructor as it's much more memory efficient and
	 * faster and it pleases my OCD.
	 *
	 * @constructor
	 * @param {String} address URL we want to parse.
	 * @param {Object|String} location Location defaults for relative paths.
	 * @param {Boolean|Function} parser Parser for the query string.
	 * @api public
	 */
	function URL(address, location, parser) {
	  if (!(this instanceof URL)) {
	    return new URL(address, location, parser);
	  }
	
	  var relative,
	      extracted,
	      parse,
	      instruction,
	      index,
	      key,
	      instructions = rules.slice(),
	      type = typeof location === 'undefined' ? 'undefined' : _typeof(location),
	      url = this,
	      i = 0;
	
	  //
	  // The following if statements allows this module two have compatibility with
	  // 2 different API:
	  //
	  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
	  //    where the boolean indicates that the query string should also be parsed.
	  //
	  // 2. The `URL` interface of the browser which accepts a URL, object as
	  //    arguments. The supplied object will be used as default values / fall-back
	  //    for relative paths.
	  //
	  if ('object' !== type && 'string' !== type) {
	    parser = location;
	    location = null;
	  }
	
	  if (parser && 'function' !== typeof parser) parser = qs.parse;
	
	  location = lolcation(location);
	
	  //
	  // Extract protocol information before running the instructions.
	  //
	  extracted = extractProtocol(address || '');
	  relative = !extracted.protocol && !extracted.slashes;
	  url.slashes = extracted.slashes || relative && location.slashes;
	  url.protocol = extracted.protocol || location.protocol || '';
	  address = extracted.rest;
	
	  //
	  // When the authority component is absent the URL starts with a path
	  // component.
	  //
	  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];
	
	  for (; i < instructions.length; i++) {
	    instruction = instructions[i];
	    parse = instruction[0];
	    key = instruction[1];
	
	    if (parse !== parse) {
	      url[key] = address;
	    } else if ('string' === typeof parse) {
	      if (~(index = address.indexOf(parse))) {
	        if ('number' === typeof instruction[2]) {
	          url[key] = address.slice(0, index);
	          address = address.slice(index + instruction[2]);
	        } else {
	          url[key] = address.slice(index);
	          address = address.slice(0, index);
	        }
	      }
	    } else if (index = parse.exec(address)) {
	      url[key] = index[1];
	      address = address.slice(0, index.index);
	    }
	
	    url[key] = url[key] || (relative && instruction[3] ? location[key] || '' : '');
	
	    //
	    // Hostname, host and protocol should be lowercased so they can be used to
	    // create a proper `origin`.
	    //
	    if (instruction[4]) url[key] = url[key].toLowerCase();
	  }
	
	  //
	  // Also parse the supplied query string in to an object. If we're supplied
	  // with a custom parser as function use that instead of the default build-in
	  // parser.
	  //
	  if (parser) url.query = parser(url.query);
	
	  //
	  // If the URL is relative, resolve the pathname against the base URL.
	  //
	  if (relative && location.slashes && url.pathname.charAt(0) !== '/' && (url.pathname !== '' || location.pathname !== '')) {
	    url.pathname = resolve(url.pathname, location.pathname);
	  }
	
	  //
	  // We should not add port numbers if they are already the default port number
	  // for a given protocol. As the host also contains the port number we're going
	  // override it with the hostname which contains no port number.
	  //
	  if (!required(url.port, url.protocol)) {
	    url.host = url.hostname;
	    url.port = '';
	  }
	
	  //
	  // Parse down the `auth` for the username and password.
	  //
	  url.username = url.password = '';
	  if (url.auth) {
	    instruction = url.auth.split(':');
	    url.username = instruction[0] || '';
	    url.password = instruction[1] || '';
	  }
	
	  url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol + '//' + url.host : 'null';
	
	  //
	  // The href is just the compiled result.
	  //
	  url.href = url.toString();
	}
	
	/**
	 * This is convenience method for changing properties in the URL instance to
	 * insure that they all propagate correctly.
	 *
	 * @param {String} part          Property we need to adjust.
	 * @param {Mixed} value          The newly assigned value.
	 * @param {Boolean|Function} fn  When setting the query, it will be the function
	 *                               used to parse the query.
	 *                               When setting the protocol, double slash will be
	 *                               removed from the final url if it is true.
	 * @returns {URL}
	 * @api public
	 */
	URL.prototype.set = function set(part, value, fn) {
	  var url = this;
	
	  switch (part) {
	    case 'query':
	      if ('string' === typeof value && value.length) {
	        value = (fn || qs.parse)(value);
	      }
	
	      url[part] = value;
	      break;
	
	    case 'port':
	      url[part] = value;
	
	      if (!required(value, url.protocol)) {
	        url.host = url.hostname;
	        url[part] = '';
	      } else if (value) {
	        url.host = url.hostname + ':' + value;
	      }
	
	      break;
	
	    case 'hostname':
	      url[part] = value;
	
	      if (url.port) value += ':' + url.port;
	      url.host = value;
	      break;
	
	    case 'host':
	      url[part] = value;
	
	      if (/:\d+$/.test(value)) {
	        value = value.split(':');
	        url.port = value.pop();
	        url.hostname = value.join(':');
	      } else {
	        url.hostname = value;
	        url.port = '';
	      }
	
	      break;
	
	    case 'protocol':
	      url.protocol = value.toLowerCase();
	      url.slashes = !fn;
	      break;
	
	    case 'pathname':
	      url.pathname = value.length && value.charAt(0) !== '/' ? '/' + value : value;
	
	      break;
	
	    default:
	      url[part] = value;
	  }
	
	  for (var i = 0; i < rules.length; i++) {
	    var ins = rules[i];
	
	    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
	  }
	
	  url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol + '//' + url.host : 'null';
	
	  url.href = url.toString();
	
	  return url;
	};
	
	/**
	 * Transform the properties back in to a valid and full URL string.
	 *
	 * @param {Function} stringify Optional query stringify function.
	 * @returns {String}
	 * @api public
	 */
	URL.prototype.toString = function toString(stringify) {
	  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;
	
	  var query,
	      url = this,
	      protocol = url.protocol;
	
	  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';
	
	  var result = protocol + (url.slashes ? '//' : '');
	
	  if (url.username) {
	    result += url.username;
	    if (url.password) result += ':' + url.password;
	    result += '@';
	  }
	
	  result += url.host + url.pathname;
	
	  query = 'object' === _typeof(url.query) ? stringify(url.query) : url.query;
	  if (query) result += '?' !== query.charAt(0) ? '?' + query : query;
	
	  if (url.hash) result += url.hash;
	
	  return result;
	};
	
	//
	// Expose the URL parser and some additional properties that might be useful for
	// others or testing.
	//
	URL.extractProtocol = extractProtocol;
	URL.location = lolcation;
	URL.qs = qs;
	
	module.exports = URL;

/***/ },
/* 22 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Check if we're required to add a port number.
	 *
	 * @see https://url.spec.whatwg.org/#default-port
	 * @param {Number|String} port Port number we need to check
	 * @param {String} protocol Protocol we need to check against.
	 * @returns {Boolean} Is it a default port for the given protocol
	 * @api private
	 */
	
	module.exports = function required(port, protocol) {
	  protocol = protocol.split(':')[0];
	  port = +port;
	
	  if (!port) return false;
	
	  switch (protocol) {
	    case 'http':
	    case 'ws':
	      return port !== 80;
	
	    case 'https':
	    case 'wss':
	      return port !== 443;
	
	    case 'ftp':
	      return port !== 21;
	
	    case 'gopher':
	      return port !== 70;
	
	    case 'file':
	      return false;
	  }
	
	  return port !== 0;
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
	
	/**
	 * These properties should not be copied or inherited from. This is only needed
	 * for all non blob URL's as a blob URL does not include a hash, only the
	 * origin.
	 *
	 * @type {Object}
	 * @private
	 */
	var ignore = { hash: 1, query: 1 },
	    URL;
	
	/**
	 * The location object differs when your code is loaded through a normal page,
	 * Worker or through a worker using a blob. And with the blobble begins the
	 * trouble as the location object will contain the URL of the blob, not the
	 * location of the page where our code is loaded in. The actual origin is
	 * encoded in the `pathname` so we can thankfully generate a good "default"
	 * location from it so we can generate proper relative URL's again.
	 *
	 * @param {Object|String} loc Optional default location object.
	 * @returns {Object} lolcation object.
	 * @api public
	 */
	module.exports = function lolcation(loc) {
	  loc = loc || global.location || {};
	  URL = URL || __webpack_require__(21);
	
	  var finaldestination = {},
	      type = typeof loc === 'undefined' ? 'undefined' : _typeof(loc),
	      key;
	
	  if ('blob:' === loc.protocol) {
	    finaldestination = new URL(unescape(loc.pathname), {});
	  } else if ('string' === type) {
	    finaldestination = new URL(loc, {});
	    for (key in ignore) {
	      delete finaldestination[key];
	    }
	  } else if ('object' === type) {
	    for (key in loc) {
	      if (key in ignore) continue;
	      finaldestination[key] = loc[key];
	    }
	
	    if (finaldestination.slashes === undefined) {
	      finaldestination.slashes = slashes.test(loc.href);
	    }
	  }
	
	  return finaldestination;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 24 */
/***/ function(module, exports) {

	'use strict';
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Simple query string parser.
	 *
	 * @param {String} query The query string that needs to be parsed.
	 * @returns {Object}
	 * @api public
	 */
	function querystring(query) {
	  var parser = /([^=?&]+)=?([^&]*)/g,
	      result = {},
	      part;
	
	  //
	  // Little nifty parsing hack, leverage the fact that RegExp.exec increments
	  // the lastIndex property so we can continue executing this loop until we've
	  // parsed all results.
	  //
	  for (; part = parser.exec(query); result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])) {}
	
	  return result;
	}
	
	/**
	 * Transform a query string to an object.
	 *
	 * @param {Object} obj Object that should be transformed.
	 * @param {String} prefix Optional prefix.
	 * @returns {String}
	 * @api public
	 */
	function querystringify(obj, prefix) {
	  prefix = prefix || '';
	
	  var pairs = [];
	
	  //
	  // Optionally prefix with a '?' if needed
	  //
	  if ('string' !== typeof prefix) prefix = '?';
	
	  for (var key in obj) {
	    if (has.call(obj, key)) {
	      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));
	    }
	  }
	
	  return pairs.length ? prefix + pairs.join('&') : '';
	}
	
	//
	// Expose the module.
	//
	exports.stringify = querystringify;
	exports.parse = querystring;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(26);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {
	    return true;
	  }
	
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style ||
	  // is firebug? http://stackoverflow.com/a/398120/376773
	  typeof window !== 'undefined' && window && window.console && (console.firebug || console.exception && console.table) ||
	  // is firefox >= v31?
	  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	  typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
	  // double check webkit in userAgent just in case we are in a worker
	  typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function (v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs(args) {
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return;
	
	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit');
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function (match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch (e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  try {
	    return exports.storage.debug;
	  } catch (e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (typeof process !== 'undefined' && 'env' in process) {
	    return process.env.DEBUG;
	  }
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = createDebug.debug = createDebug.default = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(27);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor(namespace) {
	  var hash = 0,
	      i;
	
	  for (i in namespace) {
	    hash = (hash << 5) - hash + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }
	
	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function createDebug(namespace) {
	
	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;
	
	    var self = debug;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);
	
	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	
	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);
	
	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }
	
	  return debug;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}

/***/ },
/* 27 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {};
	  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str);
	  if (str.length > 10000) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict';
	
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function TempCtor() {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(28),
	    EventTarget = __webpack_require__(30);
	
	function EventEmitter() {
	  EventTarget.call(this);
	}
	
	inherits(EventEmitter, EventTarget);
	
	EventEmitter.prototype.removeAllListeners = function (type) {
	  if (type) {
	    delete this._listeners[type];
	  } else {
	    this._listeners = {};
	  }
	};
	
	EventEmitter.prototype.once = function (type, listener) {
	  var self = this,
	      fired = false;
	
	  function g() {
	    self.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  this.on(type, g);
	};
	
	EventEmitter.prototype.emit = function () {
	  var type = arguments[0];
	  var listeners = this._listeners[type];
	  if (!listeners) {
	    return;
	  }
	  // equivalent of Array.prototype.slice.call(arguments, 1);
	  var l = arguments.length;
	  var args = new Array(l - 1);
	  for (var ai = 1; ai < l; ai++) {
	    args[ai - 1] = arguments[ai];
	  }
	  for (var i = 0; i < listeners.length; i++) {
	    listeners[i].apply(this, args);
	  }
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
	EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;
	
	module.exports.EventEmitter = EventEmitter;

/***/ },
/* 30 */
/***/ function(module, exports) {

	'use strict';
	
	/* Simplified implementation of DOM2 EventTarget.
	 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
	 */
	
	function EventTarget() {
	  this._listeners = {};
	}
	
	EventTarget.prototype.addEventListener = function (eventType, listener) {
	  if (!(eventType in this._listeners)) {
	    this._listeners[eventType] = [];
	  }
	  var arr = this._listeners[eventType];
	  // #4
	  if (arr.indexOf(listener) === -1) {
	    // Make a copy so as not to interfere with a current dispatchEvent.
	    arr = arr.concat([listener]);
	  }
	  this._listeners[eventType] = arr;
	};
	
	EventTarget.prototype.removeEventListener = function (eventType, listener) {
	  var arr = this._listeners[eventType];
	  if (!arr) {
	    return;
	  }
	  var idx = arr.indexOf(listener);
	  if (idx !== -1) {
	    if (arr.length > 1) {
	      // Make a copy so as not to interfere with a current dispatchEvent.
	      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
	    } else {
	      delete this._listeners[eventType];
	    }
	    return;
	  }
	};
	
	EventTarget.prototype.dispatchEvent = function () {
	  var event = arguments[0];
	  var t = event.type;
	  // equivalent of Array.prototype.slice.call(arguments, 0);
	  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
	  // TODO: This doesn't match the real behavior; per spec, onfoo get
	  // their place in line from the /first/ time they're set from
	  // non-null. Although WebKit bumps it to the end every time it's
	  // set.
	  if (this['on' + t]) {
	    this['on' + t].apply(this, args);
	  }
	  if (t in this._listeners) {
	    // Grab a reference to the listeners list. removeEventListener may alter the list.
	    var listeners = this._listeners[t];
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i].apply(this, args);
	    }
	  }
	};
	
	module.exports = EventTarget;

/***/ },
/* 31 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var Driver = global.WebSocket || global.MozWebSocket;
	if (Driver) {
		module.exports = function WebSocketBrowserDriver(url) {
			return new Driver(url);
		};
	} else {
		module.exports = undefined;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var inherits = __webpack_require__(28),
	    AjaxBasedTransport = __webpack_require__(33),
	    XhrReceiver = __webpack_require__(37),
	    XHRCorsObject = __webpack_require__(38),
	    XHRLocalObject = __webpack_require__(40),
	    browser = __webpack_require__(41);
	
	function XhrStreamingTransport(transUrl) {
	  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
	}
	
	inherits(XhrStreamingTransport, AjaxBasedTransport);
	
	XhrStreamingTransport.enabled = function (info) {
	  if (info.nullOrigin) {
	    return false;
	  }
	  // Opera doesn't support xhr-streaming #60
	  // But it might be able to #92
	  if (browser.isOpera()) {
	    return false;
	  }
	
	  return XHRCorsObject.enabled;
	};
	
	XhrStreamingTransport.transportName = 'xhr-streaming';
	XhrStreamingTransport.roundTrips = 2; // preflight, ajax
	
	// Safari gets confused when a streaming ajax request is started
	// before onload. This causes the load indicator to spin indefinetely.
	// Only require body when used in a browser
	XhrStreamingTransport.needBody = !!global.document;
	
	module.exports = XhrStreamingTransport;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var inherits = __webpack_require__(28),
	    urlUtils = __webpack_require__(20),
	    SenderReceiver = __webpack_require__(34);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:ajax-based');
	}
	
	function createAjaxSender(AjaxObject) {
	  return function (url, payload, callback) {
	    debug('create ajax sender', url, payload);
	    var opt = {};
	    if (typeof payload === 'string') {
	      opt.headers = { 'Content-type': 'text/plain' };
	    }
	    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
	    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
	    xo.once('finish', function (status) {
	      debug('finish', status);
	      xo = null;
	
	      if (status !== 200 && status !== 204) {
	        return callback(new Error('http status ' + status));
	      }
	      callback();
	    });
	    return function () {
	      debug('abort');
	      xo.close();
	      xo = null;
	
	      var err = new Error('Aborted');
	      err.code = 1000;
	      callback(err);
	    };
	  };
	}
	
	function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
	  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
	}
	
	inherits(AjaxBasedTransport, SenderReceiver);
	
	module.exports = AjaxBasedTransport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var inherits = __webpack_require__(28),
	    urlUtils = __webpack_require__(20),
	    BufferedSender = __webpack_require__(35),
	    Polling = __webpack_require__(36);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:sender-receiver');
	}
	
	function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
	  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
	  debug(pollUrl);
	  var self = this;
	  BufferedSender.call(this, transUrl, senderFunc);
	
	  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
	  this.poll.on('message', function (msg) {
	    debug('poll message', msg);
	    self.emit('message', msg);
	  });
	  this.poll.once('close', function (code, reason) {
	    debug('poll close', code, reason);
	    self.poll = null;
	    self.emit('close', code, reason);
	    self.close();
	  });
	}
	
	inherits(SenderReceiver, BufferedSender);
	
	SenderReceiver.prototype.close = function () {
	  BufferedSender.prototype.close.call(this);
	  debug('close');
	  this.removeAllListeners();
	  if (this.poll) {
	    this.poll.abort();
	    this.poll = null;
	  }
	};
	
	module.exports = SenderReceiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var inherits = __webpack_require__(28),
	    EventEmitter = __webpack_require__(29).EventEmitter;
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:buffered-sender');
	}
	
	function BufferedSender(url, sender) {
	  debug(url);
	  EventEmitter.call(this);
	  this.sendBuffer = [];
	  this.sender = sender;
	  this.url = url;
	}
	
	inherits(BufferedSender, EventEmitter);
	
	BufferedSender.prototype.send = function (message) {
	  debug('send', message);
	  this.sendBuffer.push(message);
	  if (!this.sendStop) {
	    this.sendSchedule();
	  }
	};
	
	// For polling transports in a situation when in the message callback,
	// new message is being send. If the sending connection was started
	// before receiving one, it is possible to saturate the network and
	// timeout due to the lack of receiving socket. To avoid that we delay
	// sending messages by some small time, in order to let receiving
	// connection be started beforehand. This is only a halfmeasure and
	// does not fix the big problem, but it does make the tests go more
	// stable on slow networks.
	BufferedSender.prototype.sendScheduleWait = function () {
	  debug('sendScheduleWait');
	  var self = this;
	  var tref;
	  this.sendStop = function () {
	    debug('sendStop');
	    self.sendStop = null;
	    clearTimeout(tref);
	  };
	  tref = setTimeout(function () {
	    debug('timeout');
	    self.sendStop = null;
	    self.sendSchedule();
	  }, 25);
	};
	
	BufferedSender.prototype.sendSchedule = function () {
	  debug('sendSchedule', this.sendBuffer.length);
	  var self = this;
	  if (this.sendBuffer.length > 0) {
	    var payload = '[' + this.sendBuffer.join(',') + ']';
	    this.sendStop = this.sender(this.url, payload, function (err) {
	      self.sendStop = null;
	      if (err) {
	        debug('error', err);
	        self.emit('close', err.code || 1006, 'Sending error: ' + err);
	        self.close();
	      } else {
	        self.sendScheduleWait();
	      }
	    });
	    this.sendBuffer = [];
	  }
	};
	
	BufferedSender.prototype._cleanup = function () {
	  debug('_cleanup');
	  this.removeAllListeners();
	};
	
	BufferedSender.prototype.close = function () {
	  debug('close');
	  this._cleanup();
	  if (this.sendStop) {
	    this.sendStop();
	    this.sendStop = null;
	  }
	};
	
	module.exports = BufferedSender;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var inherits = __webpack_require__(28),
	    EventEmitter = __webpack_require__(29).EventEmitter;
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:polling');
	}
	
	function Polling(Receiver, receiveUrl, AjaxObject) {
	  debug(receiveUrl);
	  EventEmitter.call(this);
	  this.Receiver = Receiver;
	  this.receiveUrl = receiveUrl;
	  this.AjaxObject = AjaxObject;
	  this._scheduleReceiver();
	}
	
	inherits(Polling, EventEmitter);
	
	Polling.prototype._scheduleReceiver = function () {
	  debug('_scheduleReceiver');
	  var self = this;
	  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);
	
	  poll.on('message', function (msg) {
	    debug('message', msg);
	    self.emit('message', msg);
	  });
	
	  poll.once('close', function (code, reason) {
	    debug('close', code, reason, self.pollIsClosing);
	    self.poll = poll = null;
	
	    if (!self.pollIsClosing) {
	      if (reason === 'network') {
	        self._scheduleReceiver();
	      } else {
	        self.emit('close', code || 1006, reason);
	        self.removeAllListeners();
	      }
	    }
	  });
	};
	
	Polling.prototype.abort = function () {
	  debug('abort');
	  this.removeAllListeners();
	  this.pollIsClosing = true;
	  if (this.poll) {
	    this.poll.abort();
	  }
	};
	
	module.exports = Polling;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var inherits = __webpack_require__(28),
	    EventEmitter = __webpack_require__(29).EventEmitter;
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:receiver:xhr');
	}
	
	function XhrReceiver(url, AjaxObject) {
	  debug(url);
	  EventEmitter.call(this);
	  var self = this;
	
	  this.bufferPosition = 0;
	
	  this.xo = new AjaxObject('POST', url, null);
	  this.xo.on('chunk', this._chunkHandler.bind(this));
	  this.xo.once('finish', function (status, text) {
	    debug('finish', status, text);
	    self._chunkHandler(status, text);
	    self.xo = null;
	    var reason = status === 200 ? 'network' : 'permanent';
	    debug('close', reason);
	    self.emit('close', null, reason);
	    self._cleanup();
	  });
	}
	
	inherits(XhrReceiver, EventEmitter);
	
	XhrReceiver.prototype._chunkHandler = function (status, text) {
	  debug('_chunkHandler', status);
	  if (status !== 200 || !text) {
	    return;
	  }
	
	  for (var idx = -1;; this.bufferPosition += idx + 1) {
	    var buf = text.slice(this.bufferPosition);
	    idx = buf.indexOf('\n');
	    if (idx === -1) {
	      break;
	    }
	    var msg = buf.slice(0, idx);
	    if (msg) {
	      debug('message', msg);
	      this.emit('message', msg);
	    }
	  }
	};
	
	XhrReceiver.prototype._cleanup = function () {
	  debug('_cleanup');
	  this.removeAllListeners();
	};
	
	XhrReceiver.prototype.abort = function () {
	  debug('abort');
	  if (this.xo) {
	    this.xo.close();
	    debug('close');
	    this.emit('close', null, 'user');
	    this.xo = null;
	  }
	  this._cleanup();
	};
	
	module.exports = XhrReceiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(28),
	    XhrDriver = __webpack_require__(39);
	
	function XHRCorsObject(method, url, payload, opts) {
	  XhrDriver.call(this, method, url, payload, opts);
	}
	
	inherits(XHRCorsObject, XhrDriver);
	
	XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;
	
	module.exports = XHRCorsObject;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {'use strict';
	
	var EventEmitter = __webpack_require__(29).EventEmitter,
	    inherits = __webpack_require__(28),
	    utils = __webpack_require__(17),
	    urlUtils = __webpack_require__(20),
	    XHR = global.XMLHttpRequest;
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:browser:xhr');
	}
	
	function AbstractXHRObject(method, url, payload, opts) {
	  debug(method, url);
	  var self = this;
	  EventEmitter.call(this);
	
	  setTimeout(function () {
	    self._start(method, url, payload, opts);
	  }, 0);
	}
	
	inherits(AbstractXHRObject, EventEmitter);
	
	AbstractXHRObject.prototype._start = function (method, url, payload, opts) {
	  var self = this;
	
	  try {
	    this.xhr = new XHR();
	  } catch (x) {
	    // intentionally empty
	  }
	
	  if (!this.xhr) {
	    debug('no xhr');
	    this.emit('finish', 0, 'no xhr support');
	    this._cleanup();
	    return;
	  }
	
	  // several browsers cache POSTs
	  url = urlUtils.addQuery(url, 't=' + +new Date());
	
	  // Explorer tends to keep connection open, even after the
	  // tab gets closed: http://bugs.jquery.com/ticket/5280
	  this.unloadRef = utils.unloadAdd(function () {
	    debug('unload cleanup');
	    self._cleanup(true);
	  });
	  try {
	    this.xhr.open(method, url, true);
	    if (this.timeout && 'timeout' in this.xhr) {
	      this.xhr.timeout = this.timeout;
	      this.xhr.ontimeout = function () {
	        debug('xhr timeout');
	        self.emit('finish', 0, '');
	        self._cleanup(false);
	      };
	    }
	  } catch (e) {
	    debug('exception', e);
	    // IE raises an exception on wrong port.
	    this.emit('finish', 0, '');
	    this._cleanup(false);
	    return;
	  }
	
	  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
	    debug('withCredentials');
	    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
	    // "This never affects same-site requests."
	
	    this.xhr.withCredentials = 'true';
	  }
	  if (opts && opts.headers) {
	    for (var key in opts.headers) {
	      this.xhr.setRequestHeader(key, opts.headers[key]);
	    }
	  }
	
	  this.xhr.onreadystatechange = function () {
	    if (self.xhr) {
	      var x = self.xhr;
	      var text, status;
	      debug('readyState', x.readyState);
	      switch (x.readyState) {
	        case 3:
	          // IE doesn't like peeking into responseText or status
	          // on Microsoft.XMLHTTP and readystate=3
	          try {
	            status = x.status;
	            text = x.responseText;
	          } catch (e) {
	            // intentionally empty
	          }
	          debug('status', status);
	          // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
	          if (status === 1223) {
	            status = 204;
	          }
	
	          // IE does return readystate == 3 for 404 answers.
	          if (status === 200 && text && text.length > 0) {
	            debug('chunk');
	            self.emit('chunk', status, text);
	          }
	          break;
	        case 4:
	          status = x.status;
	          debug('status', status);
	          // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
	          if (status === 1223) {
	            status = 204;
	          }
	          // IE returns this for a bad port
	          // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
	          if (status === 12005 || status === 12029) {
	            status = 0;
	          }
	
	          debug('finish', status, x.responseText);
	          self.emit('finish', status, x.responseText);
	          self._cleanup(false);
	          break;
	      }
	    }
	  };
	
	  try {
	    self.xhr.send(payload);
	  } catch (e) {
	    self.emit('finish', 0, '');
	    self._cleanup(false);
	  }
	};
	
	AbstractXHRObject.prototype._cleanup = function (abort) {
	  debug('cleanup');
	  if (!this.xhr) {
	    return;
	  }
	  this.removeAllListeners();
	  utils.unloadDel(this.unloadRef);
	
	  // IE needs this field to be a function
	  this.xhr.onreadystatechange = function () {};
	  if (this.xhr.ontimeout) {
	    this.xhr.ontimeout = null;
	  }
	
	  if (abort) {
	    try {
	      this.xhr.abort();
	    } catch (x) {
	      // intentionally empty
	    }
	  }
	  this.unloadRef = this.xhr = null;
	};
	
	AbstractXHRObject.prototype.close = function () {
	  debug('close');
	  this._cleanup(true);
	};
	
	AbstractXHRObject.enabled = !!XHR;
	// override XMLHttpRequest for IE6/7
	// obfuscate to avoid firewalls
	var axo = ['Active'].concat('Object').join('X');
	if (!AbstractXHRObject.enabled && axo in global) {
	  debug('overriding xmlhttprequest');
	  XHR = function XHR() {
	    try {
	      return new global[axo]('Microsoft.XMLHTTP');
	    } catch (e) {
	      return null;
	    }
	  };
	  AbstractXHRObject.enabled = !!new XHR();
	}
	
	var cors = false;
	try {
	  cors = 'withCredentials' in new XHR();
	} catch (ignored) {
	  // intentionally empty
	}
	
	AbstractXHRObject.supportsCORS = cors;
	
	module.exports = AbstractXHRObject;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(16)))

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(28),
	    XhrDriver = __webpack_require__(39);
	
	function XHRLocalObject(method, url, payload /*, opts */) {
	  XhrDriver.call(this, method, url, payload, {
	    noCredentials: true
	  });
	}
	
	inherits(XHRLocalObject, XhrDriver);
	
	XHRLocalObject.enabled = XhrDriver.enabled;
	
	module.exports = XHRLocalObject;

/***/ },
/* 41 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = {
	  isOpera: function isOpera() {
	    return global.navigator && /opera/i.test(global.navigator.userAgent);
	  },
	
	  isKonqueror: function isKonqueror() {
	    return global.navigator && /konqueror/i.test(global.navigator.userAgent);
	  }
	
	  // #187 wrap document.domain in try/catch because of WP8 from file:///
	  , hasDomain: function hasDomain() {
	    // non-browser client always has a domain
	    if (!global.document) {
	      return true;
	    }
	
	    try {
	      return !!global.document.domain;
	    } catch (e) {
	      return false;
	    }
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(28),
	    AjaxBasedTransport = __webpack_require__(33),
	    XhrReceiver = __webpack_require__(37),
	    XDRObject = __webpack_require__(43);
	
	// According to:
	//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
	//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/
	
	function XdrStreamingTransport(transUrl) {
	  if (!XDRObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
	}
	
	inherits(XdrStreamingTransport, AjaxBasedTransport);
	
	XdrStreamingTransport.enabled = function (info) {
	  if (info.cookie_needed || info.nullOrigin) {
	    return false;
	  }
	  return XDRObject.enabled && info.sameScheme;
	};
	
	XdrStreamingTransport.transportName = 'xdr-streaming';
	XdrStreamingTransport.roundTrips = 2; // preflight, ajax
	
	module.exports = XdrStreamingTransport;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var EventEmitter = __webpack_require__(29).EventEmitter,
	    inherits = __webpack_require__(28),
	    eventUtils = __webpack_require__(17),
	    browser = __webpack_require__(41),
	    urlUtils = __webpack_require__(20);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:sender:xdr');
	}
	
	// References:
	//   http://ajaxian.com/archives/100-line-ajax-wrapper
	//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx
	
	function XDRObject(method, url, payload) {
	  debug(method, url);
	  var self = this;
	  EventEmitter.call(this);
	
	  setTimeout(function () {
	    self._start(method, url, payload);
	  }, 0);
	}
	
	inherits(XDRObject, EventEmitter);
	
	XDRObject.prototype._start = function (method, url, payload) {
	  debug('_start');
	  var self = this;
	  var xdr = new global.XDomainRequest();
	  // IE caches even POSTs
	  url = urlUtils.addQuery(url, 't=' + +new Date());
	
	  xdr.onerror = function () {
	    debug('onerror');
	    self._error();
	  };
	  xdr.ontimeout = function () {
	    debug('ontimeout');
	    self._error();
	  };
	  xdr.onprogress = function () {
	    debug('progress', xdr.responseText);
	    self.emit('chunk', 200, xdr.responseText);
	  };
	  xdr.onload = function () {
	    debug('load');
	    self.emit('finish', 200, xdr.responseText);
	    self._cleanup(false);
	  };
	  this.xdr = xdr;
	  this.unloadRef = eventUtils.unloadAdd(function () {
	    self._cleanup(true);
	  });
	  try {
	    // Fails with AccessDenied if port number is bogus
	    this.xdr.open(method, url);
	    if (this.timeout) {
	      this.xdr.timeout = this.timeout;
	    }
	    this.xdr.send(payload);
	  } catch (x) {
	    this._error();
	  }
	};
	
	XDRObject.prototype._error = function () {
	  this.emit('finish', 0, '');
	  this._cleanup(false);
	};
	
	XDRObject.prototype._cleanup = function (abort) {
	  debug('cleanup', abort);
	  if (!this.xdr) {
	    return;
	  }
	  this.removeAllListeners();
	  eventUtils.unloadDel(this.unloadRef);
	
	  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
	  if (abort) {
	    try {
	      this.xdr.abort();
	    } catch (x) {
	      // intentionally empty
	    }
	  }
	  this.unloadRef = this.xdr = null;
	};
	
	XDRObject.prototype.close = function () {
	  debug('close');
	  this._cleanup(true);
	};
	
	// IE 8/9 if the request target uses the same scheme - #79
	XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());
	
	module.exports = XDRObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16), (function() { return this; }())))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(28),
	    AjaxBasedTransport = __webpack_require__(33),
	    EventSourceReceiver = __webpack_require__(45),
	    XHRCorsObject = __webpack_require__(38),
	    EventSourceDriver = __webpack_require__(46);
	
	function EventSourceTransport(transUrl) {
	  if (!EventSourceTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	
	  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
	}
	
	inherits(EventSourceTransport, AjaxBasedTransport);
	
	EventSourceTransport.enabled = function () {
	  return !!EventSourceDriver;
	};
	
	EventSourceTransport.transportName = 'eventsource';
	EventSourceTransport.roundTrips = 2;
	
	module.exports = EventSourceTransport;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var inherits = __webpack_require__(28),
	    EventEmitter = __webpack_require__(29).EventEmitter,
	    EventSourceDriver = __webpack_require__(46);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:receiver:eventsource');
	}
	
	function EventSourceReceiver(url) {
	  debug(url);
	  EventEmitter.call(this);
	
	  var self = this;
	  var es = this.es = new EventSourceDriver(url);
	  es.onmessage = function (e) {
	    debug('message', e.data);
	    self.emit('message', decodeURI(e.data));
	  };
	  es.onerror = function (e) {
	    debug('error', es.readyState, e);
	    // ES on reconnection has readyState = 0 or 1.
	    // on network error it's CLOSED = 2
	    var reason = es.readyState !== 2 ? 'network' : 'permanent';
	    self._cleanup();
	    self._close(reason);
	  };
	}
	
	inherits(EventSourceReceiver, EventEmitter);
	
	EventSourceReceiver.prototype.abort = function () {
	  debug('abort');
	  this._cleanup();
	  this._close('user');
	};
	
	EventSourceReceiver.prototype._cleanup = function () {
	  debug('cleanup');
	  var es = this.es;
	  if (es) {
	    es.onmessage = es.onerror = null;
	    es.close();
	    this.es = null;
	  }
	};
	
	EventSourceReceiver.prototype._close = function (reason) {
	  debug('close', reason);
	  var self = this;
	  // Safari and chrome < 15 crash if we close window before
	  // waiting for ES cleanup. See:
	  // https://code.google.com/p/chromium/issues/detail?id=89155
	  setTimeout(function () {
	    self.emit('close', null, reason);
	    self.removeAllListeners();
	  }, 200);
	};
	
	module.exports = EventSourceReceiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 46 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	module.exports = global.EventSource;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var inherits = __webpack_require__(28),
	    IframeTransport = __webpack_require__(48),
	    objectUtils = __webpack_require__(52);
	
	module.exports = function (transport) {
	
	  function IframeWrapTransport(transUrl, baseUrl) {
	    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
	  }
	
	  inherits(IframeWrapTransport, IframeTransport);
	
	  IframeWrapTransport.enabled = function (url, info) {
	    if (!global.document) {
	      return false;
	    }
	
	    var iframeInfo = objectUtils.extend({}, info);
	    iframeInfo.sameOrigin = true;
	    return transport.enabled(iframeInfo) && IframeTransport.enabled();
	  };
	
	  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
	  IframeWrapTransport.needBody = true;
	  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)
	
	  IframeWrapTransport.facadeTransport = transport;
	
	  return IframeWrapTransport;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	// Few cool transports do work only for same-origin. In order to make
	// them work cross-domain we shall use iframe, served from the
	// remote domain. New browsers have capabilities to communicate with
	// cross domain iframe using postMessage(). In IE it was implemented
	// from IE 8+, but of course, IE got some details wrong:
	//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
	//    http://stevesouders.com/misc/test-postmessage.php
	
	var inherits = __webpack_require__(28),
	    JSON3 = __webpack_require__(49),
	    EventEmitter = __webpack_require__(29).EventEmitter,
	    version = __webpack_require__(50),
	    urlUtils = __webpack_require__(20),
	    iframeUtils = __webpack_require__(51),
	    eventUtils = __webpack_require__(17),
	    random = __webpack_require__(18);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:transport:iframe');
	}
	
	function IframeTransport(transport, transUrl, baseUrl) {
	  if (!IframeTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	  EventEmitter.call(this);
	
	  var self = this;
	  this.origin = urlUtils.getOrigin(baseUrl);
	  this.baseUrl = baseUrl;
	  this.transUrl = transUrl;
	  this.transport = transport;
	  this.windowId = random.string(8);
	
	  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
	  debug(transport, transUrl, iframeUrl);
	
	  this.iframeObj = iframeUtils.createIframe(iframeUrl, function (r) {
	    debug('err callback');
	    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
	    self.close();
	  });
	
	  this.onmessageCallback = this._message.bind(this);
	  eventUtils.attachEvent('message', this.onmessageCallback);
	}
	
	inherits(IframeTransport, EventEmitter);
	
	IframeTransport.prototype.close = function () {
	  debug('close');
	  this.removeAllListeners();
	  if (this.iframeObj) {
	    eventUtils.detachEvent('message', this.onmessageCallback);
	    try {
	      // When the iframe is not loaded, IE raises an exception
	      // on 'contentWindow'.
	      this.postMessage('c');
	    } catch (x) {
	      // intentionally empty
	    }
	    this.iframeObj.cleanup();
	    this.iframeObj = null;
	    this.onmessageCallback = this.iframeObj = null;
	  }
	};
	
	IframeTransport.prototype._message = function (e) {
	  debug('message', e.data);
	  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
	    debug('not same origin', e.origin, this.origin);
	    return;
	  }
	
	  var iframeMessage;
	  try {
	    iframeMessage = JSON3.parse(e.data);
	  } catch (ignored) {
	    debug('bad json', e.data);
	    return;
	  }
	
	  if (iframeMessage.windowId !== this.windowId) {
	    debug('mismatched window id', iframeMessage.windowId, this.windowId);
	    return;
	  }
	
	  switch (iframeMessage.type) {
	    case 's':
	      this.iframeObj.loaded();
	      // window global dependency
	      this.postMessage('s', JSON3.stringify([version, this.transport, this.transUrl, this.baseUrl]));
	      break;
	    case 't':
	      this.emit('message', iframeMessage.data);
	      break;
	    case 'c':
	      var cdata;
	      try {
	        cdata = JSON3.parse(iframeMessage.data);
	      } catch (ignored) {
	        debug('bad json', iframeMessage.data);
	        return;
	      }
	      this.emit('close', cdata[0], cdata[1]);
	      this.close();
	      break;
	  }
	};
	
	IframeTransport.prototype.postMessage = function (type, data) {
	  debug('postMessage', type, data);
	  this.iframeObj.post(JSON3.stringify({
	    windowId: this.windowId,
	    type: type,
	    data: data || ''
	  }), this.origin);
	};
	
	IframeTransport.prototype.send = function (message) {
	  debug('send', message);
	  this.postMessage('m', message);
	};
	
	IframeTransport.enabled = function () {
	  return iframeUtils.iframeEnabled;
	};
	
	IframeTransport.transportName = 'iframe';
	IframeTransport.roundTrips = 2;
	
	module.exports = IframeTransport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(5);
	
	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };
	
	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[ false ? "undefined" : _typeof(exports)] && exports && !exports.nodeType && exports;
	
	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window === "undefined" ? "undefined" : _typeof(window)] && window || this,
	      freeGlobal = freeExports && objectTypes[ false ? "undefined" : _typeof(module)] && module && !module.nodeType && (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global;
	
	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());
	
	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];
	
	    // Delegate to the native `stringify` and `parse` implementations.
	    if ((typeof nativeJSON === "undefined" ? "undefined" : _typeof(nativeJSON)) == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }
	
	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        _isProperty,
	        _forEach,
	        undef;
	
	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	      // Safari < 2.0.2 stores the internal millisecond time value correctly,
	      // but clips the values returned by the date methods to the range of
	      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}
	
	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value,
	            serialized = "{\"a\":[1,true,false,null,\"\\u0000\\b\\n\\f\\r\\t\"]}";
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify,
	              stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function value() {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	              // Firefox 3.1b1 and b2 serialize string, number, and boolean
	              // primitives as object literals.
	              stringify(0) === "0" &&
	              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	              // literals.
	              stringify(new Number()) === "0" && stringify(new String()) == '""' &&
	              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	              // does not define a canonical JSON representation (this applies to
	              // objects with `toJSON` properties as well, *unless* they are nested
	              // within an object or array).
	              stringify(getClass) === undef &&
	              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	              // FF 3.1b3 pass this test.
	              stringify(undef) === undef &&
	              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	              // respectively, if the value is omitted entirely.
	              stringify() === undef &&
	              // FF 3.1b1, 2 throw an error if the given value is not a number,
	              // string, array, object, Boolean, or `null` literal. This applies to
	              // objects with custom `toJSON` methods as well, unless they are nested
	              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	              // methods entirely.
	              stringify(value) === "1" && stringify([value]) == "[1]" &&
	              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	              // `"[null]"`.
	              stringify([undef]) == "[null]" &&
	              // YUI 3.0.0b1 fails to serialize `null` literals.
	              stringify(null) == "null" &&
	              // FF 3.1b1, 2 halts serialization if an array contains a function:
	              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	              // elides non-JSON values from objects and arrays, unless they
	              // define custom `toJSON` methods.
	              stringify([undef, getClass, null]) == "[null,null,null]" &&
	              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	              // where character escape codes are expected (e.g., `\b` => `\u0008`).
	              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	              stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	              // serialize extended years.
	              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	              // The milliseconds are optional in ES 5, but required in 5.1.
	              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	              // four-digit years instead of six-digit years. Credits: @Yaffle.
	              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	              // values less than 1000. Credits: @Yaffle.
	              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }
	
	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";
	
	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");
	
	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function getDay(year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }
	
	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(_isProperty = objectProto.hasOwnProperty)) {
	        _isProperty = function isProperty(property) {
	          var members = {},
	              constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            _isProperty = function isProperty(property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__,
	                  result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            _isProperty = function isProperty(property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return _isProperty.call(this, property);
	        };
	      }
	
	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      _forEach = function forEach(object, callback) {
	        var size = 0,
	            Properties,
	            members,
	            property;
	
	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function Properties() {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;
	
	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (_isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;
	
	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          _forEach = function forEach(object, callback) {
	            var isFunction = getClass.call(object) == functionClass,
	                property,
	                length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[_typeof(object.hasOwnProperty)] && object.hasOwnProperty || _isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) {}
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          _forEach = function forEach(object, callback) {
	            // Create a set of iterated properties.
	            var members = {},
	                isFunction = getClass.call(object) == functionClass,
	                property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !_isProperty.call(members, property) && (members[property] = 1) && _isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          _forEach = function forEach(object, callback) {
	            var isFunction = getClass.call(object) == functionClass,
	                property,
	                isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && _isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || _isProperty.call(object, property = "constructor")) {
	              callback(property);
	            }
	          };
	        }
	        return _forEach(object, callback);
	      };
	
	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };
	
	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function toPaddedString(width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };
	
	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function quote(value) {
	          var result = '"',
	              index = 0,
	              length = value.length,
	              useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8:case 9:case 10:case 12:case 13:case 34:case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };
	
	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !_isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {}
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {}
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                // Months, dates, hours, minutes, and seconds should have two
	                // digits; milliseconds should have three.
	                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                // Milliseconds are optional in ES 5.0, but required in 5.1.
	                "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && (className != numberClass && className != stringClass && className != arrayClass || _isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              _forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };
	
	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter === "undefined" ? "undefined" : _typeof(filter)] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1)) {}
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ") {}
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }
	
	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;
	
	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };
	
	        // Internal: Stores the parser state.
	        var Index, Source;
	
	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function abort() {
	          Index = Source = null;
	          throw SyntaxError();
	        };
	
	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function lex() {
	          var source = Source,
	              length = source.length,
	              value,
	              begin,
	              position,
	              isSigned,
	              charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9:case 10:case 13:case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123:case 125:case 91:case 93:case 58:case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {}
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };
	
	        // Internal: Parses a JSON `value` token.
	        var get = function get(value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };
	
	        // Internal: Updates a traversed object member.
	        var update = function update(source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };
	
	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function walk(source, property, callback) {
	          var value = source[property],
	              length;
	          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              _forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };
	
	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }
	
	    exports["runInContext"] = runInContext;
	    return exports;
	  }
	
	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;
	
	    var JSON3 = runInContext(root, root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function noConflict() {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    });
	
	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }
	
	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module), (function() { return this; }())))

/***/ },
/* 50 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = '1.1.2';

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var eventUtils = __webpack_require__(17),
	    JSON3 = __webpack_require__(49),
	    browser = __webpack_require__(41);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:utils:iframe');
	}
	
	module.exports = {
	  WPrefix: '_jp',
	  currentWindowId: null,
	
	  polluteGlobalNamespace: function polluteGlobalNamespace() {
	    if (!(module.exports.WPrefix in global)) {
	      global[module.exports.WPrefix] = {};
	    }
	  },
	
	  postMessage: function postMessage(type, data) {
	    if (global.parent !== global) {
	      global.parent.postMessage(JSON3.stringify({
	        windowId: module.exports.currentWindowId,
	        type: type,
	        data: data || ''
	      }), '*');
	    } else {
	      debug('Cannot postMessage, no parent window.', type, data);
	    }
	  },
	
	  createIframe: function createIframe(iframeUrl, errorCallback) {
	    var iframe = global.document.createElement('iframe');
	    var tref, unloadRef;
	    var unattach = function unattach() {
	      debug('unattach');
	      clearTimeout(tref);
	      // Explorer had problems with that.
	      try {
	        iframe.onload = null;
	      } catch (x) {
	        // intentionally empty
	      }
	      iframe.onerror = null;
	    };
	    var cleanup = function cleanup() {
	      debug('cleanup');
	      if (iframe) {
	        unattach();
	        // This timeout makes chrome fire onbeforeunload event
	        // within iframe. Without the timeout it goes straight to
	        // onunload.
	        setTimeout(function () {
	          if (iframe) {
	            iframe.parentNode.removeChild(iframe);
	          }
	          iframe = null;
	        }, 0);
	        eventUtils.unloadDel(unloadRef);
	      }
	    };
	    var onerror = function onerror(err) {
	      debug('onerror', err);
	      if (iframe) {
	        cleanup();
	        errorCallback(err);
	      }
	    };
	    var post = function post(msg, origin) {
	      debug('post', msg, origin);
	      try {
	        // When the iframe is not loaded, IE raises an exception
	        // on 'contentWindow'.
	        setTimeout(function () {
	          if (iframe && iframe.contentWindow) {
	            iframe.contentWindow.postMessage(msg, origin);
	          }
	        }, 0);
	      } catch (x) {
	        // intentionally empty
	      }
	    };
	
	    iframe.src = iframeUrl;
	    iframe.style.display = 'none';
	    iframe.style.position = 'absolute';
	    iframe.onerror = function () {
	      onerror('onerror');
	    };
	    iframe.onload = function () {
	      debug('onload');
	      // `onload` is triggered before scripts on the iframe are
	      // executed. Give it few seconds to actually load stuff.
	      clearTimeout(tref);
	      tref = setTimeout(function () {
	        onerror('onload timeout');
	      }, 2000);
	    };
	    global.document.body.appendChild(iframe);
	    tref = setTimeout(function () {
	      onerror('timeout');
	    }, 15000);
	    unloadRef = eventUtils.unloadAdd(cleanup);
	    return {
	      post: post,
	      cleanup: cleanup,
	      loaded: unattach
	    };
	  }
	
	  /* eslint no-undef: "off", new-cap: "off" */
	  , createHtmlfile: function createHtmlfile(iframeUrl, errorCallback) {
	    var axo = ['Active'].concat('Object').join('X');
	    var doc = new global[axo]('htmlfile');
	    var tref, unloadRef;
	    var iframe;
	    var unattach = function unattach() {
	      clearTimeout(tref);
	      iframe.onerror = null;
	    };
	    var cleanup = function cleanup() {
	      if (doc) {
	        unattach();
	        eventUtils.unloadDel(unloadRef);
	        iframe.parentNode.removeChild(iframe);
	        iframe = doc = null;
	        CollectGarbage();
	      }
	    };
	    var onerror = function onerror(r) {
	      debug('onerror', r);
	      if (doc) {
	        cleanup();
	        errorCallback(r);
	      }
	    };
	    var post = function post(msg, origin) {
	      try {
	        // When the iframe is not loaded, IE raises an exception
	        // on 'contentWindow'.
	        setTimeout(function () {
	          if (iframe && iframe.contentWindow) {
	            iframe.contentWindow.postMessage(msg, origin);
	          }
	        }, 0);
	      } catch (x) {
	        // intentionally empty
	      }
	    };
	
	    doc.open();
	    doc.write('<html><s' + 'cript>' + 'document.domain="' + global.document.domain + '";' + '</s' + 'cript></html>');
	    doc.close();
	    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
	    var c = doc.createElement('div');
	    doc.body.appendChild(c);
	    iframe = doc.createElement('iframe');
	    c.appendChild(iframe);
	    iframe.src = iframeUrl;
	    iframe.onerror = function () {
	      onerror('onerror');
	    };
	    tref = setTimeout(function () {
	      onerror('timeout');
	    }, 15000);
	    unloadRef = eventUtils.unloadAdd(cleanup);
	    return {
	      post: post,
	      cleanup: cleanup,
	      loaded: unattach
	    };
	  }
	};
	
	module.exports.iframeEnabled = false;
	if (global.document) {
	  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
	  // huge delay, or not at all.
	  module.exports.iframeEnabled = (typeof global.postMessage === 'function' || _typeof(global.postMessage) === 'object') && !browser.isKonqueror();
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16), (function() { return this; }())))

/***/ },
/* 52 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = {
	  isObject: function isObject(obj) {
	    var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
	    return type === 'function' || type === 'object' && !!obj;
	  },
	
	  extend: function extend(obj) {
	    if (!this.isObject(obj)) {
	      return obj;
	    }
	    var source, prop;
	    for (var i = 1, length = arguments.length; i < length; i++) {
	      source = arguments[i];
	      for (prop in source) {
	        if (Object.prototype.hasOwnProperty.call(source, prop)) {
	          obj[prop] = source[prop];
	        }
	      }
	    }
	    return obj;
	  }
	};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(28),
	    HtmlfileReceiver = __webpack_require__(54),
	    XHRLocalObject = __webpack_require__(40),
	    AjaxBasedTransport = __webpack_require__(33);
	
	function HtmlFileTransport(transUrl) {
	  if (!HtmlfileReceiver.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
	}
	
	inherits(HtmlFileTransport, AjaxBasedTransport);
	
	HtmlFileTransport.enabled = function (info) {
	  return HtmlfileReceiver.enabled && info.sameOrigin;
	};
	
	HtmlFileTransport.transportName = 'htmlfile';
	HtmlFileTransport.roundTrips = 2;
	
	module.exports = HtmlFileTransport;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var inherits = __webpack_require__(28),
	    iframeUtils = __webpack_require__(51),
	    urlUtils = __webpack_require__(20),
	    EventEmitter = __webpack_require__(29).EventEmitter,
	    random = __webpack_require__(18);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:receiver:htmlfile');
	}
	
	function HtmlfileReceiver(url) {
	  debug(url);
	  EventEmitter.call(this);
	  var self = this;
	  iframeUtils.polluteGlobalNamespace();
	
	  this.id = 'a' + random.string(6);
	  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));
	
	  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
	  var constructFunc = HtmlfileReceiver.htmlfileEnabled ? iframeUtils.createHtmlfile : iframeUtils.createIframe;
	
	  global[iframeUtils.WPrefix][this.id] = {
	    start: function start() {
	      debug('start');
	      self.iframeObj.loaded();
	    },
	    message: function message(data) {
	      debug('message', data);
	      self.emit('message', data);
	    },
	    stop: function stop() {
	      debug('stop');
	      self._cleanup();
	      self._close('network');
	    }
	  };
	  this.iframeObj = constructFunc(url, function () {
	    debug('callback');
	    self._cleanup();
	    self._close('permanent');
	  });
	}
	
	inherits(HtmlfileReceiver, EventEmitter);
	
	HtmlfileReceiver.prototype.abort = function () {
	  debug('abort');
	  this._cleanup();
	  this._close('user');
	};
	
	HtmlfileReceiver.prototype._cleanup = function () {
	  debug('_cleanup');
	  if (this.iframeObj) {
	    this.iframeObj.cleanup();
	    this.iframeObj = null;
	  }
	  delete global[iframeUtils.WPrefix][this.id];
	};
	
	HtmlfileReceiver.prototype._close = function (reason) {
	  debug('_close', reason);
	  this.emit('close', null, reason);
	  this.removeAllListeners();
	};
	
	HtmlfileReceiver.htmlfileEnabled = false;
	
	// obfuscate to avoid firewalls
	var axo = ['Active'].concat('Object').join('X');
	if (axo in global) {
	  try {
	    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
	  } catch (x) {
	    // intentionally empty
	  }
	}
	
	HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;
	
	module.exports = HtmlfileReceiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16), (function() { return this; }())))

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(28),
	    AjaxBasedTransport = __webpack_require__(33),
	    XhrReceiver = __webpack_require__(37),
	    XHRCorsObject = __webpack_require__(38),
	    XHRLocalObject = __webpack_require__(40);
	
	function XhrPollingTransport(transUrl) {
	  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
	}
	
	inherits(XhrPollingTransport, AjaxBasedTransport);
	
	XhrPollingTransport.enabled = function (info) {
	  if (info.nullOrigin) {
	    return false;
	  }
	
	  if (XHRLocalObject.enabled && info.sameOrigin) {
	    return true;
	  }
	  return XHRCorsObject.enabled;
	};
	
	XhrPollingTransport.transportName = 'xhr-polling';
	XhrPollingTransport.roundTrips = 2; // preflight, ajax
	
	module.exports = XhrPollingTransport;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(28),
	    AjaxBasedTransport = __webpack_require__(33),
	    XdrStreamingTransport = __webpack_require__(42),
	    XhrReceiver = __webpack_require__(37),
	    XDRObject = __webpack_require__(43);
	
	function XdrPollingTransport(transUrl) {
	  if (!XDRObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
	}
	
	inherits(XdrPollingTransport, AjaxBasedTransport);
	
	XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
	XdrPollingTransport.transportName = 'xdr-polling';
	XdrPollingTransport.roundTrips = 2; // preflight, ajax
	
	module.exports = XdrPollingTransport;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	// The simplest and most robust transport, using the well-know cross
	// domain hack - JSONP. This transport is quite inefficient - one
	// message could use up to one http request. But at least it works almost
	// everywhere.
	// Known limitations:
	//   o you will get a spinning cursor
	//   o for Konqueror a dumb timer is needed to detect errors
	
	var inherits = __webpack_require__(28),
	    SenderReceiver = __webpack_require__(34),
	    JsonpReceiver = __webpack_require__(58),
	    jsonpSender = __webpack_require__(59);
	
	function JsonPTransport(transUrl) {
	  if (!JsonPTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
	}
	
	inherits(JsonPTransport, SenderReceiver);
	
	JsonPTransport.enabled = function () {
	  return !!global.document;
	};
	
	JsonPTransport.transportName = 'jsonp-polling';
	JsonPTransport.roundTrips = 1;
	JsonPTransport.needBody = true;
	
	module.exports = JsonPTransport;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var utils = __webpack_require__(51),
	    random = __webpack_require__(18),
	    browser = __webpack_require__(41),
	    urlUtils = __webpack_require__(20),
	    inherits = __webpack_require__(28),
	    EventEmitter = __webpack_require__(29).EventEmitter;
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:receiver:jsonp');
	}
	
	function JsonpReceiver(url) {
	  debug(url);
	  var self = this;
	  EventEmitter.call(this);
	
	  utils.polluteGlobalNamespace();
	
	  this.id = 'a' + random.string(6);
	  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));
	
	  global[utils.WPrefix][this.id] = this._callback.bind(this);
	  this._createScript(urlWithId);
	
	  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
	  this.timeoutId = setTimeout(function () {
	    debug('timeout');
	    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
	  }, JsonpReceiver.timeout);
	}
	
	inherits(JsonpReceiver, EventEmitter);
	
	JsonpReceiver.prototype.abort = function () {
	  debug('abort');
	  if (global[utils.WPrefix][this.id]) {
	    var err = new Error('JSONP user aborted read');
	    err.code = 1000;
	    this._abort(err);
	  }
	};
	
	JsonpReceiver.timeout = 35000;
	JsonpReceiver.scriptErrorTimeout = 1000;
	
	JsonpReceiver.prototype._callback = function (data) {
	  debug('_callback', data);
	  this._cleanup();
	
	  if (this.aborting) {
	    return;
	  }
	
	  if (data) {
	    debug('message', data);
	    this.emit('message', data);
	  }
	  this.emit('close', null, 'network');
	  this.removeAllListeners();
	};
	
	JsonpReceiver.prototype._abort = function (err) {
	  debug('_abort', err);
	  this._cleanup();
	  this.aborting = true;
	  this.emit('close', err.code, err.message);
	  this.removeAllListeners();
	};
	
	JsonpReceiver.prototype._cleanup = function () {
	  debug('_cleanup');
	  clearTimeout(this.timeoutId);
	  if (this.script2) {
	    this.script2.parentNode.removeChild(this.script2);
	    this.script2 = null;
	  }
	  if (this.script) {
	    var script = this.script;
	    // Unfortunately, you can't really abort script loading of
	    // the script.
	    script.parentNode.removeChild(script);
	    script.onreadystatechange = script.onerror = script.onload = script.onclick = null;
	    this.script = null;
	  }
	  delete global[utils.WPrefix][this.id];
	};
	
	JsonpReceiver.prototype._scriptError = function () {
	  debug('_scriptError');
	  var self = this;
	  if (this.errorTimer) {
	    return;
	  }
	
	  this.errorTimer = setTimeout(function () {
	    if (!self.loadedOkay) {
	      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
	    }
	  }, JsonpReceiver.scriptErrorTimeout);
	};
	
	JsonpReceiver.prototype._createScript = function (url) {
	  debug('_createScript', url);
	  var self = this;
	  var script = this.script = global.document.createElement('script');
	  var script2; // Opera synchronous load trick.
	
	  script.id = 'a' + random.string(8);
	  script.src = url;
	  script.type = 'text/javascript';
	  script.charset = 'UTF-8';
	  script.onerror = this._scriptError.bind(this);
	  script.onload = function () {
	    debug('onload');
	    self._abort(new Error('JSONP script loaded abnormally (onload)'));
	  };
	
	  // IE9 fires 'error' event after onreadystatechange or before, in random order.
	  // Use loadedOkay to determine if actually errored
	  script.onreadystatechange = function () {
	    debug('onreadystatechange', script.readyState);
	    if (/loaded|closed/.test(script.readyState)) {
	      if (script && script.htmlFor && script.onclick) {
	        self.loadedOkay = true;
	        try {
	          // In IE, actually execute the script.
	          script.onclick();
	        } catch (x) {
	          // intentionally empty
	        }
	      }
	      if (script) {
	        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
	      }
	    }
	  };
	  // IE: event/htmlFor/onclick trick.
	  // One can't rely on proper order for onreadystatechange. In order to
	  // make sure, set a 'htmlFor' and 'event' properties, so that
	  // script code will be installed as 'onclick' handler for the
	  // script object. Later, onreadystatechange, manually execute this
	  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
	  // set. For reference see:
	  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
	  // Also, read on that about script ordering:
	  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
	  if (typeof script.async === 'undefined' && global.document.attachEvent) {
	    // According to mozilla docs, in recent browsers script.async defaults
	    // to 'true', so we may use it to detect a good browser:
	    // https://developer.mozilla.org/en/HTML/Element/script
	    if (!browser.isOpera()) {
	      // Naively assume we're in IE
	      try {
	        script.htmlFor = script.id;
	        script.event = 'onclick';
	      } catch (x) {
	        // intentionally empty
	      }
	      script.async = true;
	    } else {
	      // Opera, second sync script hack
	      script2 = this.script2 = global.document.createElement('script');
	      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
	      script.async = script2.async = false;
	    }
	  }
	  if (typeof script.async !== 'undefined') {
	    script.async = true;
	  }
	
	  var head = global.document.getElementsByTagName('head')[0];
	  head.insertBefore(script, head.firstChild);
	  if (script2) {
	    head.insertBefore(script2, head.firstChild);
	  }
	};
	
	module.exports = JsonpReceiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16), (function() { return this; }())))

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var random = __webpack_require__(18),
	    urlUtils = __webpack_require__(20);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:sender:jsonp');
	}
	
	var form, area;
	
	function createIframe(id) {
	  debug('createIframe', id);
	  try {
	    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	    return global.document.createElement('<iframe name="' + id + '">');
	  } catch (x) {
	    var iframe = global.document.createElement('iframe');
	    iframe.name = id;
	    return iframe;
	  }
	}
	
	function createForm() {
	  debug('createForm');
	  form = global.document.createElement('form');
	  form.style.display = 'none';
	  form.style.position = 'absolute';
	  form.method = 'POST';
	  form.enctype = 'application/x-www-form-urlencoded';
	  form.acceptCharset = 'UTF-8';
	
	  area = global.document.createElement('textarea');
	  area.name = 'd';
	  form.appendChild(area);
	
	  global.document.body.appendChild(form);
	}
	
	module.exports = function (url, payload, callback) {
	  debug(url, payload);
	  if (!form) {
	    createForm();
	  }
	  var id = 'a' + random.string(8);
	  form.target = id;
	  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);
	
	  var iframe = createIframe(id);
	  iframe.id = id;
	  iframe.style.display = 'none';
	  form.appendChild(iframe);
	
	  try {
	    area.value = payload;
	  } catch (e) {
	    // seriously broken browsers get here
	  }
	  form.submit();
	
	  var completed = function completed(err) {
	    debug('completed', id, err);
	    if (!iframe.onerror) {
	      return;
	    }
	    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
	    // Opera mini doesn't like if we GC iframe
	    // immediately, thus this timeout.
	    setTimeout(function () {
	      debug('cleaning up', id);
	      iframe.parentNode.removeChild(iframe);
	      iframe = null;
	    }, 500);
	    area.value = '';
	    // It is not possible to detect if the iframe succeeded or
	    // failed to submit our form.
	    callback(err);
	  };
	  iframe.onerror = function () {
	    debug('onerror', id);
	    completed();
	  };
	  iframe.onload = function () {
	    debug('onload', id);
	    completed();
	  };
	  iframe.onreadystatechange = function (e) {
	    debug('onreadystatechange', id, iframe.readyState, e);
	    if (iframe.readyState === 'complete') {
	      completed();
	    }
	  };
	  return function () {
	    debug('aborted', id);
	    completed(new Error('Aborted'));
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16), (function() { return this; }())))

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	__webpack_require__(61);
	
	var URL = __webpack_require__(21),
	    inherits = __webpack_require__(28),
	    JSON3 = __webpack_require__(49),
	    random = __webpack_require__(18),
	    escape = __webpack_require__(62),
	    urlUtils = __webpack_require__(20),
	    eventUtils = __webpack_require__(17),
	    transport = __webpack_require__(63),
	    objectUtils = __webpack_require__(52),
	    browser = __webpack_require__(41),
	    log = __webpack_require__(64),
	    Event = __webpack_require__(65),
	    EventTarget = __webpack_require__(30),
	    loc = __webpack_require__(66),
	    CloseEvent = __webpack_require__(67),
	    TransportMessageEvent = __webpack_require__(68),
	    InfoReceiver = __webpack_require__(69);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:main');
	}
	
	var transports;
	
	// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
	function SockJS(url, protocols, options) {
	  if (!(this instanceof SockJS)) {
	    return new SockJS(url, protocols, options);
	  }
	  if (arguments.length < 1) {
	    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
	  }
	  EventTarget.call(this);
	
	  this.readyState = SockJS.CONNECTING;
	  this.extensions = '';
	  this.protocol = '';
	
	  // non-standard extension
	  options = options || {};
	  if (options.protocols_whitelist) {
	    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
	  }
	  this._transportsWhitelist = options.transports;
	  this._transportOptions = options.transportOptions || {};
	
	  var sessionId = options.sessionId || 8;
	  if (typeof sessionId === 'function') {
	    this._generateSessionId = sessionId;
	  } else if (typeof sessionId === 'number') {
	    this._generateSessionId = function () {
	      return random.string(sessionId);
	    };
	  } else {
	    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
	  }
	
	  this._server = options.server || random.numberString(1000);
	
	  // Step 1 of WS spec - parse and validate the url. Issue #8
	  var parsedUrl = new URL(url);
	  if (!parsedUrl.host || !parsedUrl.protocol) {
	    throw new SyntaxError("The URL '" + url + "' is invalid");
	  } else if (parsedUrl.hash) {
	    throw new SyntaxError('The URL must not contain a fragment');
	  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
	    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
	  }
	
	  var secure = parsedUrl.protocol === 'https:';
	  // Step 2 - don't allow secure origin with an insecure protocol
	  if (loc.protocol === 'https' && !secure) {
	    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
	  }
	
	  // Step 3 - check port access - no need here
	  // Step 4 - parse protocols argument
	  if (!protocols) {
	    protocols = [];
	  } else if (!Array.isArray(protocols)) {
	    protocols = [protocols];
	  }
	
	  // Step 5 - check protocols argument
	  var sortedProtocols = protocols.sort();
	  sortedProtocols.forEach(function (proto, i) {
	    if (!proto) {
	      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
	    }
	    if (i < sortedProtocols.length - 1 && proto === sortedProtocols[i + 1]) {
	      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
	    }
	  });
	
	  // Step 6 - convert origin
	  var o = urlUtils.getOrigin(loc.href);
	  this._origin = o ? o.toLowerCase() : null;
	
	  // remove the trailing slash
	  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));
	
	  // store the sanitized url
	  this.url = parsedUrl.href;
	  debug('using url', this.url);
	
	  // Step 7 - start connection in background
	  // obtain server info
	  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
	  this._urlInfo = {
	    nullOrigin: !browser.hasDomain(),
	    sameOrigin: urlUtils.isOriginEqual(this.url, loc.href),
	    sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
	  };
	
	  this._ir = new InfoReceiver(this.url, this._urlInfo);
	  this._ir.once('finish', this._receiveInfo.bind(this));
	}
	
	inherits(SockJS, EventTarget);
	
	function userSetCode(code) {
	  return code === 1000 || code >= 3000 && code <= 4999;
	}
	
	SockJS.prototype.close = function (code, reason) {
	  // Step 1
	  if (code && !userSetCode(code)) {
	    throw new Error('InvalidAccessError: Invalid code');
	  }
	  // Step 2.4 states the max is 123 bytes, but we are just checking length
	  if (reason && reason.length > 123) {
	    throw new SyntaxError('reason argument has an invalid length');
	  }
	
	  // Step 3.1
	  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
	    return;
	  }
	
	  // TODO look at docs to determine how to set this
	  var wasClean = true;
	  this._close(code || 1000, reason || 'Normal closure', wasClean);
	};
	
	SockJS.prototype.send = function (data) {
	  // #13 - convert anything non-string to string
	  // TODO this currently turns objects into [object Object]
	  if (typeof data !== 'string') {
	    data = '' + data;
	  }
	  if (this.readyState === SockJS.CONNECTING) {
	    throw new Error('InvalidStateError: The connection has not been established yet');
	  }
	  if (this.readyState !== SockJS.OPEN) {
	    return;
	  }
	  this._transport.send(escape.quote(data));
	};
	
	SockJS.version = __webpack_require__(50);
	
	SockJS.CONNECTING = 0;
	SockJS.OPEN = 1;
	SockJS.CLOSING = 2;
	SockJS.CLOSED = 3;
	
	SockJS.prototype._receiveInfo = function (info, rtt) {
	  debug('_receiveInfo', rtt);
	  this._ir = null;
	  if (!info) {
	    this._close(1002, 'Cannot connect to server');
	    return;
	  }
	
	  // establish a round-trip timeout (RTO) based on the
	  // round-trip time (RTT)
	  this._rto = this.countRTO(rtt);
	  // allow server to override url used for the actual transport
	  this._transUrl = info.base_url ? info.base_url : this.url;
	  info = objectUtils.extend(info, this._urlInfo);
	  debug('info', info);
	  // determine list of desired and supported transports
	  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
	  this._transports = enabledTransports.main;
	  debug(this._transports.length + ' enabled transports');
	
	  this._connect();
	};
	
	SockJS.prototype._connect = function () {
	  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
	    debug('attempt', Transport.transportName);
	    if (Transport.needBody) {
	      if (!global.document.body || typeof global.document.readyState !== 'undefined' && global.document.readyState !== 'complete' && global.document.readyState !== 'interactive') {
	        debug('waiting for body');
	        this._transports.unshift(Transport);
	        eventUtils.attachEvent('load', this._connect.bind(this));
	        return;
	      }
	    }
	
	    // calculate timeout based on RTO and round trips. Default to 5s
	    var timeoutMs = this._rto * Transport.roundTrips || 5000;
	    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
	    debug('using timeout', timeoutMs);
	
	    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
	    var options = this._transportOptions[Transport.transportName];
	    debug('transport url', transportUrl);
	    var transportObj = new Transport(transportUrl, this._transUrl, options);
	    transportObj.on('message', this._transportMessage.bind(this));
	    transportObj.once('close', this._transportClose.bind(this));
	    transportObj.transportName = Transport.transportName;
	    this._transport = transportObj;
	
	    return;
	  }
	  this._close(2000, 'All transports failed', false);
	};
	
	SockJS.prototype._transportTimeout = function () {
	  debug('_transportTimeout');
	  if (this.readyState === SockJS.CONNECTING) {
	    this._transportClose(2007, 'Transport timed out');
	  }
	};
	
	SockJS.prototype._transportMessage = function (msg) {
	  debug('_transportMessage', msg);
	  var self = this,
	      type = msg.slice(0, 1),
	      content = msg.slice(1),
	      payload;
	
	  // first check for messages that don't need a payload
	  switch (type) {
	    case 'o':
	      this._open();
	      return;
	    case 'h':
	      this.dispatchEvent(new Event('heartbeat'));
	      debug('heartbeat', this.transport);
	      return;
	  }
	
	  if (content) {
	    try {
	      payload = JSON3.parse(content);
	    } catch (e) {
	      debug('bad json', content);
	    }
	  }
	
	  if (typeof payload === 'undefined') {
	    debug('empty payload', content);
	    return;
	  }
	
	  switch (type) {
	    case 'a':
	      if (Array.isArray(payload)) {
	        payload.forEach(function (p) {
	          debug('message', self.transport, p);
	          self.dispatchEvent(new TransportMessageEvent(p));
	        });
	      }
	      break;
	    case 'm':
	      debug('message', this.transport, payload);
	      this.dispatchEvent(new TransportMessageEvent(payload));
	      break;
	    case 'c':
	      if (Array.isArray(payload) && payload.length === 2) {
	        this._close(payload[0], payload[1], true);
	      }
	      break;
	  }
	};
	
	SockJS.prototype._transportClose = function (code, reason) {
	  debug('_transportClose', this.transport, code, reason);
	  if (this._transport) {
	    this._transport.removeAllListeners();
	    this._transport = null;
	    this.transport = null;
	  }
	
	  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
	    this._connect();
	    return;
	  }
	
	  this._close(code, reason);
	};
	
	SockJS.prototype._open = function () {
	  debug('_open', this._transport.transportName, this.readyState);
	  if (this.readyState === SockJS.CONNECTING) {
	    if (this._transportTimeoutId) {
	      clearTimeout(this._transportTimeoutId);
	      this._transportTimeoutId = null;
	    }
	    this.readyState = SockJS.OPEN;
	    this.transport = this._transport.transportName;
	    this.dispatchEvent(new Event('open'));
	    debug('connected', this.transport);
	  } else {
	    // The server might have been restarted, and lost track of our
	    // connection.
	    this._close(1006, 'Server lost session');
	  }
	};
	
	SockJS.prototype._close = function (code, reason, wasClean) {
	  debug('_close', this.transport, code, reason, wasClean, this.readyState);
	  var forceFail = false;
	
	  if (this._ir) {
	    forceFail = true;
	    this._ir.close();
	    this._ir = null;
	  }
	  if (this._transport) {
	    this._transport.close();
	    this._transport = null;
	    this.transport = null;
	  }
	
	  if (this.readyState === SockJS.CLOSED) {
	    throw new Error('InvalidStateError: SockJS has already been closed');
	  }
	
	  this.readyState = SockJS.CLOSING;
	  setTimeout(function () {
	    this.readyState = SockJS.CLOSED;
	
	    if (forceFail) {
	      this.dispatchEvent(new Event('error'));
	    }
	
	    var e = new CloseEvent('close');
	    e.wasClean = wasClean || false;
	    e.code = code || 1000;
	    e.reason = reason;
	
	    this.dispatchEvent(e);
	    this.onmessage = this.onclose = this.onerror = null;
	    debug('disconnected');
	  }.bind(this), 0);
	};
	
	// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
	// and RFC 2988.
	SockJS.prototype.countRTO = function (rtt) {
	  // In a local environment, when using IE8/9 and the `jsonp-polling`
	  // transport the time needed to establish a connection (the time that pass
	  // from the opening of the transport to the call of `_dispatchOpen`) is
	  // around 200msec (the lower bound used in the article above) and this
	  // causes spurious timeouts. For this reason we calculate a value slightly
	  // larger than that used in the article.
	  if (rtt > 100) {
	    return 4 * rtt; // rto > 400msec
	  }
	  return 300 + rtt; // 300msec < rto <= 400msec
	};
	
	module.exports = function (availableTransports) {
	  transports = transport(availableTransports);
	  __webpack_require__(74)(SockJS, availableTransports);
	  return SockJS;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16), (function() { return this; }())))

/***/ },
/* 61 */
/***/ function(module, exports) {

	/* eslint-disable */
	/* jscs: disable */
	'use strict';
	
	// pulled specific shims from https://github.com/es-shims/es5-shim
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ArrayPrototype = Array.prototype;
	var ObjectPrototype = Object.prototype;
	var FunctionPrototype = Function.prototype;
	var StringPrototype = String.prototype;
	var array_slice = ArrayPrototype.slice;
	
	var _toString = ObjectPrototype.toString;
	var isFunction = function isFunction(val) {
	    return ObjectPrototype.toString.call(val) === '[object Function]';
	};
	var isArray = function isArray(obj) {
	    return _toString.call(obj) === '[object Array]';
	};
	var isString = function isString(obj) {
	    return _toString.call(obj) === '[object String]';
	};
	
	var supportsDescriptors = Object.defineProperty && function () {
	    try {
	        Object.defineProperty({}, 'x', {});
	        return true;
	    } catch (e) {
	        /* this is ES3 */
	        return false;
	    }
	}();
	
	// Define configurable, writable and non-enumerable props
	// if they don't exist.
	var defineProperty;
	if (supportsDescriptors) {
	    defineProperty = function defineProperty(object, name, method, forceAssign) {
	        if (!forceAssign && name in object) {
	            return;
	        }
	        Object.defineProperty(object, name, {
	            configurable: true,
	            enumerable: false,
	            writable: true,
	            value: method
	        });
	    };
	} else {
	    defineProperty = function defineProperty(object, name, method, forceAssign) {
	        if (!forceAssign && name in object) {
	            return;
	        }
	        object[name] = method;
	    };
	}
	var defineProperties = function defineProperties(object, map, forceAssign) {
	    for (var name in map) {
	        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
	            defineProperty(object, name, map[name], forceAssign);
	        }
	    }
	};
	
	var toObject = function toObject(o) {
	    if (o == null) {
	        // this matches both null and undefined
	        throw new TypeError("can't convert " + o + ' to object');
	    }
	    return Object(o);
	};
	
	//
	// Util
	// ======
	//
	
	// ES5 9.4
	// http://es5.github.com/#x9.4
	// http://jsperf.com/to-integer
	
	function toInteger(num) {
	    var n = +num;
	    if (n !== n) {
	        // isNaN
	        n = 0;
	    } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
	        n = (n > 0 || -1) * Math.floor(Math.abs(n));
	    }
	    return n;
	}
	
	function ToUint32(x) {
	    return x >>> 0;
	}
	
	//
	// Function
	// ========
	//
	
	// ES-5 15.3.4.5
	// http://es5.github.com/#x15.3.4.5
	
	function Empty() {}
	
	defineProperties(FunctionPrototype, {
	    bind: function bind(that) {
	        // .length is 1
	        // 1. Let Target be the this value.
	        var target = this;
	        // 2. If IsCallable(Target) is false, throw a TypeError exception.
	        if (!isFunction(target)) {
	            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
	        }
	        // 3. Let A be a new (possibly empty) internal list of all of the
	        //   argument values provided after thisArg (arg1, arg2 etc), in order.
	        // XXX slicedArgs will stand in for "A" if used
	        var args = array_slice.call(arguments, 1); // for normal call
	        // 4. Let F be a new native ECMAScript object.
	        // 11. Set the [[Prototype]] internal property of F to the standard
	        //   built-in Function prototype object as specified in 15.3.3.1.
	        // 12. Set the [[Call]] internal property of F as described in
	        //   15.3.4.5.1.
	        // 13. Set the [[Construct]] internal property of F as described in
	        //   15.3.4.5.2.
	        // 14. Set the [[HasInstance]] internal property of F as described in
	        //   15.3.4.5.3.
	        var binder = function binder() {
	
	            if (this instanceof bound) {
	                // 15.3.4.5.2 [[Construct]]
	                // When the [[Construct]] internal method of a function object,
	                // F that was created using the bind function is called with a
	                // list of arguments ExtraArgs, the following steps are taken:
	                // 1. Let target be the value of F's [[TargetFunction]]
	                //   internal property.
	                // 2. If target has no [[Construct]] internal method, a
	                //   TypeError exception is thrown.
	                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Construct]] internal
	                //   method of target providing args as the arguments.
	
	                var result = target.apply(this, args.concat(array_slice.call(arguments)));
	                if (Object(result) === result) {
	                    return result;
	                }
	                return this;
	            } else {
	                // 15.3.4.5.1 [[Call]]
	                // When the [[Call]] internal method of a function object, F,
	                // which was created using the bind function is called with a
	                // this value and a list of arguments ExtraArgs, the following
	                // steps are taken:
	                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 2. Let boundThis be the value of F's [[BoundThis]] internal
	                //   property.
	                // 3. Let target be the value of F's [[TargetFunction]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Call]] internal method
	                //   of target providing boundThis as the this value and
	                //   providing args as the arguments.
	
	                // equiv: target.call(this, ...boundArgs, ...args)
	                return target.apply(that, args.concat(array_slice.call(arguments)));
	            }
	        };
	
	        // 15. If the [[Class]] internal property of Target is "Function", then
	        //     a. Let L be the length property of Target minus the length of A.
	        //     b. Set the length own property of F to either 0 or L, whichever is
	        //       larger.
	        // 16. Else set the length own property of F to 0.
	
	        var boundLength = Math.max(0, target.length - args.length);
	
	        // 17. Set the attributes of the length own property of F to the values
	        //   specified in 15.3.5.1.
	        var boundArgs = [];
	        for (var i = 0; i < boundLength; i++) {
	            boundArgs.push('$' + i);
	        }
	
	        // XXX Build a dynamic function with desired amount of arguments is the only
	        // way to set the length property of a function.
	        // In environments where Content Security Policies enabled (Chrome extensions,
	        // for ex.) all use of eval or Function costructor throws an exception.
	        // However in all of these environments Function.prototype.bind exists
	        // and so this code will never be executed.
	        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);
	
	        if (target.prototype) {
	            Empty.prototype = target.prototype;
	            bound.prototype = new Empty();
	            // Clean up dangling references.
	            Empty.prototype = null;
	        }
	
	        // TODO
	        // 18. Set the [[Extensible]] internal property of F to true.
	
	        // TODO
	        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
	        // 20. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
	        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
	        //   false.
	        // 21. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
	        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
	        //   and false.
	
	        // TODO
	        // NOTE Function objects created using Function.prototype.bind do not
	        // have a prototype property or the [[Code]], [[FormalParameters]], and
	        // [[Scope]] internal properties.
	        // XXX can't delete prototype in pure-js.
	
	        // 22. Return F.
	        return bound;
	    }
	});
	
	//
	// Array
	// =====
	//
	
	// ES5 15.4.3.2
	// http://es5.github.com/#x15.4.3.2
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
	defineProperties(Array, { isArray: isArray });
	
	var boxedString = Object('a');
	var splitString = boxedString[0] !== 'a' || !(0 in boxedString);
	
	var properlyBoxesContext = function properlyBoxed(method) {
	    // Check node 0.6.21 bug where third parameter is not boxed
	    var properlyBoxesNonStrict = true;
	    var properlyBoxesStrict = true;
	    if (method) {
	        method.call('foo', function (_, __, context) {
	            if ((typeof context === 'undefined' ? 'undefined' : _typeof(context)) !== 'object') {
	                properlyBoxesNonStrict = false;
	            }
	        });
	
	        method.call([1], function () {
	            'use strict';
	
	            properlyBoxesStrict = typeof this === 'string';
	        }, 'x');
	    }
	    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
	};
	
	defineProperties(ArrayPrototype, {
	    forEach: function forEach(fun /*, thisp*/) {
	        var object = toObject(this),
	            self = splitString && isString(this) ? this.split('') : object,
	            thisp = arguments[1],
	            i = -1,
	            length = self.length >>> 0;
	
	        // If no callback function or if callback is not a callable function
	        if (!isFunction(fun)) {
	            throw new TypeError(); // TODO message
	        }
	
	        while (++i < length) {
	            if (i in self) {
	                // Invoke the callback function with call, passing arguments:
	                // context, property value, property key, thisArg object
	                // context
	                fun.call(thisp, self[i], i, object);
	            }
	        }
	    }
	}, !properlyBoxesContext(ArrayPrototype.forEach));
	
	// ES5 15.4.4.14
	// http://es5.github.com/#x15.4.4.14
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
	var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
	defineProperties(ArrayPrototype, {
	    indexOf: function indexOf(sought /*, fromIndex */) {
	        var self = splitString && isString(this) ? this.split('') : toObject(this),
	            length = self.length >>> 0;
	
	        if (!length) {
	            return -1;
	        }
	
	        var i = 0;
	        if (arguments.length > 1) {
	            i = toInteger(arguments[1]);
	        }
	
	        // handle negative indices
	        i = i >= 0 ? i : Math.max(0, length + i);
	        for (; i < length; i++) {
	            if (i in self && self[i] === sought) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2IndexOfBug);
	
	//
	// String
	// ======
	//
	
	// ES5 15.5.4.14
	// http://es5.github.com/#x15.5.4.14
	
	// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
	// Many browsers do not split properly with regular expressions or they
	// do not perform the split correctly under obscure conditions.
	// See http://blog.stevenlevithan.com/archives/cross-browser-split
	// I've tested in many browsers and this seems to cover the deviant ones:
	//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
	//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
	//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
	//       [undefined, "t", undefined, "e", ...]
	//    ''.split(/.?/) should be [], not [""]
	//    '.'.split(/()()/) should be ["."], not ["", "", "."]
	
	var string_split = StringPrototype.split;
	if ('ab'.split(/(?:ab)*/).length !== 2 || '.'.split(/(.?)(.?)/).length !== 4 || 'tesst'.split(/(s)*/)[1] === 't' || 'test'.split(/(?:)/, -1).length !== 4 || ''.split(/.?/).length || '.'.split(/()()/).length > 1) {
	    (function () {
	        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group
	
	        StringPrototype.split = function (separator, limit) {
	            var string = this;
	            if (separator === void 0 && limit === 0) {
	                return [];
	            }
	
	            // If `separator` is not a regex, use native split
	            if (_toString.call(separator) !== '[object RegExp]') {
	                return string_split.call(this, separator, limit);
	            }
	
	            var output = [],
	                flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.extended ? 'x' : '') + ( // Proposed for ES6
	            separator.sticky ? 'y' : ''),
	                // Firefox 3+
	            lastLastIndex = 0,
	
	            // Make `global` and avoid `lastIndex` issues by working with a copy
	            separator2,
	                match,
	                lastIndex,
	                lastLength;
	            separator = new RegExp(separator.source, flags + 'g');
	            string += ''; // Type-convert
	            if (!compliantExecNpcg) {
	                // Doesn't need flags gy, but they don't hurt
	                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
	            }
	            /* Values for `limit`, per the spec:
	             * If undefined: 4294967295 // Math.pow(2, 32) - 1
	             * If 0, Infinity, or NaN: 0
	             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
	             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
	             * If other: Type-convert, then use the above rules
	             */
	            limit = limit === void 0 ? -1 >>> 0 : // Math.pow(2, 32) - 1
	            ToUint32(limit);
	            while (match = separator.exec(string)) {
	                // `separator.lastIndex` is not reliable cross-browser
	                lastIndex = match.index + match[0].length;
	                if (lastIndex > lastLastIndex) {
	                    output.push(string.slice(lastLastIndex, match.index));
	                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
	                    // nonparticipating capturing groups
	                    if (!compliantExecNpcg && match.length > 1) {
	                        match[0].replace(separator2, function () {
	                            for (var i = 1; i < arguments.length - 2; i++) {
	                                if (arguments[i] === void 0) {
	                                    match[i] = void 0;
	                                }
	                            }
	                        });
	                    }
	                    if (match.length > 1 && match.index < string.length) {
	                        ArrayPrototype.push.apply(output, match.slice(1));
	                    }
	                    lastLength = match[0].length;
	                    lastLastIndex = lastIndex;
	                    if (output.length >= limit) {
	                        break;
	                    }
	                }
	                if (separator.lastIndex === match.index) {
	                    separator.lastIndex++; // Avoid an infinite loop
	                }
	            }
	            if (lastLastIndex === string.length) {
	                if (lastLength || !separator.test('')) {
	                    output.push('');
	                }
	            } else {
	                output.push(string.slice(lastLastIndex));
	            }
	            return output.length > limit ? output.slice(0, limit) : output;
	        };
	    })();
	
	    // [bugfix, chrome]
	    // If separator is undefined, then the result array contains just one String,
	    // which is the this value (converted to a String). If limit is not undefined,
	    // then the output array is truncated so that it contains no more than limit
	    // elements.
	    // "0".split(undefined, 0) -> []
	} else if ('0'.split(void 0, 0).length) {
	    StringPrototype.split = function split(separator, limit) {
	        if (separator === void 0 && limit === 0) {
	            return [];
	        }
	        return string_split.call(this, separator, limit);
	    };
	}
	
	// ECMA-262, 3rd B.2.3
	// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
	// non-normative section suggesting uniform semantics and it should be
	// normalized across all browsers
	// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
	var string_substr = StringPrototype.substr;
	var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
	defineProperties(StringPrototype, {
	    substr: function substr(start, length) {
	        return string_substr.call(this, start < 0 ? (start = this.length + start) < 0 ? 0 : start : start, length);
	    }
	}, hasNegativeSubstrBug);

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var JSON3 = __webpack_require__(49);
	
	// Some extra characters that Chrome gets wrong, and substitutes with
	// something else on the wire.
	// eslint-disable-next-line no-control-regex
	var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
	    extraLookup;
	
	// This may be quite slow, so let's delay until user actually uses bad
	// characters.
	var unrollLookup = function unrollLookup(escapable) {
	  var i;
	  var unrolled = {};
	  var c = [];
	  for (i = 0; i < 65536; i++) {
	    c.push(String.fromCharCode(i));
	  }
	  escapable.lastIndex = 0;
	  c.join('').replace(escapable, function (a) {
	    unrolled[a] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	    return '';
	  });
	  escapable.lastIndex = 0;
	  return unrolled;
	};
	
	// Quote string, also taking care of unicode characters that browsers
	// often break. Especially, take care of unicode surrogates:
	// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
	module.exports = {
	  quote: function quote(string) {
	    var quoted = JSON3.stringify(string);
	
	    // In most cases this should be very fast and good enough.
	    extraEscapable.lastIndex = 0;
	    if (!extraEscapable.test(quoted)) {
	      return quoted;
	    }
	
	    if (!extraLookup) {
	      extraLookup = unrollLookup(extraEscapable);
	    }
	
	    return quoted.replace(extraEscapable, function (a) {
	      return extraLookup[a];
	    });
	  }
	};

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:utils:transport');
	}
	
	module.exports = function (availableTransports) {
	  return {
	    filterToEnabled: function filterToEnabled(transportsWhitelist, info) {
	      var transports = {
	        main: [],
	        facade: []
	      };
	      if (!transportsWhitelist) {
	        transportsWhitelist = [];
	      } else if (typeof transportsWhitelist === 'string') {
	        transportsWhitelist = [transportsWhitelist];
	      }
	
	      availableTransports.forEach(function (trans) {
	        if (!trans) {
	          return;
	        }
	
	        if (trans.transportName === 'websocket' && info.websocket === false) {
	          debug('disabled from server', 'websocket');
	          return;
	        }
	
	        if (transportsWhitelist.length && transportsWhitelist.indexOf(trans.transportName) === -1) {
	          debug('not in whitelist', trans.transportName);
	          return;
	        }
	
	        if (trans.enabled(info)) {
	          debug('enabled', trans.transportName);
	          transports.main.push(trans);
	          if (trans.facadeTransport) {
	            transports.facade.push(trans.facadeTransport);
	          }
	        } else {
	          debug('disabled', trans.transportName);
	        }
	      });
	      return transports;
	    }
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 64 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var logObject = {};
	['log', 'debug', 'warn'].forEach(function (level) {
	  var levelExists;
	
	  try {
	    levelExists = global.console && global.console[level] && global.console[level].apply;
	  } catch (e) {
	    // do nothing
	  }
	
	  logObject[level] = levelExists ? function () {
	    return global.console[level].apply(global.console, arguments);
	  } : level === 'log' ? function () {} : logObject.log;
	});
	
	module.exports = logObject;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 65 */
/***/ function(module, exports) {

	'use strict';
	
	function Event(eventType) {
	  this.type = eventType;
	}
	
	Event.prototype.initEvent = function (eventType, canBubble, cancelable) {
	  this.type = eventType;
	  this.bubbles = canBubble;
	  this.cancelable = cancelable;
	  this.timeStamp = +new Date();
	  return this;
	};
	
	Event.prototype.stopPropagation = function () {};
	Event.prototype.preventDefault = function () {};
	
	Event.CAPTURING_PHASE = 1;
	Event.AT_TARGET = 2;
	Event.BUBBLING_PHASE = 3;
	
	module.exports = Event;

/***/ },
/* 66 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = global.location || {
	  origin: 'http://localhost:80',
	  protocol: 'http',
	  host: 'localhost',
	  port: 80,
	  href: 'http://localhost/',
	  hash: ''
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(28),
	    Event = __webpack_require__(65);
	
	function CloseEvent() {
	  Event.call(this);
	  this.initEvent('close', false, false);
	  this.wasClean = false;
	  this.code = 0;
	  this.reason = '';
	}
	
	inherits(CloseEvent, Event);
	
	module.exports = CloseEvent;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(28),
	    Event = __webpack_require__(65);
	
	function TransportMessageEvent(data) {
	  Event.call(this);
	  this.initEvent('message', false, false);
	  this.data = data;
	}
	
	inherits(TransportMessageEvent, Event);
	
	module.exports = TransportMessageEvent;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var EventEmitter = __webpack_require__(29).EventEmitter,
	    inherits = __webpack_require__(28),
	    urlUtils = __webpack_require__(20),
	    XDR = __webpack_require__(43),
	    XHRCors = __webpack_require__(38),
	    XHRLocal = __webpack_require__(40),
	    XHRFake = __webpack_require__(70),
	    InfoIframe = __webpack_require__(71),
	    InfoAjax = __webpack_require__(73);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:info-receiver');
	}
	
	function InfoReceiver(baseUrl, urlInfo) {
	  debug(baseUrl);
	  var self = this;
	  EventEmitter.call(this);
	
	  setTimeout(function () {
	    self.doXhr(baseUrl, urlInfo);
	  }, 0);
	}
	
	inherits(InfoReceiver, EventEmitter);
	
	// TODO this is currently ignoring the list of available transports and the whitelist
	
	InfoReceiver._getReceiver = function (baseUrl, url, urlInfo) {
	  // determine method of CORS support (if needed)
	  if (urlInfo.sameOrigin) {
	    return new InfoAjax(url, XHRLocal);
	  }
	  if (XHRCors.enabled) {
	    return new InfoAjax(url, XHRCors);
	  }
	  if (XDR.enabled && urlInfo.sameScheme) {
	    return new InfoAjax(url, XDR);
	  }
	  if (InfoIframe.enabled()) {
	    return new InfoIframe(baseUrl, url);
	  }
	  return new InfoAjax(url, XHRFake);
	};
	
	InfoReceiver.prototype.doXhr = function (baseUrl, urlInfo) {
	  var self = this,
	      url = urlUtils.addPath(baseUrl, '/info');
	  debug('doXhr', url);
	
	  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);
	
	  this.timeoutRef = setTimeout(function () {
	    debug('timeout');
	    self._cleanup(false);
	    self.emit('finish');
	  }, InfoReceiver.timeout);
	
	  this.xo.once('finish', function (info, rtt) {
	    debug('finish', info, rtt);
	    self._cleanup(true);
	    self.emit('finish', info, rtt);
	  });
	};
	
	InfoReceiver.prototype._cleanup = function (wasClean) {
	  debug('_cleanup');
	  clearTimeout(this.timeoutRef);
	  this.timeoutRef = null;
	  if (!wasClean && this.xo) {
	    this.xo.close();
	  }
	  this.xo = null;
	};
	
	InfoReceiver.prototype.close = function () {
	  debug('close');
	  this.removeAllListeners();
	  this._cleanup(false);
	};
	
	InfoReceiver.timeout = 8000;
	
	module.exports = InfoReceiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var EventEmitter = __webpack_require__(29).EventEmitter,
	    inherits = __webpack_require__(28);
	
	function XHRFake() /* method, url, payload, opts */{
	  var self = this;
	  EventEmitter.call(this);
	
	  this.to = setTimeout(function () {
	    self.emit('finish', 200, '{}');
	  }, XHRFake.timeout);
	}
	
	inherits(XHRFake, EventEmitter);
	
	XHRFake.prototype.close = function () {
	  clearTimeout(this.to);
	};
	
	XHRFake.timeout = 2000;
	
	module.exports = XHRFake;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var EventEmitter = __webpack_require__(29).EventEmitter,
	    inherits = __webpack_require__(28),
	    JSON3 = __webpack_require__(49),
	    utils = __webpack_require__(17),
	    IframeTransport = __webpack_require__(48),
	    InfoReceiverIframe = __webpack_require__(72);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:info-iframe');
	}
	
	function InfoIframe(baseUrl, url) {
	  var self = this;
	  EventEmitter.call(this);
	
	  var go = function go() {
	    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);
	
	    ifr.once('message', function (msg) {
	      if (msg) {
	        var d;
	        try {
	          d = JSON3.parse(msg);
	        } catch (e) {
	          debug('bad json', msg);
	          self.emit('finish');
	          self.close();
	          return;
	        }
	
	        var info = d[0],
	            rtt = d[1];
	        self.emit('finish', info, rtt);
	      }
	      self.close();
	    });
	
	    ifr.once('close', function () {
	      self.emit('finish');
	      self.close();
	    });
	  };
	
	  // TODO this seems the same as the 'needBody' from transports
	  if (!global.document.body) {
	    utils.attachEvent('load', go);
	  } else {
	    go();
	  }
	}
	
	inherits(InfoIframe, EventEmitter);
	
	InfoIframe.enabled = function () {
	  return IframeTransport.enabled();
	};
	
	InfoIframe.prototype.close = function () {
	  if (this.ifr) {
	    this.ifr.close();
	  }
	  this.removeAllListeners();
	  this.ifr = null;
	};
	
	module.exports = InfoIframe;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16), (function() { return this; }())))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(28),
	    EventEmitter = __webpack_require__(29).EventEmitter,
	    JSON3 = __webpack_require__(49),
	    XHRLocalObject = __webpack_require__(40),
	    InfoAjax = __webpack_require__(73);
	
	function InfoReceiverIframe(transUrl) {
	  var self = this;
	  EventEmitter.call(this);
	
	  this.ir = new InfoAjax(transUrl, XHRLocalObject);
	  this.ir.once('finish', function (info, rtt) {
	    self.ir = null;
	    self.emit('message', JSON3.stringify([info, rtt]));
	  });
	}
	
	inherits(InfoReceiverIframe, EventEmitter);
	
	InfoReceiverIframe.transportName = 'iframe-info-receiver';
	
	InfoReceiverIframe.prototype.close = function () {
	  if (this.ir) {
	    this.ir.close();
	    this.ir = null;
	  }
	  this.removeAllListeners();
	};
	
	module.exports = InfoReceiverIframe;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var EventEmitter = __webpack_require__(29).EventEmitter,
	    inherits = __webpack_require__(28),
	    JSON3 = __webpack_require__(49),
	    objectUtils = __webpack_require__(52);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:info-ajax');
	}
	
	function InfoAjax(url, AjaxObject) {
	  EventEmitter.call(this);
	
	  var self = this;
	  var t0 = +new Date();
	  this.xo = new AjaxObject('GET', url);
	
	  this.xo.once('finish', function (status, text) {
	    var info, rtt;
	    if (status === 200) {
	      rtt = +new Date() - t0;
	      if (text) {
	        try {
	          info = JSON3.parse(text);
	        } catch (e) {
	          debug('bad json', text);
	        }
	      }
	
	      if (!objectUtils.isObject(info)) {
	        info = {};
	      }
	    }
	    self.emit('finish', info, rtt);
	    self.removeAllListeners();
	  });
	}
	
	inherits(InfoAjax, EventEmitter);
	
	InfoAjax.prototype.close = function () {
	  this.removeAllListeners();
	  this.xo.close();
	};
	
	module.exports = InfoAjax;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var urlUtils = __webpack_require__(20),
	    eventUtils = __webpack_require__(17),
	    JSON3 = __webpack_require__(49),
	    FacadeJS = __webpack_require__(75),
	    InfoIframeReceiver = __webpack_require__(72),
	    iframeUtils = __webpack_require__(51),
	    loc = __webpack_require__(66);
	
	var debug = function debug() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(25)('sockjs-client:iframe-bootstrap');
	}
	
	module.exports = function (SockJS, availableTransports) {
	  var transportMap = {};
	  availableTransports.forEach(function (at) {
	    if (at.facadeTransport) {
	      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
	    }
	  });
	
	  // hard-coded for the info iframe
	  // TODO see if we can make this more dynamic
	  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
	  var parentOrigin;
	
	  /* eslint-disable camelcase */
	  SockJS.bootstrap_iframe = function () {
	    /* eslint-enable camelcase */
	    var facade;
	    iframeUtils.currentWindowId = loc.hash.slice(1);
	    var onMessage = function onMessage(e) {
	      if (e.source !== parent) {
	        return;
	      }
	      if (typeof parentOrigin === 'undefined') {
	        parentOrigin = e.origin;
	      }
	      if (e.origin !== parentOrigin) {
	        return;
	      }
	
	      var iframeMessage;
	      try {
	        iframeMessage = JSON3.parse(e.data);
	      } catch (ignored) {
	        debug('bad json', e.data);
	        return;
	      }
	
	      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
	        return;
	      }
	      switch (iframeMessage.type) {
	        case 's':
	          var p;
	          try {
	            p = JSON3.parse(iframeMessage.data);
	          } catch (ignored) {
	            debug('bad json', iframeMessage.data);
	            break;
	          }
	          var version = p[0];
	          var transport = p[1];
	          var transUrl = p[2];
	          var baseUrl = p[3];
	          debug(version, transport, transUrl, baseUrl);
	          // change this to semver logic
	          if (version !== SockJS.version) {
	            throw new Error('Incompatible SockJS! Main site uses:' + ' "' + version + '", the iframe:' + ' "' + SockJS.version + '".');
	          }
	
	          if (!urlUtils.isOriginEqual(transUrl, loc.href) || !urlUtils.isOriginEqual(baseUrl, loc.href)) {
	            throw new Error('Can\'t connect to different domain from within an ' + 'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
	          }
	          facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
	          break;
	        case 'm':
	          facade._send(iframeMessage.data);
	          break;
	        case 'c':
	          if (facade) {
	            facade._close();
	          }
	          facade = null;
	          break;
	      }
	    };
	
	    eventUtils.attachEvent('message', onMessage);
	
	    // Start
	    iframeUtils.postMessage('s');
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var JSON3 = __webpack_require__(49),
	    iframeUtils = __webpack_require__(51);
	
	function FacadeJS(transport) {
	  this._transport = transport;
	  transport.on('message', this._transportMessage.bind(this));
	  transport.on('close', this._transportClose.bind(this));
	}
	
	FacadeJS.prototype._transportClose = function (code, reason) {
	  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
	};
	FacadeJS.prototype._transportMessage = function (frame) {
	  iframeUtils.postMessage('t', frame);
	};
	FacadeJS.prototype._send = function (data) {
	  this._transport.send(data);
	};
	FacadeJS.prototype._close = function () {
	  this._transport.close();
	  this._transport.removeAllListeners();
	};
	
	module.exports = FacadeJS;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*globals window __webpack_hash__ */
	if (true) {
		var lastData;
		var upToDate = function upToDate() {
			return lastData.indexOf(__webpack_require__.h()) >= 0;
		};
		var check = function check() {
			module.hot.check(function (err, updatedModules) {
				if (err) {
					if (module.hot.status() in {
						abort: 1,
						fail: 1
					}) {
						console.warn("[HMR] Cannot check for update. Need to do a full reload!");
						console.warn("[HMR] " + err.stack || err.message);
					} else {
						console.warn("[HMR] Update check failed: " + err.stack || err.message);
					}
					return;
				}
	
				if (!updatedModules) {
					console.warn("[HMR] Cannot find update. Need to do a full reload!");
					console.warn("[HMR] (Probably because of restarting the webpack-dev-server)");
					return;
				}
	
				module.hot.apply({
					ignoreUnaccepted: true
				}, function (err, renewedModules) {
					if (err) {
						if (module.hot.status() in {
							abort: 1,
							fail: 1
						}) {
							console.warn("[HMR] Cannot apply update. Need to do a full reload!");
							console.warn("[HMR] " + err.stack || err.message);
						} else {
							console.warn("[HMR] Update failed: " + err.stack || err.message);
						}
						return;
					}
	
					if (!upToDate()) {
						check();
					}
	
					__webpack_require__(77)(updatedModules, renewedModules);
	
					if (upToDate()) {
						console.log("[HMR] App is up to date.");
					}
				});
			});
		};
		var addEventListener = window.addEventListener ? function (eventName, listener) {
			window.addEventListener(eventName, listener, false);
		} : function (eventName, listener) {
			window.attachEvent("on" + eventName, listener);
		};
		addEventListener("message", function (event) {
			if (typeof event.data === "string" && event.data.indexOf("webpackHotUpdate") === 0) {
				lastData = event.data;
				if (!upToDate() && module.hot.status() === "idle") {
					console.log("[HMR] Checking for updates on the server...");
					check();
				}
			}
		});
		console.log("[HMR] Waiting for update signal from WDS...");
	} else {
		throw new Error("[HMR] Hot Module Replacement is disabled.");
	}

/***/ },
/* 77 */
/***/ function(module, exports) {

	"use strict";
	
	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function (updatedModules, renewedModules) {
		var unacceptedModules = updatedModules.filter(function (moduleId) {
			return renewedModules && renewedModules.indexOf(moduleId) < 0;
		});
	
		if (unacceptedModules.length > 0) {
			console.warn("[HMR] The following modules couldn't be hot updated: (They would need a full reload!)");
			unacceptedModules.forEach(function (moduleId) {
				console.warn("[HMR]  - " + moduleId);
			});
		}
	
		if (!renewedModules || renewedModules.length === 0) {
			console.log("[HMR] Nothing hot updated.");
		} else {
			console.log("[HMR] Updated modules:");
			renewedModules.forEach(function (moduleId) {
				console.log("[HMR]  - " + moduleId);
			});
		}
	};

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(79);
	
	var _react = __webpack_require__(83);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(113);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	render(_react2.default.createElement('div', { className: 'header' }), document.getElementById('root')); /**
	                                                                                                         * Created by Liukeyi on 2017/2/8.
	                                                                                                         */

/***/ },
/* 79 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(84);

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var ReactChildren = __webpack_require__(86);
	var ReactComponent = __webpack_require__(99);
	var ReactPureComponent = __webpack_require__(102);
	var ReactClass = __webpack_require__(103);
	var ReactDOMFactories = __webpack_require__(105);
	var ReactElement = __webpack_require__(90);
	var ReactPropTypes = __webpack_require__(110);
	var ReactVersion = __webpack_require__(111);
	
	var onlyChild = __webpack_require__(112);
	var warning = __webpack_require__(92);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(106);
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var __spread = _assign;
	
	if (process.env.NODE_ENV !== 'production') {
	  var warned = false;
	  __spread = function __spread() {
	    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
	    warned = true;
	    return _assign.apply(null, arguments);
	  };
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function createMixin(mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 85 */
/***/ function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	
	'use strict';
	/* eslint-disable no-unused-vars */
	
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(87);
	var ReactElement = __webpack_require__(90);
	
	var emptyFunction = __webpack_require__(93);
	var traverseAllChildren = __webpack_require__(96);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func,
	      context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result,
	      keyPrefix = bookKeeping.keyPrefix,
	      func = bookKeeping.func,
	      context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(88);
	
	var invariant = __webpack_require__(89);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var standardReleaser = function standardReleaser(instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 88 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var validateFormat = function validateFormat(format) {};
	
	if (process.env.NODE_ENV !== 'production') {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _assign = __webpack_require__(85);
	
	var ReactCurrentOwner = __webpack_require__(91);
	
	var warning = __webpack_require__(92);
	var canDefineProperty = __webpack_require__(94);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	var REACT_ELEMENT_TYPE = __webpack_require__(95);
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	var specialPropKeyWarningShown, specialPropRefWarningShown;
	
	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}
	
	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}
	
	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function warnAboutAccessingKey() {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}
	
	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function warnAboutAccessingRef() {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}
	
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }
	
	  return element;
	};
	
	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (Object.freeze) {
	        Object.freeze(childArray);
	      }
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = _assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 91 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(93);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 93 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    // $FlowFixMe https://github.com/facebook/flow/issues/285
	    Object.defineProperty({}, 'x', { get: function get() {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 95 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	module.exports = REACT_ELEMENT_TYPE;

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(88);
	
	var ReactCurrentOwner = __webpack_require__(91);
	var REACT_ELEMENT_TYPE = __webpack_require__(95);
	
	var getIteratorFn = __webpack_require__(97);
	var invariant = __webpack_require__(89);
	var KeyEscapeUtils = __webpack_require__(98);
	var warning = __webpack_require__(92);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && (typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 97 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(88);
	
	var ReactNoopUpdateQueue = __webpack_require__(100);
	
	var canDefineProperty = __webpack_require__(94);
	var emptyObject = __webpack_require__(101);
	var invariant = __webpack_require__(89);
	var warning = __webpack_require__(92);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var warning = __webpack_require__(92);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var ReactComponent = __webpack_require__(99);
	var ReactNoopUpdateQueue = __webpack_require__(100);
	
	var emptyObject = __webpack_require__(101);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;
	
	module.exports = ReactPureComponent;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(88),
	    _assign = __webpack_require__(85);
	
	var ReactComponent = __webpack_require__(99);
	var ReactElement = __webpack_require__(90);
	var ReactPropTypeLocationNames = __webpack_require__(104);
	var ReactNoopUpdateQueue = __webpack_require__(100);
	
	var emptyObject = __webpack_require__(101);
	var invariant = __webpack_require__(89);
	var warning = __webpack_require__(92);
	
	var MIXINS_KEY = 'mixins';
	
	// Helper function to allow the creation of anonymous functions which do not
	// have .name set to the name of the variable being assigned to.
	function identity(fn) {
	  return fn;
	}
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	
	var injectedMixins = [];
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or host components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: 'DEFINE_MANY',
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: 'DEFINE_MANY',
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: 'DEFINE_MANY',
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: 'DEFINE_MANY',
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: 'DEFINE_MANY',
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: 'DEFINE_MANY_MERGED',
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: 'DEFINE_MANY_MERGED',
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: 'DEFINE_MANY_MERGED',
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: 'DEFINE_ONCE',
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: 'DEFINE_MANY',
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: 'DEFINE_MANY',
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: 'DEFINE_MANY',
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: 'DEFINE_ONCE',
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: 'DEFINE_MANY',
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: 'DEFINE_MANY',
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: 'DEFINE_MANY',
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: 'OVERRIDE_BASE'
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function displayName(Constructor, _displayName) {
	    Constructor.displayName = _displayName;
	  },
	  mixins: function mixins(Constructor, _mixins) {
	    if (_mixins) {
	      for (var i = 0; i < _mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, _mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _childContextTypes, 'childContext');
	    }
	    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, _childContextTypes);
	  },
	  contextTypes: function contextTypes(Constructor, _contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _contextTypes, 'context');
	    }
	    Constructor.contextTypes = _assign({}, Constructor.contextTypes, _contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = _getDefaultProps;
	    }
	  },
	  propTypes: function propTypes(Constructor, _propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _propTypes, 'prop');
	    }
	    Constructor.propTypes = _assign({}, Constructor.propTypes, _propTypes);
	  },
	  statics: function statics(Constructor, _statics) {
	    mixStaticSpecIntoComponent(Constructor, _statics);
	  },
	  autobind: function autobind() {} };
	
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but only in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
	    }
	  }
	}
	
	function validateMethodOverride(isAlreadyDefined, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (isAlreadyDefined) {
	    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classes.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    if (process.env.NODE_ENV !== 'production') {
	      var typeofSpec = typeof spec === 'undefined' ? 'undefined' : _typeof(spec);
	      var isMixinValid = typeofSpec === 'object' && spec !== null;
	
	      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
	    }
	
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;
	
	  var proto = Constructor.prototype;
	  var autoBindPairs = proto.__reactAutoBindPairs;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    var isAlreadyDefined = proto.hasOwnProperty(name);
	    validateMethodOverride(isAlreadyDefined, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        autoBindPairs.push(name, property);
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === 'DEFINE_MANY_MERGED') {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === 'DEFINE_MANY') {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  var pairs = component.__reactAutoBindPairs;
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	    var method = pairs[i + 1];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function replaceState(newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback, 'replaceState');
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted() {
	    return this.updater.isMounted(this);
	  }
	};
	
	var ReactClassComponent = function ReactClassComponent() {};
	_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function createClass(spec) {
	    // To keep our warnings more understandable, we'll use a little hack here to
	    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
	    // unnecessarily identify a class without displayName as 'Constructor'.
	    var Constructor = identity(function (props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
	
	      this.state = initialState;
	    });
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function injectMixin(mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(90);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(106);
	  createDOMFactory = ReactElementValidator.createFactory;
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),
	
	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(91);
	var ReactComponentTreeHook = __webpack_require__(107);
	var ReactElement = __webpack_require__(90);
	
	var checkReactTypeSpec = __webpack_require__(108);
	
	var canDefineProperty = __webpack_require__(94);
	var getIteratorFn = __webpack_require__(97);
	var warning = __webpack_require__(92);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();
	
	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
	
	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function createElement(type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      if (typeof type !== 'function' && typeof type !== 'string') {
	        var info = '';
	        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
	          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
	        }
	        info += getDeclarationErrorAddendum();
	        process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info) : void 0;
	      }
	    }
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function createFactory(type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function cloneElement(element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(88);
	
	var ReactCurrentOwner = __webpack_require__(91);
	
	var invariant = __webpack_require__(89);
	var warning = __webpack_require__(92);
	
	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty)
	  // Strip regex characters so we can use it for regex
	  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  // Remove hasOwnProperty from the template to make it generic
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}
	
	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
	
	var setItem;
	var getItem;
	var removeItem;
	var getItemIDs;
	var addRoot;
	var removeRoot;
	var getRootIDs;
	
	if (canUseCollections) {
	  var itemMap = new Map();
	  var rootIDSet = new Set();
	
	  setItem = function setItem(id, item) {
	    itemMap.set(id, item);
	  };
	  getItem = function getItem(id) {
	    return itemMap.get(id);
	  };
	  removeItem = function removeItem(id) {
	    itemMap['delete'](id);
	  };
	  getItemIDs = function getItemIDs() {
	    return Array.from(itemMap.keys());
	  };
	
	  addRoot = function addRoot(id) {
	    rootIDSet.add(id);
	  };
	  removeRoot = function removeRoot(id) {
	    rootIDSet['delete'](id);
	  };
	  getRootIDs = function getRootIDs() {
	    return Array.from(rootIDSet.keys());
	  };
	} else {
	  var itemByKey = {};
	  var rootByKey = {};
	
	  // Use non-numeric keys to prevent V8 performance issues:
	  // https://github.com/facebook/react/pull/7232
	  var getKeyFromID = function getKeyFromID(id) {
	    return '.' + id;
	  };
	  var getIDFromKey = function getIDFromKey(key) {
	    return parseInt(key.substr(1), 10);
	  };
	
	  setItem = function setItem(id, item) {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  };
	  getItem = function getItem(id) {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  };
	  removeItem = function removeItem(id) {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  };
	  getItemIDs = function getItemIDs() {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  };
	
	  addRoot = function addRoot(id) {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  };
	  removeRoot = function removeRoot(id) {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  };
	  getRootIDs = function getRootIDs() {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  };
	}
	
	var unmountedIDs = [];
	
	function purgeDeep(id) {
	  var item = getItem(id);
	  if (item) {
	    var childIDs = item.childIDs;
	
	    removeItem(id);
	    childIDs.forEach(purgeDeep);
	  }
	}
	
	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}
	
	function _getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}
	
	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}
	
	var ReactComponentTreeHook = {
	  onSetChildren: function onSetChildren(id, nextChildIDs) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.childIDs = nextChildIDs;
	
	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = getItem(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || _typeof(nextChild.element) !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent id is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function onBeforeMountComponent(id, element, parentID) {
	    var item = {
	      element: element,
	      parentID: parentID,
	      text: null,
	      childIDs: [],
	      isMounted: false,
	      updateCount: 0
	    };
	    setItem(id, item);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(id, element) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function onMountComponent(id) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function onUpdateComponent(id) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function onUnmountComponent(id) {
	    var item = getItem(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function purgeUnmountedComponents() {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }
	
	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function isMounted(id) {
	    var item = getItem(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function getCurrentStackAddendum(topElement) {
	    var info = '';
	    if (topElement) {
	      var name = _getDisplayName(topElement);
	      var owner = topElement._owner;
	      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
	    }
	
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;
	
	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function getStackAddendumByID(id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function getChildIDs(id) {
	    var item = getItem(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function getDisplayName(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return _getDisplayName(element);
	  },
	  getElement: function getElement(id) {
	    var item = getItem(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function getOwnerID(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function getParentID(id) {
	    var item = getItem(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function getSource(id) {
	    var item = getItem(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function getText(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function getUpdateCount(id) {
	    var item = getItem(id);
	    return item ? item.updateCount : 0;
	  },
	
	  getRootIDs: getRootIDs,
	  getRegisteredIDs: getItemIDs
	};
	
	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(88);
	
	var ReactPropTypeLocationNames = __webpack_require__(104);
	var ReactPropTypesSecret = __webpack_require__(109);
	
	var invariant = __webpack_require__(89);
	var warning = __webpack_require__(92);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(107);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(107);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 109 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(90);
	var ReactPropTypeLocationNames = __webpack_require__(104);
	var ReactPropTypesSecret = __webpack_require__(109);
	
	var emptyFunction = __webpack_require__(93);
	var getIteratorFn = __webpack_require__(97);
	var warning = __webpack_require__(92);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	  symbol: createPrimitiveTypeChecker('symbol'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	/*eslint-disable no-self-compare*/
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	/*eslint-enable no-self-compare*/
	
	/**
	 * We use an Error-like object for backward compatibility as people may call
	 * PropTypes directly and inspect their output. However we don't use real
	 * Errors anymore. We don't inspect their stack anyway, and creating them
	 * is prohibitively expensive if they are created too often, such as what
	 * happens in oneOfType() for any type before the one that matched.
	 */
	function PropTypeError(message) {
	  this.message = message;
	  this.stack = '';
	}
	// Make `instanceof Error` still work for returned errors.
	PropTypeError.prototype = Error.prototype;
	
	function createChainableTypeChecker(validate) {
	  if (process.env.NODE_ENV !== 'production') {
	    var manualPropTypeCallCache = {};
	  }
	  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (process.env.NODE_ENV !== 'production') {
	      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
	        var cacheKey = componentName + ':' + propName;
	        if (!manualPropTypeCallCache[cacheKey]) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;
	          manualPropTypeCallCache[cacheKey] = true;
	        }
	      }
	    }
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        if (props[propName] === null) {
	          return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	        }
	        return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName, secret) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	    }
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!ReactElement.isValidElement(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (is(propValue, expectedValues[i])) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	    }
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }
	
	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }
	
	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }
	
	  return false;
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return ANONYMOUS;
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 111 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	module.exports = '15.4.2';

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	'use strict';
	
	var _prodInvariant = __webpack_require__(88);
	
	var ReactElement = __webpack_require__(90);
	
	var invariant = __webpack_require__(89);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(114);

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactDefaultInjection = __webpack_require__(119);
	var ReactMount = __webpack_require__(247);
	var ReactReconciler = __webpack_require__(140);
	var ReactUpdates = __webpack_require__(137);
	var ReactVersion = __webpack_require__(252);
	
	var findDOMNode = __webpack_require__(253);
	var getHostComponentFromComposite = __webpack_require__(254);
	var renderSubtreeIntoContainer = __webpack_require__(255);
	var warning = __webpack_require__(92);
	
	ReactDefaultInjection.inject();
	
	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function getNodeFromInstance(inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(129);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(143);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(256);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(257);
	  var ReactDOMInvalidARIAHook = __webpack_require__(258);
	
	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
	}
	
	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var DOMProperty = __webpack_require__(117);
	var ReactDOMComponentFlags = __webpack_require__(118);
	
	var invariant = __webpack_require__(89);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;
	
	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
	
	/**
	 * Check if a given node should be cached.
	 */
	function shouldPrecacheNode(node, nodeID) {
	  return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
	}
	
	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}
	
	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}
	
	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}
	
	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (shouldPrecacheNode(childNode, childID)) {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}
	
	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }
	
	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }
	
	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }
	
	  return closest;
	}
	
	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  if (inst._hostNode) {
	    return inst._hostNode;
	  }
	
	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }
	
	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }
	
	  return inst._hostNode;
	}
	
	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};
	
	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 116 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var invariant = __webpack_require__(89);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	
	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',
	
	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   *
	   * autofocus is predefined, because adding it to the property whitelist
	   * causes unintended side effects.
	   *
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? { autofocus: 'autoFocus' } : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function isCustomAttribute(attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 118 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};
	
	module.exports = ReactDOMComponentFlags;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ARIADOMPropertyConfig = __webpack_require__(120);
	var BeforeInputEventPlugin = __webpack_require__(121);
	var ChangeEventPlugin = __webpack_require__(136);
	var DefaultEventPluginOrder = __webpack_require__(153);
	var EnterLeaveEventPlugin = __webpack_require__(154);
	var HTMLDOMPropertyConfig = __webpack_require__(159);
	var ReactComponentBrowserEnvironment = __webpack_require__(160);
	var ReactDOMComponent = __webpack_require__(173);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactDOMEmptyComponent = __webpack_require__(218);
	var ReactDOMTreeTraversal = __webpack_require__(219);
	var ReactDOMTextComponent = __webpack_require__(220);
	var ReactDefaultBatchingStrategy = __webpack_require__(221);
	var ReactEventListener = __webpack_require__(222);
	var ReactInjection = __webpack_require__(225);
	var ReactReconcileTransaction = __webpack_require__(226);
	var SVGDOMPropertyConfig = __webpack_require__(234);
	var SelectEventPlugin = __webpack_require__(235);
	var SimpleEventPlugin = __webpack_require__(236);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 120 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ARIADOMPropertyConfig = {
	  Properties: {
	    // Global States and Properties
	    'aria-current': 0, // state
	    'aria-details': 0,
	    'aria-disabled': 0, // state
	    'aria-hidden': 0, // state
	    'aria-invalid': 0, // state
	    'aria-keyshortcuts': 0,
	    'aria-label': 0,
	    'aria-roledescription': 0,
	    // Widget Attributes
	    'aria-autocomplete': 0,
	    'aria-checked': 0,
	    'aria-expanded': 0,
	    'aria-haspopup': 0,
	    'aria-level': 0,
	    'aria-modal': 0,
	    'aria-multiline': 0,
	    'aria-multiselectable': 0,
	    'aria-orientation': 0,
	    'aria-placeholder': 0,
	    'aria-pressed': 0,
	    'aria-readonly': 0,
	    'aria-required': 0,
	    'aria-selected': 0,
	    'aria-sort': 0,
	    'aria-valuemax': 0,
	    'aria-valuemin': 0,
	    'aria-valuenow': 0,
	    'aria-valuetext': 0,
	    // Live Region Attributes
	    'aria-atomic': 0,
	    'aria-busy': 0,
	    'aria-live': 0,
	    'aria-relevant': 0,
	    // Drag-and-Drop Attributes
	    'aria-dropeffect': 0,
	    'aria-grabbed': 0,
	    // Relationship Attributes
	    'aria-activedescendant': 0,
	    'aria-colcount': 0,
	    'aria-colindex': 0,
	    'aria-colspan': 0,
	    'aria-controls': 0,
	    'aria-describedby': 0,
	    'aria-errormessage': 0,
	    'aria-flowto': 0,
	    'aria-labelledby': 0,
	    'aria-owns': 0,
	    'aria-posinset': 0,
	    'aria-rowcount': 0,
	    'aria-rowindex': 0,
	    'aria-rowspan': 0,
	    'aria-setsize': 0
	  },
	  DOMAttributeNames: {},
	  DOMPropertyNames: {}
	};
	
	module.exports = ARIADOMPropertyConfig;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var EventPropagators = __webpack_require__(122);
	var ExecutionEnvironment = __webpack_require__(129);
	var FallbackCompositionState = __webpack_require__(130);
	var SyntheticCompositionEvent = __webpack_require__(133);
	var SyntheticInputEvent = __webpack_require__(135);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return (typeof opera === 'undefined' ? 'undefined' : _typeof(opera)) === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: 'onBeforeInput',
	      captured: 'onBeforeInputCapture'
	    },
	    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionEnd',
	      captured: 'onCompositionEndCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionStart',
	      captured: 'onCompositionStartCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionUpdate',
	      captured: 'onCompositionUpdateCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case 'topCompositionStart':
	      return eventTypes.compositionStart;
	    case 'topCompositionEnd':
	      return eventTypes.compositionEnd;
	    case 'topCompositionUpdate':
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topKeyUp':
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case 'topKeyDown':
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case 'topKeyPress':
	    case 'topMouseDown':
	    case 'topBlur':
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topCompositionEnd':
	      return getDataFromCustomEvent(nativeEvent);
	    case 'topKeyPress':
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case 'topTextInput':
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  // If composition event is available, we extract a string only at
	  // compositionevent, otherwise extract it at fallback events.
	  if (currentComposition) {
	    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case 'topPaste':
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case 'topKeyPress':
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case 'topCompositionEnd':
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(123);
	var EventPluginUtils = __webpack_require__(125);
	
	var accumulateInto = __webpack_require__(127);
	var forEachAccumulated = __webpack_require__(128);
	var warning = __webpack_require__(92);
	
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, phase, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(116);
	
	var EventPluginRegistry = __webpack_require__(124);
	var EventPluginUtils = __webpack_require__(125);
	var ReactErrorUtils = __webpack_require__(126);
	
	var accumulateInto = __webpack_require__(127);
	var forEachAccumulated = __webpack_require__(128);
	var invariant = __webpack_require__(89);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	var getDictionaryKey = function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};
	
	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}
	
	function shouldPreventMouseEvent(name, type, props) {
	  switch (name) {
	    case 'onClick':
	    case 'onClickCapture':
	    case 'onDoubleClick':
	    case 'onDoubleClickCapture':
	    case 'onMouseDown':
	    case 'onMouseDownCapture':
	    case 'onMouseMove':
	    case 'onMouseMoveCapture':
	    case 'onMouseUp':
	    case 'onMouseUpCapture':
	      return !!(props.disabled && isInteractive(type));
	    default:
	      return false;
	  }
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function putListener(inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : _prodInvariant('94', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : void 0;
	
	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function getListener(inst, registrationName) {
	    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
	    // live here; needs to be moved to a better place soon
	    var bankForRegistrationName = listenerBank[registrationName];
	    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
	      return null;
	    }
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function deleteListener(inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function deleteAllListeners(inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }
	
	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }
	
	      delete listenerBank[registrationName][key];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function enqueueEvents(events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function processEventQueue(simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function __purge() {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function __getListenerBank() {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var invariant = __webpack_require__(89);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var eventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!eventPluginOrder) {
	    // Wait until an `eventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var pluginModule = namesToPlugins[pluginName];
	    var pluginIndex = eventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
	    var publishedEvents = pluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, pluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
	
	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	  // Trust the developer to only use possibleRegistrationNames in __DEV__
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function injectEventPluginOrder(injectedEventPluginOrder) {
	    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var pluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = pluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function getPluginModuleForEvent(event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    if (dispatchConfig.phasedRegistrationNames !== undefined) {
	      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
	      // that it is not undefined.
	      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	
	      for (var phase in phasedRegistrationNames) {
	        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
	          continue;
	        }
	        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
	        if (pluginModule) {
	          return pluginModule;
	        }
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function _resetEventPlugins() {
	    eventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var ReactErrorUtils = __webpack_require__(126);
	
	var invariant = __webpack_require__(89);
	var warning = __webpack_require__(92);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function injectComponentTree(Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function injectTreeTraversal(Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};
	
	function isEndish(topLevelType) {
	  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
	}
	function isStartish(topLevelType) {
	  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function validateEventDispatches(event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getInstanceFromNode: function getInstanceFromNode(node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function getNodeFromInstance(node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function isAncestor(a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function getLowestCommonAncestor(a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function getParentInstance(inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function traverseTwoPhase(target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a) {
	  try {
	    func(a);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function rethrowCaughtError() {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
	      var boundFunc = func.bind(null, a);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      // $FlowFixMe https://github.com/facebook/flow/issues/2336
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var invariant = __webpack_require__(89);
	
	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
	
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }
	
	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 128 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}
	
	module.exports = forEachAccumulated;

/***/ },
/* 129 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var PooledClass = __webpack_require__(131);
	
	var getTextContentAccessor = __webpack_require__(132);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	_assign(FallbackCompositionState.prototype, {
	  destructor: function destructor() {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function getText() {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function getData() {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var invariant = __webpack_require__(89);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var standardReleaser = function standardReleaser(instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(129);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(134);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var PooledClass = __webpack_require__(131);
	
	var emptyFunction = __webpack_require__(93);
	var warning = __webpack_require__(92);
	
	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';
	
	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function timeStamp(event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }
	
	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}
	
	_assign(SyntheticEvent.prototype, {
	
	  preventDefault: function preventDefault() {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else if (typeof event.returnValue !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function stopPropagation() {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }
	
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function persist() {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function destructor() {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function construct(target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function apply(constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function set(target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var E = function E() {};
	  E.prototype = Super.prototype;
	  var prototype = new E();
	
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	
	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };
	
	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }
	
	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }
	
	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(134);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(123);
	var EventPropagators = __webpack_require__(122);
	var ExecutionEnvironment = __webpack_require__(129);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactUpdates = __webpack_require__(137);
	var SyntheticEvent = __webpack_require__(134);
	
	var getEventTarget = __webpack_require__(150);
	var isEventSupported = __webpack_require__(151);
	var isTextInputElement = __webpack_require__(152);
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: 'onChange',
	      captured: 'onChangeCapture'
	    },
	    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}
	
	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topChange') {
	    return targetInst;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	  // IE10+ fire input events to often, such when a placeholder
	  // changes or when an input with a placeholder is focused.
	  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
	}
	
	/**
	 * (For IE <=11) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function get() {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function set(val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For IE <=11) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  if (activeElement.attachEvent) {
	    activeElement.attachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.addEventListener('propertychange', handlePropertyChange, false);
	  }
	}
	
	/**
	 * (For IE <=11) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	
	  if (activeElement.detachEvent) {
	    activeElement.detachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
	  }
	
	  activeElement = null;
	  activeElementInst = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For IE <=11) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetInstForInputEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topInput') {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return targetInst;
	  }
	}
	
	function handleEventsForInputEventIE(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9-11, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetInstForInputEventIE(topLevelType, targetInst) {
	  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementInst;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetInstForClickEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topClick') {
	    return targetInst;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }
	
	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst);
	      if (inst) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116),
	    _assign = __webpack_require__(85);
	
	var CallbackQueue = __webpack_require__(138);
	var PooledClass = __webpack_require__(131);
	var ReactFeatureFlags = __webpack_require__(139);
	var ReactReconciler = __webpack_require__(140);
	var Transaction = __webpack_require__(149);
	
	var invariant = __webpack_require__(89);
	
	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}
	
	var NESTED_UPDATES = {
	  initialize: function initialize() {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function close() {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function initialize() {
	    this.callbackQueue.reset();
	  },
	  close: function close() {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}
	
	_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function destructor() {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function perform(method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.type.isReactTopLevelWrapper) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
	
	    if (markerName) {
	      console.timeEnd(markerName);
	    }
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function flushBatchedUpdates() {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var PooledClass = __webpack_require__(131);
	
	var invariant = __webpack_require__(89);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	
	var CallbackQueue = function () {
	  function CallbackQueue(arg) {
	    _classCallCheck(this, CallbackQueue);
	
	    this._callbacks = null;
	    this._contexts = null;
	    this._arg = arg;
	  }
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	
	  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._callbacks.push(callback);
	    this._contexts = this._contexts || [];
	    this._contexts.push(context);
	  };
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	
	  CallbackQueue.prototype.notifyAll = function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    var arg = this._arg;
	    if (callbacks && contexts) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i], arg);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  };
	
	  CallbackQueue.prototype.checkpoint = function checkpoint() {
	    return this._callbacks ? this._callbacks.length : 0;
	  };
	
	  CallbackQueue.prototype.rollback = function rollback(len) {
	    if (this._callbacks && this._contexts) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  };
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	
	  CallbackQueue.prototype.reset = function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  };
	
	  /**
	   * `PooledClass` looks for this.
	   */
	
	  CallbackQueue.prototype.destructor = function destructor() {
	    this.reset();
	  };
	
	  return CallbackQueue;
	}();
	
	module.exports = PooledClass.addPoolingTo(CallbackQueue);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 139 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};
	
	module.exports = ReactFeatureFlags;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(141);
	var ReactInstrumentation = __webpack_require__(143);
	
	var warning = __webpack_require__(92);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
	  ) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },
	
	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function getHostNode(internalInstance) {
	    return internalInstance.getHostNode();
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function receiveComponent(internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactOwner = __webpack_require__(142);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || (typeof element === 'undefined' ? 'undefined' : _typeof(element)) !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevRef = null;
	  var prevOwner = null;
	  if (prevElement !== null && (typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement)) === 'object') {
	    prevRef = prevElement.ref;
	    prevOwner = prevElement._owner;
	  }
	
	  var nextRef = null;
	  var nextOwner = null;
	  if (nextElement !== null && (typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement)) === 'object') {
	    nextRef = nextElement.ref;
	    nextOwner = nextElement._owner;
	  }
	
	  return prevRef !== nextRef ||
	  // If owner changes but we have an unchanged function ref, don't update refs
	  typeof nextRef === 'string' && nextOwner !== prevOwner;
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || (typeof element === 'undefined' ? 'undefined' : _typeof(element)) !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var invariant = __webpack_require__(89);
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid owner.
	 * @final
	 */
	function isValidOwner(object) {
	  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	}
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function addComponentAsRefTo(component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function removeComponentAsRefFrom(component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// Trust the developer to only use ReactInstrumentation with a __DEV__ check
	
	var debugTool = null;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(144);
	  debugTool = ReactDebugTool;
	}
	
	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactInvalidSetStateWarningHook = __webpack_require__(145);
	var ReactHostOperationHistoryHook = __webpack_require__(146);
	var ReactComponentTreeHook = __webpack_require__(107);
	var ExecutionEnvironment = __webpack_require__(129);
	
	var performanceNow = __webpack_require__(147);
	var warning = __webpack_require__(92);
	
	var hooks = [];
	var didHookThrowForEvent = {};
	
	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}
	
	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}
	
	var _isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = [];
	var currentFlushStartTime = 0;
	var currentTimerDebugID = null;
	var currentTimerStartTime = 0;
	var currentTimerNestedFlushDuration = 0;
	var currentTimerType = null;
	
	var lifeCycleTimerHasWarned = false;
	
	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}
	
	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}
	
	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements;
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();
	
	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = 0;
	    currentFlushMeasurements = [];
	    clearHistory();
	    return;
	  }
	
	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }
	
	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}
	
	function checkDebugID(debugID) {
	  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}
	
	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (_isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
	      startTime = _lifeCycleTimerStack$.startTime,
	      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
	      debugID = _lifeCycleTimerStack$.debugID,
	      timerType = _lifeCycleTimerStack$.timerType;
	
	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	var lastMarkTimeStamp = 0;
	var canUsePerformanceMeasure =
	// $FlowFixMe https://github.com/facebook/flow/issues/2345
	typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
	
	function shouldMark(debugID) {
	  if (!_isProfiling || !canUsePerformanceMeasure) {
	    return false;
	  }
	  var element = ReactComponentTreeHook.getElement(debugID);
	  if (element == null || (typeof element === 'undefined' ? 'undefined' : _typeof(element)) !== 'object') {
	    return false;
	  }
	  var isHostElement = typeof element.type === 'string';
	  if (isHostElement) {
	    return false;
	  }
	  return true;
	}
	
	function markBegin(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }
	
	  var markName = debugID + '::' + markType;
	  lastMarkTimeStamp = performanceNow();
	  performance.mark(markName);
	}
	
	function markEnd(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }
	
	  var markName = debugID + '::' + markType;
	  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';
	
	  // Chrome has an issue of dropping markers recorded too fast:
	  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
	  // To work around this, we will not report very small measurements.
	  // I determined the magic number by tweaking it back and forth.
	  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
	  // When the bug is fixed, we can `measure()` unconditionally if we want to.
	  var timeStamp = performanceNow();
	  if (timeStamp - lastMarkTimeStamp > 0.1) {
	    var measurementName = displayName + ' [' + markType + ']';
	    performance.measure(measurementName, markName);
	  }
	
	  performance.clearMarks(markName);
	  performance.clearMeasures(measurementName);
	}
	
	var ReactDebugTool = {
	  addHook: function addHook(hook) {
	    hooks.push(hook);
	  },
	  removeHook: function removeHook(hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function isProfiling() {
	    return _isProfiling;
	  },
	  beginProfiling: function beginProfiling() {
	    if (_isProfiling) {
	      return;
	    }
	
	    _isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function endProfiling() {
	    if (!_isProfiling) {
	      return;
	    }
	
	    _isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function getFlushHistory() {
	    return flushHistory;
	  },
	  onBeginFlush: function onBeginFlush() {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function onEndFlush() {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function onBeginLifeCycleTimer(debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    markBegin(debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function onEndLifeCycleTimer(debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    markEnd(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onBeginProcessingChildContext: function onBeginProcessingChildContext() {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function onEndProcessingChildContext() {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function onHostOperation(operation) {
	    checkDebugID(operation.instanceID);
	    emitEvent('onHostOperation', operation);
	  },
	  onSetState: function onSetState() {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function onSetChildren(debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	    markBegin(debugID, 'mount');
	  },
	  onMountComponent: function onMountComponent(debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'mount');
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	    markBegin(debugID, 'update');
	  },
	  onUpdateComponent: function onUpdateComponent(debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'update');
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function onBeforeUnmountComponent(debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	    markBegin(debugID, 'unmount');
	  },
	  onUnmountComponent: function onUnmountComponent(debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'unmount');
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function onTestEvent() {
	    emitEvent('onTestEvent');
	  }
	};
	
	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
	
	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}
	
	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var warning = __webpack_require__(92);
	
	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;
	
	  var warnInvalidSetState = function warnInvalidSetState() {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}
	
	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function onBeginProcessingChildContext() {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function onEndProcessingChildContext() {
	    processingChildContext = false;
	  },
	  onSetState: function onSetState() {
	    warnInvalidSetState();
	  }
	};
	
	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 146 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var history = [];
	
	var ReactHostOperationHistoryHook = {
	  onHostOperation: function onHostOperation(operation) {
	    history.push(operation);
	  },
	  clearHistory: function clearHistory() {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }
	
	    history = [];
	  },
	  getHistory: function getHistory() {
	    return history;
	  }
	};
	
	module.exports = ReactHostOperationHistoryHook;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var performance = __webpack_require__(148);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(129);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var invariant = __webpack_require__(89);
	
	var OBSERVED_ERROR = {};
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var TransactionImpl = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function reinitializeTransaction() {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function isInTransaction() {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function perform(method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function initializeAll(startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function closeAll(startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	module.exports = TransactionImpl;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 150 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	
	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }
	
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(129);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 152 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	
	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }
	
	  if (nodeName === 'textarea') {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 153 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	
	var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(122);
	var ReactDOMComponentTree = __webpack_require__(115);
	var SyntheticMouseEvent = __webpack_require__(155);
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: 'onMouseEnter',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  },
	  mouseLeave: {
	    registrationName: 'onMouseLeave',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  }
	};
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    if (topLevelType === 'topMouseOut') {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
	
	    return [leave, enter];
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(156);
	var ViewportMetrics = __webpack_require__(157);
	
	var getEventModifierState = __webpack_require__(158);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function button(event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function relatedTarget(event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function pageX(event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function pageY(event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(134);
	
	var getEventTarget = __webpack_require__(150);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function view(event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function detail(event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function refreshScrollValues(scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 158 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(117);
	
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    // specifies target context for links with `preload` type
	    as: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    playsInline: HAS_BOOLEAN_VALUE,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,
	
	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {}
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(161);
	var ReactDOMIDOperations = __webpack_require__(172);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMLazyTree = __webpack_require__(162);
	var Danger = __webpack_require__(168);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactInstrumentation = __webpack_require__(143);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(165);
	var setInnerHTML = __webpack_require__(164);
	var setTextContent = __webpack_require__(166);
	
	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});
	
	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}
	
	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}
	
	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}
	
	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}
	
	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}
	
	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation({
	      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
	      type: 'replace text',
	      payload: stringText
	    });
	  }
	}
	
	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function dangerouslyReplaceNodeWithMarkup(oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: prevInstance._debugID,
	        type: 'replace with',
	        payload: markup.toString()
	      });
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: nextInstance._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  };
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
	
	  replaceDelimitedText: replaceDelimitedText,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function processUpdates(parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case 'INSERT_MARKUP':
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'insert child',
	              payload: { toIndex: update.toIndex, content: update.content.toString() }
	            });
	          }
	          break;
	        case 'MOVE_EXISTING':
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'move child',
	              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
	            });
	          }
	          break;
	        case 'SET_MARKUP':
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace children',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'TEXT_CONTENT':
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace text',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'REMOVE_NODE':
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'remove child',
	              payload: { fromIndex: update.fromIndex }
	            });
	          }
	          break;
	      }
	    }
	  }
	
	};
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMNamespaces = __webpack_require__(163);
	var setInnerHTML = __webpack_require__(164);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(165);
	var setTextContent = __webpack_require__(166);
	
	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
	
	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}
	
	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});
	
	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}
	
	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}
	
	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}
	
	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}
	
	function toString() {
	  return this.node.nodeName;
	}
	
	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}
	
	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;
	
	module.exports = DOMLazyTree;

/***/ },
/* 163 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};
	
	module.exports = DOMNamespaces;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(129);
	var DOMNamespaces = __webpack_require__(163);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(165);
	
	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var svgNode = reusableSVGContainer.firstChild;
	    while (svgNode.firstChild) {
	      node.appendChild(svgNode.firstChild);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function setInnerHTML(node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 165 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	
	var createMicrosoftUnsafeLocalFunction = function createMicrosoftUnsafeLocalFunction(func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};
	
	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(129);
	var escapeTextContentForBrowser = __webpack_require__(167);
	var setInnerHTML = __webpack_require__(164);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function setTextContent(node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	
	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function setTextContent(node, text) {
	      if (node.nodeType === 3) {
	        node.nodeValue = text;
	        return;
	      }
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 167 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */
	
	'use strict';
	
	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html
	
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var DOMLazyTree = __webpack_require__(162);
	var ExecutionEnvironment = __webpack_require__(129);
	
	var createNodesFromMarkup = __webpack_require__(169);
	var emptyFunction = __webpack_require__(93);
	var invariant = __webpack_require__(89);
	
	var Danger = {
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
	
	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	var ExecutionEnvironment = __webpack_require__(129);
	
	var createArrayFromMixed = __webpack_require__(170);
	var getMarkupWrap = __webpack_require__(171);
	var invariant = __webpack_require__(89);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var invariant = __webpack_require__(89);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
	
	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	var ExecutionEnvironment = __webpack_require__(129);
	
	var invariant = __webpack_require__(89);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(161);
	var ReactDOMComponentTree = __webpack_require__(115);
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(116),
	    _assign = __webpack_require__(85);
	
	var AutoFocusUtils = __webpack_require__(174);
	var CSSPropertyOperations = __webpack_require__(176);
	var DOMLazyTree = __webpack_require__(162);
	var DOMNamespaces = __webpack_require__(163);
	var DOMProperty = __webpack_require__(117);
	var DOMPropertyOperations = __webpack_require__(184);
	var EventPluginHub = __webpack_require__(123);
	var EventPluginRegistry = __webpack_require__(124);
	var ReactBrowserEventEmitter = __webpack_require__(186);
	var ReactDOMComponentFlags = __webpack_require__(118);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactDOMInput = __webpack_require__(189);
	var ReactDOMOption = __webpack_require__(192);
	var ReactDOMSelect = __webpack_require__(193);
	var ReactDOMTextarea = __webpack_require__(194);
	var ReactInstrumentation = __webpack_require__(143);
	var ReactMultiChild = __webpack_require__(195);
	var ReactServerRenderingTransaction = __webpack_require__(214);
	
	var emptyFunction = __webpack_require__(93);
	var escapeTextContentForBrowser = __webpack_require__(167);
	var invariant = __webpack_require__(89);
	var isEventSupported = __webpack_require__(151);
	var shallowEqual = __webpack_require__(204);
	var validateDOMNesting = __webpack_require__(217);
	var warning = __webpack_require__(92);
	
	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var STYLE = 'style';
	var HTML = '__html';
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};
	
	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	function friendlyStringify(obj) {
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || _typeof(props.style) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}
	
	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}
	
	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}
	
	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}
	
	var setAndValidateContentChildDev = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setAndValidateContentChildDev = function setAndValidateContentChildDev(content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;
	
	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }
	
	    validateDOMNesting(null, String(content), this, this._ancestorInfo);
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
	
	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
	      break;
	  }
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = _assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	var globalIdCounter = 1;
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setAndValidateContentChildDev.call(this, null);
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }
	
	    assertValidProps(this, props);
	
	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, null, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function _createContentMarkup(transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function _createInitialChildren(transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      // TODO: Validate that text is allowed as a child of this node
	      if (contentToUse != null) {
	        // Avoid setting textContent when the text is empty. In IE11 setting
	        // textContent on a text area will cause the placeholder to not
	        // show within the textarea until it has been focused and blurred again.
	        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
	        if (contentToUse !== '') {
	          if (process.env.NODE_ENV !== 'production') {
	            setAndValidateContentChildDev.call(this, contentToUse);
	          }
	          DOMLazyTree.queueText(lazyTree, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function receiveComponent(nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[_typeof(lastProps.children)] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[_typeof(nextProps.children)] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setAndValidateContentChildDev.call(this, null);
	      }
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  getHostNode: function getHostNode() {
	    return getNode(this);
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function unmountComponent(safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }
	
	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;
	
	    if (process.env.NODE_ENV !== 'production') {
	      setAndValidateContentChildDev.call(this, null);
	    }
	  },
	
	  getPublicInstance: function getPublicInstance() {
	    return getNode(this);
	  }
	
	};
	
	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(115);
	
	var focusNode = __webpack_require__(175);
	
	var AutoFocusUtils = {
	  focusDOMComponent: function focusDOMComponent() {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 175 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(177);
	var ExecutionEnvironment = __webpack_require__(129);
	var ReactInstrumentation = __webpack_require__(143);
	
	var camelizeStyleName = __webpack_require__(178);
	var dangerousStyleValue = __webpack_require__(180);
	var hyphenateStyleName = __webpack_require__(181);
	var memoizeStringOnly = __webpack_require__(183);
	var warning = __webpack_require__(92);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	
	  var warnHyphenatedStyleName = function warnHyphenatedStyleName(name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnBadVendoredStyleName = function warnBadVendoredStyleName(name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };
	
	  var warnStyleValueIsNaN = function warnStyleValueIsNaN(name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }
	
	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };
	
	  var checkRenderMessage = function checkRenderMessage(owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function warnValidStyle(name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }
	
	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function createMarkupForStyles(styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue, component);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function setValueForStyles(node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: component._debugID,
	        type: 'update styles',
	        payload: styles
	      });
	    }
	
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName], component);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 177 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridColumn: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(179);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 179 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(177);
	var warning = __webpack_require__(92);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(182);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 182 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 183 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(117);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactInstrumentation = __webpack_require__(143);
	
	var quoteAttributeValueForBrowser = __webpack_require__(185);
	var warning = __webpack_require__(92);
	
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function createMarkupForID(id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function setAttributeForID(node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  createMarkupForRoot: function createMarkupForRoot() {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },
	
	  setAttributeForRoot: function setAttributeForRoot(node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function createMarkupForProperty(name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function setValueForProperty(node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },
	
	  setValueForAttribute: function setValueForAttribute(node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },
	
	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function deleteValueForAttribute(node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function deleteValueForProperty(node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  }
	
	};
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(167);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var EventPluginRegistry = __webpack_require__(124);
	var ReactEventEmitterMixin = __webpack_require__(187);
	var ViewportMetrics = __webpack_require__(157);
	
	var getVendorPrefixedEventName = __webpack_require__(188);
	var isEventSupported = __webpack_require__(151);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function injectReactEventListener(ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function setEnabled(enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function isEnabled() {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function listenTo(registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === 'topWheel') {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === 'topScroll') {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === 'topFocus' || dependency === 'topBlur') {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening.topBlur = true;
	          isListening.topFocus = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Protect against document.createEvent() returning null
	   * Some popup blocker extensions appear to do this:
	   * https://github.com/facebook/react/issues/6887
	   */
	  supportsEventPageXY: function supportsEventPageXY() {
	    if (!document.createEvent) {
	      return false;
	    }
	    var ev = document.createEvent('MouseEvent');
	    return ev != null && 'pageX' in ev;
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(123);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(129);
	
	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
	
	  return prefixes;
	}
	
	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};
	
	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};
	
	/**
	 * Element to check for prefixes on.
	 */
	var style = {};
	
	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }
	
	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}
	
	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }
	
	  var prefixMap = vendorPrefixes[eventName];
	
	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }
	
	  return '';
	}
	
	module.exports = getVendorPrefixedEventName;

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116),
	    _assign = __webpack_require__(85);
	
	var DOMPropertyOperations = __webpack_require__(184);
	var LinkedValueUtils = __webpack_require__(190);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactUpdates = __webpack_require__(137);
	
	var invariant = __webpack_require__(89);
	var warning = __webpack_require__(92);
	
	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked != null : props.value != null;
	}
	
	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function getHostProps(inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	
	      var owner = inst._currentElement._owner;
	
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      inst._wrapperState.controlled = isControlled(props);
	    }
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;
	
	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        // In Chrome, assigning defaultValue to certain input types triggers input validation.
	        // For number inputs, the display value loses trailing decimal points. For email inputs,
	        // Chrome raises "The specified value <x> is not a valid email address".
	        //
	        // Here we check to see if the defaultValue has actually changed, avoiding these problems
	        // when the user is inputting text
	        //
	        // https://github.com/facebook/react/issues/7253
	        if (node.defaultValue !== '' + props.defaultValue) {
	          node.defaultValue = '' + props.defaultValue;
	        }
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.
	
	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }
	
	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var React = __webpack_require__(84);
	var ReactPropTypesSecret = __webpack_require__(191);
	
	var invariant = __webpack_require__(89);
	var warning = __webpack_require__(92);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}
	
	var propTypes = {
	  value: function value(props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function checked(props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: React.PropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function checkPropTypes(tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function getValue(inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function getChecked(inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function executeOnChange(inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 191 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var React = __webpack_require__(84);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactDOMSelect = __webpack_require__(193);
	
	var warning = __webpack_require__(92);
	var didWarnInvalidOptionChildren = false;
	
	function flattenChildren(children) {
	  var content = '';
	
	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  React.Children.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });
	
	  return content;
	}
	
	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function mountWrapper(inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }
	
	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;
	
	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }
	
	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }
	
	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },
	
	  getHostProps: function getHostProps(inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = flattenChildren(props.children);
	
	    if (content) {
	      hostProps.children = content;
	    }
	
	    return hostProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var LinkedValueUtils = __webpack_require__(190);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactUpdates = __webpack_require__(137);
	
	var warning = __webpack_require__(92);
	
	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function getHostProps(inst, props) {
	    return _assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },
	
	  getSelectValueContext: function getSelectValueContext(inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },
	
	  postUpdateWrapper: function postUpdateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116),
	    _assign = __webpack_require__(85);
	
	var LinkedValueUtils = __webpack_require__(190);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactUpdates = __webpack_require__(137);
	
	var invariant = __webpack_require__(89);
	var warning = __webpack_require__(92);
	
	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function getHostProps(inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, props, {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;
	
	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }
	
	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }
	
	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var textContent = node.textContent;
	
	    // Only set node.value if textContent is equal to the expected
	    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
	    // will populate textContent as well.
	    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
	    if (textContent === inst._wrapperState.initialValue) {
	      node.value = textContent;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var ReactComponentEnvironment = __webpack_require__(196);
	var ReactInstanceMap = __webpack_require__(197);
	var ReactInstrumentation = __webpack_require__(143);
	
	var ReactCurrentOwner = __webpack_require__(91);
	var ReactReconciler = __webpack_require__(140);
	var ReactChildReconciler = __webpack_require__(198);
	
	var emptyFunction = __webpack_require__(93);
	var flattenChildren = __webpack_require__(213);
	var invariant = __webpack_require__(89);
	
	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'INSERT_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'MOVE_EXISTING',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'REMOVE_NODE',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'SET_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'TEXT_CONTENT',
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}
	
	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function getDebugID(inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function setChildrenForInstrumentation(children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function mountChildren(nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }
	
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function updateTextContent(nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function updateMarkup(nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },
	
	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function unmountChildren(safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function moveChild(child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function createChild(child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function removeChild(child, node) {
	      return makeRemove(child, node);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function _mountChildAtIndex(child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function _unmountChild(child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var invariant = __webpack_require__(89);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function injectEnvironment(environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 197 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function remove(key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function get(key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function has(key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function set(key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(140);
	
	var instantiateReactComponent = __webpack_require__(199);
	var KeyEscapeUtils = __webpack_require__(209);
	var shouldUpdateReactComponent = __webpack_require__(205);
	var traverseAllChildren = __webpack_require__(210);
	var warning = __webpack_require__(92);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(107);
	}
	
	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(107);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
	  ) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	
	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
	  ) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function unmountChildren(renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(116),
	    _assign = __webpack_require__(85);
	
	var ReactCompositeComponent = __webpack_require__(200);
	var ReactEmptyComponent = __webpack_require__(206);
	var ReactHostComponent = __webpack_require__(207);
	
	var getNextDebugID = __webpack_require__(208);
	var invariant = __webpack_require__(89);
	var warning = __webpack_require__(92);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function ReactCompositeComponentWrapper(element) {
	  this.construct(element);
	};
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
	    var element = node;
	    var type = element.type;
	    if (typeof type !== 'function' && typeof type !== 'string') {
	      var info = '';
	      if (process.env.NODE_ENV !== 'production') {
	        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
	          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
	        }
	      }
	      info += getDeclarationErrorAddendum(element._owner);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info) : _prodInvariant('130', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info) : void 0;
	    }
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	
	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : _prodInvariant('131', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : void 0;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(116),
	    _assign = __webpack_require__(85);
	
	var React = __webpack_require__(84);
	var ReactComponentEnvironment = __webpack_require__(196);
	var ReactCurrentOwner = __webpack_require__(91);
	var ReactErrorUtils = __webpack_require__(126);
	var ReactInstanceMap = __webpack_require__(197);
	var ReactInstrumentation = __webpack_require__(143);
	var ReactNodeTypes = __webpack_require__(201);
	var ReactReconciler = __webpack_require__(140);
	
	if (process.env.NODE_ENV !== 'production') {
	  var checkReactTypeSpec = __webpack_require__(202);
	}
	
	var emptyObject = __webpack_require__(101);
	var invariant = __webpack_require__(89);
	var shallowEqual = __webpack_require__(204);
	var shouldUpdateReactComponent = __webpack_require__(205);
	var warning = __webpack_require__(92);
	
	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};
	
	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}
	
	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}
	
	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}
	
	// Separated into a function to contain deoptimizations caused by try/finally.
	function measureLifeCyclePerf(fn, debugID, timerType) {
	  if (debugID === 0) {
	    // Top-level wrappers (see ReactMount) and empty components (see
	    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
	    // Both are implementation details that should go away in the future.
	    return fn();
	  }
	
	  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
	  try {
	    return fn();
	  } finally {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
	  }
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponent = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function construct(element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;
	
	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	
	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    var _this = this;
	
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    var updateQueue = transaction.getUpdateQueue();
	
	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;
	
	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }
	
	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';
	
	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	
	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(function () {
	            return inst.componentDidMount();
	          }, _this._debugID, 'componentDidMount');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }
	
	    return markup;
	  },
	
	  _constructComponent: function _constructComponent(doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },
	
	  _constructComponentWithoutOwner: function _constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;
	
	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        return measureLifeCyclePerf(function () {
	          return new Component(publicProps, publicContext, updateQueue);
	        }, this._debugID, 'ctor');
	      } else {
	        return new Component(publicProps, publicContext, updateQueue);
	      }
	    }
	
	    // This can still be an instance in case of factory components
	    // but we'll count this as time spent rendering as the more common case.
	    if (process.env.NODE_ENV !== 'production') {
	      return measureLifeCyclePerf(function () {
	        return Component(publicProps, publicContext, updateQueue);
	      }, this._debugID, 'render');
	    } else {
	      return Component(publicProps, publicContext, updateQueue);
	    }
	  },
	
	  performInitialMountWithErrorHandling: function performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();
	
	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);
	
	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },
	
	  performInitialMount: function performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;
	
	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }
	
	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillMount();
	        }, debugID, 'componentWillMount');
	      } else {
	        inst.componentWillMount();
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;
	
	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (debugID !== 0) {
	        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	      }
	    }
	
	    return markup;
	  },
	
	  getHostNode: function getHostNode() {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(safely) {
	    if (!this._renderedComponent) {
	      return;
	    }
	
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;
	
	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          measureLifeCyclePerf(function () {
	            return inst.componentWillUnmount();
	          }, this._debugID, 'componentWillUnmount');
	        } else {
	          inst.componentWillUnmount();
	        }
	      }
	    }
	
	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function _maskContext(context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function _processContext(context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function _processChildContext(currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext;
	
	    if (inst.getChildContext) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	        try {
	          childContext = inst.getChildContext();
	        } finally {
	          ReactInstrumentation.debugTool.onEndProcessingChildContext();
	        }
	      } else {
	        childContext = inst.getChildContext();
	      }
	    }
	
	    if (childContext) {
	      !(_typeof(Component.childContextTypes) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function _checkContextTypes(typeSpecs, values, location) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	    }
	  },
	
	  receiveComponent: function receiveComponent(nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    var willReceive = false;
	    var nextContext;
	
	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }
	
	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;
	
	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }
	
	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillReceiveProps(nextProps, nextContext);
	        }, this._debugID, 'componentWillReceiveProps');
	      } else {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;
	
	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          shouldUpdate = measureLifeCyclePerf(function () {
	            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	          }, this._debugID, 'shouldComponentUpdate');
	        } else {
	          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }
	
	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function _processPendingState(props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function _performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var _this2 = this;
	
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillUpdate(nextProps, nextState, nextContext);
	        }, this._debugID, 'componentWillUpdate');
	      } else {
	        inst.componentWillUpdate(nextProps, nextState, nextContext);
	      }
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function _updateRenderedComponent(transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	
	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }
	
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);
	
	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;
	
	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (debugID !== 0) {
	          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	        }
	      }
	
	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },
	
	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function _replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function _renderValidatedComponentWithoutOwnerOrContext() {
	    var inst = this._instance;
	    var renderedElement;
	
	    if (process.env.NODE_ENV !== 'production') {
	      renderedElement = measureLifeCyclePerf(function () {
	        return inst.render();
	      }, this._debugID, 'render');
	    } else {
	      renderedElement = inst.render();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedElement === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedElement = null;
	      }
	    }
	
	    return renderedElement;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function _renderValidatedComponent() {
	    var renderedElement;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    return renderedElement;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function attachRef(ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function detachRef(ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function getName() {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function getPublicInstance() {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var React = __webpack_require__(84);
	
	var invariant = __webpack_require__(89);
	
	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,
	
	  getType: function getType(node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (React.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};
	
	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(116);
	
	var ReactPropTypeLocationNames = __webpack_require__(203);
	var ReactPropTypesSecret = __webpack_require__(191);
	
	var invariant = __webpack_require__(89);
	var warning = __webpack_require__(92);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(107);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(107);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 204 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 205 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement);
	  var nextType = typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement);
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 206 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyComponentFactory;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function injectEmptyComponentFactory(factory) {
	    emptyComponentFactory = factory;
	  }
	};
	
	var ReactEmptyComponent = {
	  create: function create(instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var invariant = __webpack_require__(89);
	
	var genericComponentClass = null;
	var textComponentClass = null;
	
	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function injectGenericComponentClass(componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function injectTextComponentClass(componentClass) {
	    textComponentClass = componentClass;
	  }
	};
	
	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};
	
	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 208 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var nextDebugID = 1;
	
	function getNextDebugID() {
	  return nextDebugID++;
	}
	
	module.exports = getNextDebugID;

/***/ },
/* 209 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(116);
	
	var ReactCurrentOwner = __webpack_require__(91);
	var REACT_ELEMENT_TYPE = __webpack_require__(211);
	
	var getIteratorFn = __webpack_require__(212);
	var invariant = __webpack_require__(89);
	var KeyEscapeUtils = __webpack_require__(209);
	var warning = __webpack_require__(92);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && (typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 211 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	module.exports = REACT_ELEMENT_TYPE;

/***/ },
/* 212 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var KeyEscapeUtils = __webpack_require__(209);
	var traverseAllChildren = __webpack_require__(210);
	var warning = __webpack_require__(92);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(107);
	}
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && (typeof traverseContext === 'undefined' ? 'undefined' : _typeof(traverseContext)) === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(107);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	
	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var PooledClass = __webpack_require__(131);
	var Transaction = __webpack_require__(149);
	var ReactInstrumentation = __webpack_require__(143);
	var ReactServerUpdateQueue = __webpack_require__(215);
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	var noopCallbackQueue = {
	  enqueue: function enqueue() {}
	};
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return noopCallbackQueue;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function getUpdateQueue() {
	    return this.updateQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {},
	
	  checkpoint: function checkpoint() {},
	
	  rollback: function rollback() {}
	};
	
	_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var ReactUpdateQueue = __webpack_require__(216);
	
	var warning = __webpack_require__(92);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */
	
	var ReactServerUpdateQueue = function () {
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);
	
	    this.transaction = transaction;
	  }
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	
	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };
	
	  return ReactServerUpdateQueue;
	}();
	
	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(116);
	
	var ReactCurrentOwner = __webpack_require__(91);
	var ReactInstanceMap = __webpack_require__(197);
	var ReactInstrumentation = __webpack_require__(143);
	var ReactUpdates = __webpack_require__(137);
	
	var invariant = __webpack_require__(89);
	var warning = __webpack_require__(92);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function formatUnexpectedArgument(arg) {
	  var type = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }
	
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function enqueueElementInternal(internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },
	
	  validateCallback: function validateCallback(callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var emptyFunction = __webpack_require__(93);
	var warning = __webpack_require__(92);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    current: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.current = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function findOwnerStack(instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function validateDOMNesting(childTag, childText, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    if (childText != null) {
	      process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
	      childTag = '#text';
	    }
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      var tagDisplayName = childTag;
	      var whitespaceInfo = '';
	      if (childTag === '#text') {
	        if (/\S/.test(childText)) {
	          tagDisplayName = 'Text nodes';
	        } else {
	          tagDisplayName = 'Whitespace text nodes';
	          whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
	        }
	      } else {
	        tagDisplayName = '<' + childTag + '>';
	      }
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var DOMLazyTree = __webpack_require__(162);
	var ReactDOMComponentTree = __webpack_require__(115);
	
	var ReactDOMEmptyComponent = function ReactDOMEmptyComponent(instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function receiveComponent() {},
	  getHostNode: function getHostNode() {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function unmountComponent() {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMEmptyComponent;

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var invariant = __webpack_require__(89);
	
	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }
	
	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }
	
	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }
	
	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}
	
	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	
	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}
	
	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
	
	  return inst._hostParent;
	}
	
	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], 'captured', arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], 'bubbled', arg);
	  }
	}
	
	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], 'bubbled', argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], 'captured', argTo);
	  }
	}
	
	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116),
	    _assign = __webpack_require__(85);
	
	var DOMChildrenOperations = __webpack_require__(161);
	var DOMLazyTree = __webpack_require__(162);
	var ReactDOMComponentTree = __webpack_require__(115);
	
	var escapeTextContentForBrowser = __webpack_require__(167);
	var invariant = __webpack_require__(89);
	var validateDOMNesting = __webpack_require__(217);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function ReactDOMTextComponent(text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	
	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};
	
	_assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(null, this._stringText, this, parentInfo);
	      }
	    }
	
	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function receiveComponent(nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },
	
	  getHostNode: function getHostNode() {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },
	
	  unmountComponent: function unmountComponent() {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var ReactUpdates = __webpack_require__(137);
	var Transaction = __webpack_require__(149);
	
	var emptyFunction = __webpack_require__(93);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function close() {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      return callback(a, b, c, d, e);
	    } else {
	      return transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var EventListener = __webpack_require__(223);
	var ExecutionEnvironment = __webpack_require__(129);
	var PooledClass = __webpack_require__(131);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactUpdates = __webpack_require__(137);
	
	var getEventTarget = __webpack_require__(150);
	var getUnboundedScrollPosition = __webpack_require__(224);
	
	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function destructor() {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function setEnabled(enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function isEnabled() {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function monitorScrollValue(refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(93);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 224 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(117);
	var EventPluginHub = __webpack_require__(123);
	var EventPluginUtils = __webpack_require__(125);
	var ReactComponentEnvironment = __webpack_require__(196);
	var ReactEmptyComponent = __webpack_require__(206);
	var ReactBrowserEventEmitter = __webpack_require__(186);
	var ReactHostComponent = __webpack_require__(207);
	var ReactUpdates = __webpack_require__(137);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(85);
	
	var CallbackQueue = __webpack_require__(138);
	var PooledClass = __webpack_require__(131);
	var ReactBrowserEventEmitter = __webpack_require__(186);
	var ReactInputSelection = __webpack_require__(227);
	var ReactInstrumentation = __webpack_require__(143);
	var Transaction = __webpack_require__(149);
	var ReactUpdateQueue = __webpack_require__(216);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function initialize() {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function close(previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function close() {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function getUpdateQueue() {
	    return ReactUpdateQueue;
	  },
	
	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function checkpoint() {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },
	
	  rollback: function rollback(checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(228);
	
	var containsNode = __webpack_require__(230);
	var focusNode = __webpack_require__(175);
	var getActiveElement = __webpack_require__(233);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function getSelectionInformation() {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function restoreSelection(priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function getSelection(input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function setSelection(input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(129);
	
	var getNodeForCharacterOffset = __webpack_require__(229);
	var getTextContentAccessor = __webpack_require__(132);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 229 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(231);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(232);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 232 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 233 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 234 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};
	
	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(122);
	var ExecutionEnvironment = __webpack_require__(129);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactInputSelection = __webpack_require__(227);
	var SyntheticEvent = __webpack_require__(134);
	
	var getActiveElement = __webpack_require__(233);
	var isTextInputElement = __webpack_require__(152);
	var shallowEqual = __webpack_require__(204);
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: 'onSelect',
	      captured: 'onSelectCapture'
	    },
	    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
	  }
	};
	
	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case 'topFocus':
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case 'topBlur':
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case 'topMouseDown':
	        mouseDown = true;
	        break;
	      case 'topContextMenu':
	      case 'topMouseUp':
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case 'topSelectionChange':
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case 'topKeyDown':
	      case 'topKeyUp':
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function didPutListener(inst, registrationName, listener) {
	    if (registrationName === 'onSelect') {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var EventListener = __webpack_require__(223);
	var EventPropagators = __webpack_require__(122);
	var ReactDOMComponentTree = __webpack_require__(115);
	var SyntheticAnimationEvent = __webpack_require__(237);
	var SyntheticClipboardEvent = __webpack_require__(238);
	var SyntheticEvent = __webpack_require__(134);
	var SyntheticFocusEvent = __webpack_require__(239);
	var SyntheticKeyboardEvent = __webpack_require__(240);
	var SyntheticMouseEvent = __webpack_require__(155);
	var SyntheticDragEvent = __webpack_require__(243);
	var SyntheticTouchEvent = __webpack_require__(244);
	var SyntheticTransitionEvent = __webpack_require__(245);
	var SyntheticUIEvent = __webpack_require__(156);
	var SyntheticWheelEvent = __webpack_require__(246);
	
	var emptyFunction = __webpack_require__(93);
	var getEventCharCode = __webpack_require__(241);
	var invariant = __webpack_require__(89);
	
	/**
	 * Turns
	 * ['abort', ...]
	 * into
	 * eventTypes = {
	 *   'abort': {
	 *     phasedRegistrationNames: {
	 *       bubbled: 'onAbort',
	 *       captured: 'onAbortCapture',
	 *     },
	 *     dependencies: ['topAbort'],
	 *   },
	 *   ...
	 * };
	 * topLevelEventsToDispatchConfig = {
	 *   'topAbort': { sameConfig }
	 * };
	 */
	var eventTypes = {};
	var topLevelEventsToDispatchConfig = {};
	['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
	  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
	  var onEvent = 'on' + capitalizedEvent;
	  var topEvent = 'top' + capitalizedEvent;
	
	  var type = {
	    phasedRegistrationNames: {
	      bubbled: onEvent,
	      captured: onEvent + 'Capture'
	    },
	    dependencies: [topEvent]
	  };
	  eventTypes[event] = type;
	  topLevelEventsToDispatchConfig[topEvent] = type;
	});
	
	var onClickListeners = {};
	
	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}
	
	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case 'topAbort':
	      case 'topCanPlay':
	      case 'topCanPlayThrough':
	      case 'topDurationChange':
	      case 'topEmptied':
	      case 'topEncrypted':
	      case 'topEnded':
	      case 'topError':
	      case 'topInput':
	      case 'topInvalid':
	      case 'topLoad':
	      case 'topLoadedData':
	      case 'topLoadedMetadata':
	      case 'topLoadStart':
	      case 'topPause':
	      case 'topPlay':
	      case 'topPlaying':
	      case 'topProgress':
	      case 'topRateChange':
	      case 'topReset':
	      case 'topSeeked':
	      case 'topSeeking':
	      case 'topStalled':
	      case 'topSubmit':
	      case 'topSuspend':
	      case 'topTimeUpdate':
	      case 'topVolumeChange':
	      case 'topWaiting':
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case 'topKeyPress':
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case 'topKeyDown':
	      case 'topKeyUp':
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case 'topBlur':
	      case 'topFocus':
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case 'topClick':
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case 'topDoubleClick':
	      case 'topMouseDown':
	      case 'topMouseMove':
	      case 'topMouseUp':
	      // TODO: Disabled elements should not respond to mouse events
	      /* falls through */
	      case 'topMouseOut':
	      case 'topMouseOver':
	      case 'topContextMenu':
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case 'topDrag':
	      case 'topDragEnd':
	      case 'topDragEnter':
	      case 'topDragExit':
	      case 'topDragLeave':
	      case 'topDragOver':
	      case 'topDragStart':
	      case 'topDrop':
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case 'topTouchCancel':
	      case 'topTouchEnd':
	      case 'topTouchMove':
	      case 'topTouchStart':
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case 'topAnimationEnd':
	      case 'topAnimationIteration':
	      case 'topAnimationStart':
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case 'topTransitionEnd':
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case 'topScroll':
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case 'topWheel':
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case 'topCopy':
	      case 'topCut':
	      case 'topPaste':
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function didPutListener(inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function willDeleteListener(inst, registrationName) {
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(134);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
	
	module.exports = SyntheticAnimationEvent;

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(134);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function clipboardData(event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(156);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(156);
	
	var getEventCharCode = __webpack_require__(241);
	var getEventKey = __webpack_require__(242);
	var getEventModifierState = __webpack_require__(158);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function charCode(event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function keyCode(event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function which(event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 241 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(241);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(155);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(156);
	
	var getEventModifierState = __webpack_require__(158);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(134);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
	
	module.exports = SyntheticTransitionEvent;

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(155);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function deltaX(event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function deltaY(event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var DOMLazyTree = __webpack_require__(162);
	var DOMProperty = __webpack_require__(117);
	var React = __webpack_require__(84);
	var ReactBrowserEventEmitter = __webpack_require__(186);
	var ReactCurrentOwner = __webpack_require__(91);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactDOMContainerInfo = __webpack_require__(248);
	var ReactDOMFeatureFlags = __webpack_require__(249);
	var ReactFeatureFlags = __webpack_require__(139);
	var ReactInstanceMap = __webpack_require__(197);
	var ReactInstrumentation = __webpack_require__(143);
	var ReactMarkupChecksum = __webpack_require__(250);
	var ReactReconciler = __webpack_require__(140);
	var ReactUpdateQueue = __webpack_require__(216);
	var ReactUpdates = __webpack_require__(137);
	
	var emptyObject = __webpack_require__(101);
	var instantiateReactComponent = __webpack_require__(199);
	var invariant = __webpack_require__(89);
	var setInnerHTML = __webpack_require__(164);
	var shouldUpdateReactComponent = __webpack_require__(205);
	var warning = __webpack_require__(92);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var instancesByReactRootID = {};
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props.child;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }
	
	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );
	
	  if (markerName) {
	    console.timeEnd(markerName);
	  }
	
	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}
	
	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}
	
	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}
	
	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}
	
	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}
	
	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function TopLevelWrapper() {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  return this.props.child;
	};
	TopLevelWrapper.isReactTopLevelWrapper = true;
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function scrollMonitor(container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    return prevComponent;
	  },
	
	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
	
	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	
	    var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });
	
	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props.child;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function render(nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function unmountComponentAtNode(container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }
	
	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },
	
	  _mountImageIntoNode: function _mountImageIntoNode(markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: hostNode._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  }
	};
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var validateDOMNesting = __webpack_require__(217);
	
	var DOC_NODE_TYPE = 9;
	
	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}
	
	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 249 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: true,
	  useFiber: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(251);
	
	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function addChecksumToMarkup(markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function canReuseMarkup(markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 251 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 252 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	module.exports = '15.4.2';

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(116);
	
	var ReactCurrentOwner = __webpack_require__(91);
	var ReactDOMComponentTree = __webpack_require__(115);
	var ReactInstanceMap = __webpack_require__(197);
	
	var getHostComponentFromComposite = __webpack_require__(254);
	var invariant = __webpack_require__(89);
	var warning = __webpack_require__(92);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	
	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }
	
	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactNodeTypes = __webpack_require__(201);
	
	function getHostComponentFromComposite(inst) {
	  var type;
	
	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }
	
	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}
	
	module.exports = getHostComponentFromComposite;

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(247);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(117);
	var EventPluginRegistry = __webpack_require__(124);
	var ReactComponentTreeHook = __webpack_require__(107);
	
	var warning = __webpack_require__(92);
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,
	
	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};
	
	  var validateProperty = function validateProperty(tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
	
	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}
	
	var warnUnknownProperties = function warnUnknownProperties(debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }
	
	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}
	
	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(107);
	
	var warning = __webpack_require__(92);
	
	var didWarnValueNull = false;
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	
	    didWarnValueNull = true;
	  }
	}
	
	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(117);
	var ReactComponentTreeHook = __webpack_require__(107);
	
	var warning = __webpack_require__(92);
	
	var warnedProperties = {};
	var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	
	function validateProperty(tagName, name, debugID) {
	  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	    return true;
	  }
	
	  if (rARIA.test(name)) {
	    var lowerCasedName = name.toLowerCase();
	    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // If this is an aria-* attribute, but is not listed in the known DOM
	    // DOM properties, then it is an invalid aria-* attribute.
	    if (standardName == null) {
	      warnedProperties[name] = true;
	      return false;
	    }
	    // aria-* attributes should be lowercase; suggest the lowercase version.
	    if (name !== standardName) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      warnedProperties[name] = true;
	      return true;
	    }
	  }
	
	  return true;
	}
	
	function warnInvalidARIAProps(debugID, element) {
	  var invalidProps = [];
	
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      invalidProps.push(key);
	    }
	  }
	
	  var unknownPropString = invalidProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (invalidProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (invalidProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	
	  warnInvalidARIAProps(debugID, element);
	}
	
	var ReactDOMInvalidARIAHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  }
	};
	
	module.exports = ReactDOMInvalidARIAHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQ/ODJlOCIsIndlYnBhY2s6Ly8vLi9+L3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91cmwvfi9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3VybC91dGlsLmpzIiwid2VicGFjazovLy8uL34vcXVlcnlzdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHJpcC1hbnNpL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYW5zaS1yZWdleC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3NvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL2VudHJ5LmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0LWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvd2Vic29ja2V0LmpzIiwid2VicGFjazovLy8uL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL2Jyb3dzZXItY3J5cHRvLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdXRpbHMvdXJsLmpzIiwid2VicGFjazovLy8uL34vdXJsLXBhcnNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVxdWlyZXMtcG9ydC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3VybC1wYXJzZS9sb2xjYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGVidWcvc3JjL2RlYnVnLmpzIiwid2VicGFjazovLy8uL34vbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvZXZlbnQvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL2V2ZW50L2V2ZW50dGFyZ2V0LmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2Jyb3dzZXIvd2Vic29ja2V0LmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3hoci1zdHJlYW1pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvbGliL2FqYXgtYmFzZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvbGliL3NlbmRlci1yZWNlaXZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9saWIvYnVmZmVyZWQtc2VuZGVyLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2xpYi9wb2xsaW5nLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3JlY2VpdmVyL3hoci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvYnJvd3Nlci9hYnN0cmFjdC14aHIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQveGRyLXN0cmVhbWluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9zZW5kZXIveGRyLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2V2ZW50c291cmNlLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3JlY2VpdmVyL2V2ZW50c291cmNlLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2Jyb3dzZXIvZXZlbnRzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2lmcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2pzb24zL2xpYi9qc29uMy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy9pZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvaHRtbGZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvcmVjZWl2ZXIvaHRtbGZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQveGhyLXBvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQveGRyLXBvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvanNvbnAtcG9sbGluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9yZWNlaXZlci9qc29ucC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9zZW5kZXIvanNvbnAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi9tYWluLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvc2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy90cmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi9ldmVudC9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL2xvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvZXZlbnQvY2xvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi9ldmVudC90cmFucy1tZXNzYWdlLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvaW5mby1yZWNlaXZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi9pbmZvLWlmcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL2luZm8taWZyYW1lLXJlY2VpdmVyLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvaW5mby1hamF4LmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvaWZyYW1lLWJvb3RzdHJhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL2ZhY2FkZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9vbmx5LWRldi1zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3QvbG9nLWFwcGx5LXJlc3VsdC5qcyIsIndlYnBhY2s6Ly8vLi9lbnRyeS5qcyIsIndlYnBhY2s6Ly8vLi9sZXNzL3Rlc3QubGVzcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L3JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0LmpzIiwid2VicGFjazovLy8uL34vb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0tleUVzY2FwZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQdXJlQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50VmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY2hlY2tSZWFjdFR5cGVTcGVjLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9vbmx5Q2hpbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvRE9NUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvQVJJQURPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpbkh1Yi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RFcnJvclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9hY2N1bXVsYXRlSW50by5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUG9vbGVkQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9DYWxsYmFja1F1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEZlYXR1cmVGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFJlZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RPd25lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnN0cnVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RGVidWdUb29sLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvaXNUZXh0SW5wdXRFbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9WaWV3cG9ydE1ldHJpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9ET01MYXp5VHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvRE9NTmFtZXNwYWNlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvc2V0SW5uZXJIVE1MLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9zZXRUZXh0Q29udGVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9EYW5nZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvQXV0b0ZvY3VzVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaHlwaGVuYXRlLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0xpbmtlZFZhbHVlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01TZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0TXVsdGlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnN0YW5jZU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdE5vZGVUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvY2hlY2tSZWFjdFR5cGVTcGVjLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0SG9zdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZ2V0TmV4dERlYnVnSUQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0tleUVzY2FwZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2dldEl0ZXJhdG9yRm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2ZsYXR0ZW5DaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUVtcHR5Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaXNOb2RlLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TaW1wbGVFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljQW5pbWF0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9nZXRFdmVudEtleS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0TW91bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29udGFpbmVySW5mby5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2FkbGVyMzIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0VmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZmluZERPTU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW52YWxpZEFSSUFIb29rLmpzIl0sIm5hbWVzIjpbInB1bnljb2RlIiwicmVxdWlyZSIsInV0aWwiLCJleHBvcnRzIiwicGFyc2UiLCJ1cmxQYXJzZSIsInJlc29sdmUiLCJ1cmxSZXNvbHZlIiwicmVzb2x2ZU9iamVjdCIsInVybFJlc29sdmVPYmplY3QiLCJmb3JtYXQiLCJ1cmxGb3JtYXQiLCJVcmwiLCJwcm90b2NvbCIsInNsYXNoZXMiLCJhdXRoIiwiaG9zdCIsInBvcnQiLCJob3N0bmFtZSIsImhhc2giLCJzZWFyY2giLCJxdWVyeSIsInBhdGhuYW1lIiwicGF0aCIsImhyZWYiLCJwcm90b2NvbFBhdHRlcm4iLCJwb3J0UGF0dGVybiIsInNpbXBsZVBhdGhQYXR0ZXJuIiwiZGVsaW1zIiwidW53aXNlIiwiY29uY2F0IiwiYXV0b0VzY2FwZSIsIm5vbkhvc3RDaGFycyIsImhvc3RFbmRpbmdDaGFycyIsImhvc3RuYW1lTWF4TGVuIiwiaG9zdG5hbWVQYXJ0UGF0dGVybiIsImhvc3RuYW1lUGFydFN0YXJ0IiwidW5zYWZlUHJvdG9jb2wiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwicXVlcnlzdHJpbmciLCJ1cmwiLCJwYXJzZVF1ZXJ5U3RyaW5nIiwic2xhc2hlc0Rlbm90ZUhvc3QiLCJpc09iamVjdCIsInUiLCJwcm90b3R5cGUiLCJpc1N0cmluZyIsIlR5cGVFcnJvciIsInF1ZXJ5SW5kZXgiLCJpbmRleE9mIiwic3BsaXR0ZXIiLCJ1U3BsaXQiLCJzcGxpdCIsInNsYXNoUmVnZXgiLCJyZXBsYWNlIiwiam9pbiIsInJlc3QiLCJ0cmltIiwibGVuZ3RoIiwic2ltcGxlUGF0aCIsImV4ZWMiLCJzdWJzdHIiLCJwcm90byIsImxvd2VyUHJvdG8iLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoIiwiaG9zdEVuZCIsImkiLCJoZWMiLCJhdFNpZ24iLCJsYXN0SW5kZXhPZiIsInNsaWNlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwibCIsInBhcnQiLCJuZXdwYXJ0IiwiaiIsImsiLCJjaGFyQ29kZUF0IiwidmFsaWRQYXJ0cyIsIm5vdEhvc3QiLCJiaXQiLCJwdXNoIiwidW5zaGlmdCIsInRvQVNDSUkiLCJwIiwiaCIsImFlIiwiZXNjIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwicW0iLCJzIiwib2JqIiwiY2FsbCIsIk9iamVjdCIsImtleXMiLCJzdHJpbmdpZnkiLCJjaGFyQXQiLCJzb3VyY2UiLCJyZWxhdGl2ZSIsInJlbCIsInJlc3VsdCIsInRrZXlzIiwidGsiLCJ0a2V5IiwicmtleXMiLCJyayIsInJrZXkiLCJ2IiwicmVsUGF0aCIsInNoaWZ0IiwiaXNTb3VyY2VBYnMiLCJpc1JlbEFicyIsIm11c3RFbmRBYnMiLCJyZW1vdmVBbGxEb3RzIiwic3JjUGF0aCIsInBzeWNob3RpYyIsInBvcCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiYXV0aEluSG9zdCIsImlzTnVsbCIsImxhc3QiLCJoYXNUcmFpbGluZ1NsYXNoIiwidXAiLCJzcGxpY2UiLCJpc0Fic29sdXRlIiwicm9vdCIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlIiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsIndpbmRvdyIsInNlbGYiLCJtYXhJbnQiLCJiYXNlIiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJkZWxpbWl0ZXIiLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImVycm9ycyIsImJhc2VNaW51c1RNaW4iLCJmbG9vciIsIk1hdGgiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJrZXkiLCJlcnJvciIsInR5cGUiLCJSYW5nZUVycm9yIiwibWFwIiwiYXJyYXkiLCJmbiIsIm1hcERvbWFpbiIsInN0cmluZyIsInBhcnRzIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJvdXRwdXQiLCJjb3VudGVyIiwidmFsdWUiLCJleHRyYSIsInVjczJlbmNvZGUiLCJiYXNpY1RvRGlnaXQiLCJjb2RlUG9pbnQiLCJkaWdpdFRvQmFzaWMiLCJkaWdpdCIsImZsYWciLCJhZGFwdCIsImRlbHRhIiwibnVtUG9pbnRzIiwiZmlyc3RUaW1lIiwiZGVjb2RlIiwiaW5wdXQiLCJpbnB1dExlbmd0aCIsIm91dCIsIm4iLCJiaWFzIiwiYmFzaWMiLCJpbmRleCIsIm9sZGkiLCJ3IiwidCIsImJhc2VNaW51c1QiLCJlbmNvZGUiLCJoYW5kbGVkQ1BDb3VudCIsImJhc2ljTGVuZ3RoIiwibSIsInEiLCJjdXJyZW50VmFsdWUiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJxTWludXNUIiwidG9Vbmljb2RlIiwidGVzdCIsImRlZmluZSIsImhhc093blByb3BlcnR5Iiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwicGF0aHMiLCJjaGlsZHJlbiIsImFyZyIsInByb3AiLCJxcyIsInNlcCIsImVxIiwib3B0aW9ucyIsInJlZ2V4cCIsIm1heEtleXMiLCJsZW4iLCJ4IiwiaWR4Iiwia3N0ciIsInZzdHIiLCJBcnJheSIsImlzQXJyYXkiLCJzdHJpbmdpZnlQcmltaXRpdmUiLCJpc0Zpbml0ZSIsIm5hbWUiLCJ1bmRlZmluZWQiLCJrcyIsImFuc2lSZWdleCIsInN0ciIsIlNvY2tKUyIsInJldHJpZXMiLCJzb2NrIiwic29ja2V0IiwiaGFuZGxlcnMiLCJvbm9wZW4iLCJvbmNsb3NlIiwiY2xvc2UiLCJyZXRyeUluTXMiLCJwb3ciLCJyYW5kb20iLCJzZXRUaW1lb3V0Iiwib25tZXNzYWdlIiwiZSIsIm1zZyIsIkpTT04iLCJkYXRhIiwidHJhbnNwb3J0TGlzdCIsIl9zb2NranNfb25sb2FkIiwidXRpbHMiLCJ1cmxVdGlscyIsImluaGVyaXRzIiwiRXZlbnRFbWl0dGVyIiwiV2Vic29ja2V0RHJpdmVyIiwiZGVidWciLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJXZWJTb2NrZXRUcmFuc3BvcnQiLCJ0cmFuc1VybCIsImlnbm9yZSIsImVuYWJsZWQiLCJFcnJvciIsImFkZFBhdGgiLCJ3cyIsImVtaXQiLCJ1bmxvYWRSZWYiLCJ1bmxvYWRBZGQiLCJjb2RlIiwicmVhc29uIiwiX2NsZWFudXAiLCJvbmVycm9yIiwic2VuZCIsInVubG9hZERlbCIsInJlbW92ZUFsbExpc3RlbmVycyIsInRyYW5zcG9ydE5hbWUiLCJyb3VuZFRyaXBzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJhcmd1bWVudHMiLCJJdGVtIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsIm9uVW5sb2FkIiwiYWZ0ZXJVbmxvYWQiLCJpc0Nocm9tZVBhY2thZ2VkQXBwIiwiY2hyb21lIiwiYXBwIiwicnVudGltZSIsImF0dGFjaEV2ZW50IiwiZXZlbnQiLCJsaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJkb2N1bWVudCIsImRldGFjaEV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlZiIsInRyaWdnZXJVbmxvYWRDYWxsYmFja3MiLCJ1bmxvYWRUcmlnZ2VyZWQiLCJjcnlwdG8iLCJfcmFuZG9tU3RyaW5nQ2hhcnMiLCJtYXgiLCJieXRlcyIsInJhbmRvbUJ5dGVzIiwicmV0IiwibnVtYmVyIiwibnVtYmVyU3RyaW5nIiwiZ2V0UmFuZG9tVmFsdWVzIiwiVWludDhBcnJheSIsIlVSTCIsImdldE9yaWdpbiIsImlzT3JpZ2luRXF1YWwiLCJhIiwiYiIsInJlcyIsImlzU2NoZW1lRXF1YWwiLCJhZGRRdWVyeSIsInJlcXVpcmVkIiwibG9sY2F0aW9uIiwicHJvdG9jb2xyZSIsInJ1bGVzIiwiTmFOIiwiZXh0cmFjdFByb3RvY29sIiwiYWRkcmVzcyIsImxvY2F0aW9uIiwicGFyc2VyIiwiZXh0cmFjdGVkIiwiaW5zdHJ1Y3Rpb24iLCJpbnN0cnVjdGlvbnMiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwib3JpZ2luIiwidG9TdHJpbmciLCJzZXQiLCJpbnMiLCJsb2MiLCJmaW5hbGRlc3RpbmF0aW9uIiwidW5lc2NhcGUiLCJoYXMiLCJxdWVyeXN0cmluZ2lmeSIsInByZWZpeCIsInBhaXJzIiwibG9nIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwic3RvcmFnZSIsImxvY2FsIiwibG9jYWxzdG9yYWdlIiwiY29sb3JzIiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJjb25zb2xlIiwiZmlyZWJ1ZyIsImV4Y2VwdGlvbiIsInRhYmxlIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwicGFyc2VJbnQiLCJSZWdFeHAiLCIkMSIsImZvcm1hdHRlcnMiLCJlcnIiLCJtZXNzYWdlIiwibmFtZXNwYWNlIiwiaHVtYW5pemUiLCJkaWZmIiwiYyIsImNvbG9yIiwibGFzdEMiLCJGdW5jdGlvbiIsIm5hbWVzcGFjZXMiLCJyZW1vdmVJdGVtIiwiREVCVUciLCJlbmFibGUiLCJsb2NhbFN0b3JhZ2UiLCJjcmVhdGVEZWJ1ZyIsImRlZmF1bHQiLCJjb2VyY2UiLCJkaXNhYmxlIiwibmFtZXMiLCJza2lwcyIsInByZXZUaW1lIiwic2VsZWN0Q29sb3IiLCJhYnMiLCJjdXJyIiwiRGF0ZSIsIm1zIiwicHJldiIsImZvcm1hdHRlciIsInZhbCIsImxvZ0ZuIiwiYmluZCIsImluaXQiLCJzdGFjayIsImQiLCJ5IiwiaXNOYU4iLCJsb25nIiwiZm10TG9uZyIsImZtdFNob3J0IiwicGFyc2VGbG9hdCIsInJvdW5kIiwicGx1cmFsIiwiY2VpbCIsImNyZWF0ZSIsImN0b3IiLCJzdXBlckN0b3IiLCJzdXBlcl8iLCJjb25zdHJ1Y3RvciIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsIlRlbXBDdG9yIiwiRXZlbnRUYXJnZXQiLCJfbGlzdGVuZXJzIiwiZmlyZWQiLCJnIiwibGlzdGVuZXJzIiwiYWkiLCJldmVudFR5cGUiLCJhcnIiLCJkaXNwYXRjaEV2ZW50IiwiRHJpdmVyIiwiV2ViU29ja2V0IiwiTW96V2ViU29ja2V0IiwiV2ViU29ja2V0QnJvd3NlckRyaXZlciIsIkFqYXhCYXNlZFRyYW5zcG9ydCIsIlhoclJlY2VpdmVyIiwiWEhSQ29yc09iamVjdCIsIlhIUkxvY2FsT2JqZWN0IiwiWGhyU3RyZWFtaW5nVHJhbnNwb3J0IiwiaW5mbyIsIm51bGxPcmlnaW4iLCJpc09wZXJhIiwibmVlZEJvZHkiLCJTZW5kZXJSZWNlaXZlciIsImNyZWF0ZUFqYXhTZW5kZXIiLCJBamF4T2JqZWN0IiwicGF5bG9hZCIsImNhbGxiYWNrIiwib3B0IiwiaGVhZGVycyIsImFqYXhVcmwiLCJ4byIsInN0YXR1cyIsInVybFN1ZmZpeCIsIlJlY2VpdmVyIiwiQnVmZmVyZWRTZW5kZXIiLCJQb2xsaW5nIiwic2VuZGVyRnVuYyIsInBvbGxVcmwiLCJwb2xsIiwiYWJvcnQiLCJzZW5kZXIiLCJzZW5kQnVmZmVyIiwic2VuZFN0b3AiLCJzZW5kU2NoZWR1bGUiLCJzZW5kU2NoZWR1bGVXYWl0IiwidHJlZiIsInJlY2VpdmVVcmwiLCJfc2NoZWR1bGVSZWNlaXZlciIsInBvbGxJc0Nsb3NpbmciLCJidWZmZXJQb3NpdGlvbiIsIl9jaHVua0hhbmRsZXIiLCJ0ZXh0IiwiYnVmIiwiWGhyRHJpdmVyIiwibWV0aG9kIiwib3B0cyIsInN1cHBvcnRzQ09SUyIsIlhIUiIsIlhNTEh0dHBSZXF1ZXN0IiwiQWJzdHJhY3RYSFJPYmplY3QiLCJfc3RhcnQiLCJ4aHIiLCJvcGVuIiwib250aW1lb3V0Iiwibm9DcmVkZW50aWFscyIsIndpdGhDcmVkZW50aWFscyIsInNldFJlcXVlc3RIZWFkZXIiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VUZXh0IiwiYXhvIiwiY29ycyIsImlnbm9yZWQiLCJpc0tvbnF1ZXJvciIsImhhc0RvbWFpbiIsImRvbWFpbiIsIlhEUk9iamVjdCIsIlhkclN0cmVhbWluZ1RyYW5zcG9ydCIsImNvb2tpZV9uZWVkZWQiLCJzYW1lU2NoZW1lIiwiZXZlbnRVdGlscyIsInhkciIsIlhEb21haW5SZXF1ZXN0IiwiX2Vycm9yIiwib25wcm9ncmVzcyIsIm9ubG9hZCIsIkV2ZW50U291cmNlUmVjZWl2ZXIiLCJFdmVudFNvdXJjZURyaXZlciIsIkV2ZW50U291cmNlVHJhbnNwb3J0IiwiZXMiLCJkZWNvZGVVUkkiLCJfY2xvc2UiLCJFdmVudFNvdXJjZSIsIklmcmFtZVRyYW5zcG9ydCIsIm9iamVjdFV0aWxzIiwidHJhbnNwb3J0IiwiSWZyYW1lV3JhcFRyYW5zcG9ydCIsImJhc2VVcmwiLCJpZnJhbWVJbmZvIiwiZXh0ZW5kIiwic2FtZU9yaWdpbiIsImZhY2FkZVRyYW5zcG9ydCIsIkpTT04zIiwiaWZyYW1lVXRpbHMiLCJ3aW5kb3dJZCIsImlmcmFtZVVybCIsImlmcmFtZU9iaiIsImNyZWF0ZUlmcmFtZSIsInIiLCJvbm1lc3NhZ2VDYWxsYmFjayIsIl9tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJjbGVhbnVwIiwiaWZyYW1lTWVzc2FnZSIsImxvYWRlZCIsImNkYXRhIiwicG9zdCIsImlmcmFtZUVuYWJsZWQiLCJpc0xvYWRlciIsIm9iamVjdFR5cGVzIiwicnVuSW5Db250ZXh0IiwiY29udGV4dCIsIk51bWJlciIsIlN5bnRheEVycm9yIiwibmF0aXZlSlNPTiIsIm9iamVjdFByb3RvIiwiZ2V0Q2xhc3MiLCJpc1Byb3BlcnR5IiwiZm9yRWFjaCIsInVuZGVmIiwiaXNFeHRlbmRlZCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ01pbGxpc2Vjb25kcyIsImlzU3VwcG9ydGVkIiwic2VyaWFsaXplZCIsInN0cmluZ2lmeVN1cHBvcnRlZCIsInRvSlNPTiIsInBhcnNlU3VwcG9ydGVkIiwiZnVuY3Rpb25DbGFzcyIsImRhdGVDbGFzcyIsIm51bWJlckNsYXNzIiwic3RyaW5nQ2xhc3MiLCJhcnJheUNsYXNzIiwiYm9vbGVhbkNsYXNzIiwiY2hhckluZGV4QnVnZ3kiLCJNb250aHMiLCJnZXREYXkiLCJ5ZWFyIiwibW9udGgiLCJwcm9wZXJ0eSIsIm1lbWJlcnMiLCJfX3Byb3RvX18iLCJvcmlnaW5hbCIsInBhcmVudCIsIm9iamVjdCIsInNpemUiLCJQcm9wZXJ0aWVzIiwidmFsdWVPZiIsImlzRnVuY3Rpb24iLCJoYXNQcm9wZXJ0eSIsImlzQ29uc3RydWN0b3IiLCJFc2NhcGVzIiwibGVhZGluZ1plcm9lcyIsInRvUGFkZGVkU3RyaW5nIiwid2lkdGgiLCJ1bmljb2RlUHJlZml4IiwicXVvdGUiLCJ1c2VDaGFySW5kZXgiLCJzeW1ib2xzIiwiY2hhckNvZGUiLCJzZXJpYWxpemUiLCJwcm9wZXJ0aWVzIiwid2hpdGVzcGFjZSIsImluZGVudGF0aW9uIiwiY2xhc3NOYW1lIiwiZGF0ZSIsInRpbWUiLCJob3VycyIsIm1pbnV0ZXMiLCJzZWNvbmRzIiwibWlsbGlzZWNvbmRzIiwicmVzdWx0cyIsImVsZW1lbnQiLCJmaWx0ZXIiLCJVbmVzY2FwZXMiLCJJbmRleCIsIlNvdXJjZSIsImxleCIsImJlZ2luIiwicG9zaXRpb24iLCJpc1NpZ25lZCIsImdldCIsImhhc01lbWJlcnMiLCJ1cGRhdGUiLCJ3YWxrIiwicHJldmlvdXNKU09OIiwiaXNSZXN0b3JlZCIsIldQcmVmaXgiLCJjdXJyZW50V2luZG93SWQiLCJwb2xsdXRlR2xvYmFsTmFtZXNwYWNlIiwiZXJyb3JDYWxsYmFjayIsImlmcmFtZSIsImNyZWF0ZUVsZW1lbnQiLCJ1bmF0dGFjaCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNvbnRlbnRXaW5kb3ciLCJzcmMiLCJkaXNwbGF5IiwiYm9keSIsImFwcGVuZENoaWxkIiwiY3JlYXRlSHRtbGZpbGUiLCJkb2MiLCJDb2xsZWN0R2FyYmFnZSIsIndyaXRlIiwicGFyZW50V2luZG93IiwiSHRtbGZpbGVSZWNlaXZlciIsIkh0bWxGaWxlVHJhbnNwb3J0IiwiaWQiLCJodG1sZmlsZUVuYWJsZWQiLCJjb25zdHJ1Y3RGdW5jIiwic3RhcnQiLCJzdG9wIiwiWGhyUG9sbGluZ1RyYW5zcG9ydCIsIlhkclBvbGxpbmdUcmFuc3BvcnQiLCJKc29ucFJlY2VpdmVyIiwianNvbnBTZW5kZXIiLCJKc29uUFRyYW5zcG9ydCIsInVybFdpdGhJZCIsIl9jYWxsYmFjayIsIl9jcmVhdGVTY3JpcHQiLCJ0aW1lb3V0SWQiLCJfYWJvcnQiLCJzY3JpcHRFcnJvclRpbWVvdXQiLCJhYm9ydGluZyIsInNjcmlwdDIiLCJzY3JpcHQiLCJvbmNsaWNrIiwiX3NjcmlwdEVycm9yIiwiZXJyb3JUaW1lciIsImxvYWRlZE9rYXkiLCJjaGFyc2V0IiwiaHRtbEZvciIsImFzeW5jIiwiaGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RDaGlsZCIsImZvcm0iLCJhcmVhIiwiY3JlYXRlRm9ybSIsImVuY3R5cGUiLCJhY2NlcHRDaGFyc2V0IiwidGFyZ2V0IiwiYWN0aW9uIiwic3VibWl0IiwiY29tcGxldGVkIiwiRXZlbnQiLCJDbG9zZUV2ZW50IiwiVHJhbnNwb3J0TWVzc2FnZUV2ZW50IiwiSW5mb1JlY2VpdmVyIiwidHJhbnNwb3J0cyIsInByb3RvY29scyIsIkNPTk5FQ1RJTkciLCJleHRlbnNpb25zIiwicHJvdG9jb2xzX3doaXRlbGlzdCIsIndhcm4iLCJfdHJhbnNwb3J0c1doaXRlbGlzdCIsIl90cmFuc3BvcnRPcHRpb25zIiwidHJhbnNwb3J0T3B0aW9ucyIsInNlc3Npb25JZCIsIl9nZW5lcmF0ZVNlc3Npb25JZCIsIl9zZXJ2ZXIiLCJzZXJ2ZXIiLCJwYXJzZWRVcmwiLCJzZWN1cmUiLCJzb3J0ZWRQcm90b2NvbHMiLCJzb3J0IiwibyIsIl9vcmlnaW4iLCJfdXJsSW5mbyIsIl9pciIsIl9yZWNlaXZlSW5mbyIsInVzZXJTZXRDb2RlIiwiQ0xPU0lORyIsIkNMT1NFRCIsIndhc0NsZWFuIiwiT1BFTiIsIl90cmFuc3BvcnQiLCJydHQiLCJfcnRvIiwiY291bnRSVE8iLCJfdHJhbnNVcmwiLCJiYXNlX3VybCIsImVuYWJsZWRUcmFuc3BvcnRzIiwiZmlsdGVyVG9FbmFibGVkIiwiX3RyYW5zcG9ydHMiLCJtYWluIiwiX2Nvbm5lY3QiLCJUcmFuc3BvcnQiLCJ0aW1lb3V0TXMiLCJfdHJhbnNwb3J0VGltZW91dElkIiwiX3RyYW5zcG9ydFRpbWVvdXQiLCJ0cmFuc3BvcnRVcmwiLCJ0cmFuc3BvcnRPYmoiLCJfdHJhbnNwb3J0TWVzc2FnZSIsIl90cmFuc3BvcnRDbG9zZSIsImNvbnRlbnQiLCJfb3BlbiIsImZvcmNlRmFpbCIsImF2YWlsYWJsZVRyYW5zcG9ydHMiLCJBcnJheVByb3RvdHlwZSIsIk9iamVjdFByb3RvdHlwZSIsIkZ1bmN0aW9uUHJvdG90eXBlIiwiU3RyaW5nUHJvdG90eXBlIiwiYXJyYXlfc2xpY2UiLCJfdG9TdHJpbmciLCJzdXBwb3J0c0Rlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydHkiLCJmb3JjZUFzc2lnbiIsImRlZmluZVByb3BlcnRpZXMiLCJ0b09iamVjdCIsInRvSW50ZWdlciIsIm51bSIsIlRvVWludDMyIiwiRW1wdHkiLCJ0aGF0IiwiYmluZGVyIiwiYm91bmQiLCJib3VuZExlbmd0aCIsImJvdW5kQXJncyIsImJveGVkU3RyaW5nIiwic3BsaXRTdHJpbmciLCJwcm9wZXJseUJveGVzQ29udGV4dCIsInByb3Blcmx5Qm94ZWQiLCJwcm9wZXJseUJveGVzTm9uU3RyaWN0IiwicHJvcGVybHlCb3hlc1N0cmljdCIsIl8iLCJfXyIsInRoaXNwIiwiaGFzRmlyZWZveDJJbmRleE9mQnVnIiwic291Z2h0Iiwic3RyaW5nX3NwbGl0IiwiY29tcGxpYW50RXhlY05wY2ciLCJzZXBhcmF0b3IiLCJsaW1pdCIsImZsYWdzIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsImV4dGVuZGVkIiwic3RpY2t5IiwibGFzdExhc3RJbmRleCIsInNlcGFyYXRvcjIiLCJsYXN0SW5kZXgiLCJsYXN0TGVuZ3RoIiwic3RyaW5nX3N1YnN0ciIsImhhc05lZ2F0aXZlU3Vic3RyQnVnIiwiZXh0cmFFc2NhcGFibGUiLCJleHRyYUxvb2t1cCIsInVucm9sbExvb2t1cCIsImVzY2FwYWJsZSIsInVucm9sbGVkIiwicXVvdGVkIiwidHJhbnNwb3J0c1doaXRlbGlzdCIsImZhY2FkZSIsInRyYW5zIiwid2Vic29ja2V0IiwibG9nT2JqZWN0IiwibGV2ZWwiLCJsZXZlbEV4aXN0cyIsImluaXRFdmVudCIsImNhbkJ1YmJsZSIsImNhbmNlbGFibGUiLCJidWJibGVzIiwidGltZVN0YW1wIiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJDQVBUVVJJTkdfUEhBU0UiLCJBVF9UQVJHRVQiLCJCVUJCTElOR19QSEFTRSIsIlhEUiIsIlhIUkNvcnMiLCJYSFJMb2NhbCIsIlhIUkZha2UiLCJJbmZvSWZyYW1lIiwiSW5mb0FqYXgiLCJ1cmxJbmZvIiwiZG9YaHIiLCJfZ2V0UmVjZWl2ZXIiLCJ0aW1lb3V0UmVmIiwidG8iLCJJbmZvUmVjZWl2ZXJJZnJhbWUiLCJnbyIsImlmciIsImlyIiwidDAiLCJGYWNhZGVKUyIsIkluZm9JZnJhbWVSZWNlaXZlciIsInRyYW5zcG9ydE1hcCIsImF0IiwicGFyZW50T3JpZ2luIiwiYm9vdHN0cmFwX2lmcmFtZSIsIm9uTWVzc2FnZSIsIl9zZW5kIiwiZnJhbWUiLCJsYXN0RGF0YSIsInVwVG9EYXRlIiwiY2hlY2siLCJob3QiLCJ1cGRhdGVkTW9kdWxlcyIsImZhaWwiLCJpZ25vcmVVbmFjY2VwdGVkIiwicmVuZXdlZE1vZHVsZXMiLCJldmVudE5hbWUiLCJ1bmFjY2VwdGVkTW9kdWxlcyIsIm1vZHVsZUlkIiwicmVuZGVyIiwiZ2V0RWxlbWVudEJ5SWQiLCJfYXNzaWduIiwiUmVhY3RDaGlsZHJlbiIsIlJlYWN0Q29tcG9uZW50IiwiUmVhY3RQdXJlQ29tcG9uZW50IiwiUmVhY3RDbGFzcyIsIlJlYWN0RE9NRmFjdG9yaWVzIiwiUmVhY3RFbGVtZW50IiwiUmVhY3RQcm9wVHlwZXMiLCJSZWFjdFZlcnNpb24iLCJvbmx5Q2hpbGQiLCJ3YXJuaW5nIiwiY3JlYXRlRmFjdG9yeSIsImNsb25lRWxlbWVudCIsIlJlYWN0RWxlbWVudFZhbGlkYXRvciIsIl9fc3ByZWFkIiwid2FybmVkIiwiUmVhY3QiLCJDaGlsZHJlbiIsImNvdW50IiwidG9BcnJheSIsIm9ubHkiLCJDb21wb25lbnQiLCJQdXJlQ29tcG9uZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJQcm9wVHlwZXMiLCJjcmVhdGVDbGFzcyIsImNyZWF0ZU1peGluIiwibWl4aW4iLCJET00iLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzaG91bGRVc2VOYXRpdmUiLCJhc3NpZ24iLCJ0ZXN0MSIsImdldE93blByb3BlcnR5TmFtZXMiLCJ0ZXN0MiIsIm9yZGVyMiIsInRlc3QzIiwibGV0dGVyIiwiZnJvbSIsIlBvb2xlZENsYXNzIiwiZW1wdHlGdW5jdGlvbiIsInRyYXZlcnNlQWxsQ2hpbGRyZW4iLCJ0d29Bcmd1bWVudFBvb2xlciIsImZvdXJBcmd1bWVudFBvb2xlciIsInVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4IiwiZXNjYXBlVXNlclByb3ZpZGVkS2V5IiwiRm9yRWFjaEJvb2tLZWVwaW5nIiwiZm9yRWFjaEZ1bmN0aW9uIiwiZm9yRWFjaENvbnRleHQiLCJmdW5jIiwiZGVzdHJ1Y3RvciIsImFkZFBvb2xpbmdUbyIsImZvckVhY2hTaW5nbGVDaGlsZCIsImJvb2tLZWVwaW5nIiwiY2hpbGQiLCJmb3JFYWNoQ2hpbGRyZW4iLCJmb3JFYWNoRnVuYyIsInRyYXZlcnNlQ29udGV4dCIsImdldFBvb2xlZCIsInJlbGVhc2UiLCJNYXBCb29rS2VlcGluZyIsIm1hcFJlc3VsdCIsImtleVByZWZpeCIsIm1hcEZ1bmN0aW9uIiwibWFwQ29udGV4dCIsIm1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJjaGlsZEtleSIsIm1hcHBlZENoaWxkIiwibWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCIsInRoYXRSZXR1cm5zQXJndW1lbnQiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJlc2NhcGVkUHJlZml4IiwibWFwQ2hpbGRyZW4iLCJmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSIsImNvdW50Q2hpbGRyZW4iLCJfcHJvZEludmFyaWFudCIsImludmFyaWFudCIsIm9uZUFyZ3VtZW50UG9vbGVyIiwiY29weUZpZWxkc0Zyb20iLCJLbGFzcyIsImluc3RhbmNlUG9vbCIsImluc3RhbmNlIiwiYTEiLCJhMiIsInRocmVlQXJndW1lbnRQb29sZXIiLCJhMyIsImE0Iiwic3RhbmRhcmRSZWxlYXNlciIsInBvb2xTaXplIiwiREVGQVVMVF9QT09MX1NJWkUiLCJERUZBVUxUX1BPT0xFUiIsIkNvcHlDb25zdHJ1Y3RvciIsInBvb2xlciIsIk5ld0tsYXNzIiwicmVhY3RQcm9kSW52YXJpYW50IiwiYXJnQ291bnQiLCJhcmdJZHgiLCJmcmFtZXNUb1BvcCIsInZhbGlkYXRlRm9ybWF0IiwiY29uZGl0aW9uIiwiZiIsImFyZ0luZGV4IiwiUmVhY3RDdXJyZW50T3duZXIiLCJjYW5EZWZpbmVQcm9wZXJ0eSIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFU0VSVkVEX1BST1BTIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5IiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJwcm9wcyIsImRpc3BsYXlOYW1lIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJvd25lciIsIiQkdHlwZW9mIiwiX293bmVyIiwiX3N0b3JlIiwidmFsaWRhdGVkIiwiX3NlbGYiLCJfc291cmNlIiwiZnJlZXplIiwicHJvcE5hbWUiLCJjaGlsZHJlbkxlbmd0aCIsImNoaWxkQXJyYXkiLCJkZWZhdWx0UHJvcHMiLCJjdXJyZW50IiwiZmFjdG9yeSIsIm9sZEVsZW1lbnQiLCJuZXdLZXkiLCJuZXdFbGVtZW50IiwicHJpbnRXYXJuaW5nIiwiX2xlbiIsIl9rZXkiLCJfbGVuMiIsIl9rZXkyIiwibWFrZUVtcHR5RnVuY3Rpb24iLCJ0aGF0UmV0dXJucyIsInRoYXRSZXR1cm5zRmFsc2UiLCJ0aGF0UmV0dXJuc1RydWUiLCJ0aGF0UmV0dXJuc051bGwiLCJ0aGF0UmV0dXJuc1RoaXMiLCJTeW1ib2wiLCJnZXRJdGVyYXRvckZuIiwiS2V5RXNjYXBlVXRpbHMiLCJTRVBBUkFUT1IiLCJTVUJTRVBBUkFUT1IiLCJkaWRXYXJuQWJvdXRNYXBzIiwiZ2V0Q29tcG9uZW50S2V5IiwiY29tcG9uZW50IiwidHJhdmVyc2VBbGxDaGlsZHJlbkltcGwiLCJuYW1lU29GYXIiLCJuZXh0TmFtZSIsInN1YnRyZWVDb3VudCIsIm5leHROYW1lUHJlZml4IiwiaXRlcmF0b3JGbiIsIml0ZXJhdG9yIiwic3RlcCIsImVudHJpZXMiLCJpaSIsIm5leHQiLCJkb25lIiwibWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSIsIm1hcHNBc0NoaWxkcmVuT3duZXJOYW1lIiwiZ2V0TmFtZSIsImVudHJ5IiwiYWRkZW5kdW0iLCJfaXNSZWFjdEVsZW1lbnQiLCJjaGlsZHJlblN0cmluZyIsIklURVJBVE9SX1NZTUJPTCIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwibWF5YmVJdGVyYWJsZSIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJ1bmVzY2FwZVJlZ2V4IiwidW5lc2NhcGVyTG9va3VwIiwia2V5U3Vic3RyaW5nIiwic3Vic3RyaW5nIiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJlbXB0eU9iamVjdCIsInVwZGF0ZXIiLCJyZWZzIiwiaXNSZWFjdENvbXBvbmVudCIsInNldFN0YXRlIiwicGFydGlhbFN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwiZW5xdWV1ZUNhbGxiYWNrIiwiZm9yY2VVcGRhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJkZXByZWNhdGVkQVBJcyIsImlzTW91bnRlZCIsInJlcGxhY2VTdGF0ZSIsImRlZmluZURlcHJlY2F0aW9uV2FybmluZyIsIm1ldGhvZE5hbWUiLCJmbk5hbWUiLCJ3YXJuTm9vcCIsInB1YmxpY0luc3RhbmNlIiwiY2FsbGVyTmFtZSIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJjb21wbGV0ZVN0YXRlIiwiQ29tcG9uZW50RHVtbXkiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIlJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzIiwiTUlYSU5TX0tFWSIsImlkZW50aXR5IiwiaW5qZWN0ZWRNaXhpbnMiLCJSZWFjdENsYXNzSW50ZXJmYWNlIiwibWl4aW5zIiwic3RhdGljcyIsInByb3BUeXBlcyIsImNvbnRleHRUeXBlcyIsImNoaWxkQ29udGV4dFR5cGVzIiwiZ2V0RGVmYXVsdFByb3BzIiwiZ2V0SW5pdGlhbFN0YXRlIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwidXBkYXRlQ29tcG9uZW50IiwiUkVTRVJWRURfU1BFQ19LRVlTIiwiQ29uc3RydWN0b3IiLCJtaXhTcGVjSW50b0NvbXBvbmVudCIsInZhbGlkYXRlVHlwZURlZiIsImNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uIiwibWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQiLCJhdXRvYmluZCIsInR5cGVEZWYiLCJ2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlIiwiaXNBbHJlYWR5RGVmaW5lZCIsInNwZWNQb2xpY3kiLCJSZWFjdENsYXNzTWl4aW4iLCJzcGVjIiwidHlwZW9mU3BlYyIsImlzTWl4aW5WYWxpZCIsImF1dG9CaW5kUGFpcnMiLCJfX3JlYWN0QXV0b0JpbmRQYWlycyIsImlzUmVhY3RDbGFzc01ldGhvZCIsInNob3VsZEF1dG9CaW5kIiwiY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uIiwiaXNSZXNlcnZlZCIsImlzSW5oZXJpdGVkIiwibWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyIsIm9uZSIsInR3byIsIm1lcmdlZFJlc3VsdCIsImNoYWluZWRGdW5jdGlvbiIsImJpbmRBdXRvQmluZE1ldGhvZCIsImJvdW5kTWV0aG9kIiwiX19yZWFjdEJvdW5kQ29udGV4dCIsIl9fcmVhY3RCb3VuZE1ldGhvZCIsIl9fcmVhY3RCb3VuZEFyZ3VtZW50cyIsImNvbXBvbmVudE5hbWUiLCJfYmluZCIsIm5ld1RoaXMiLCJyZWJvdW5kTWV0aG9kIiwiYmluZEF1dG9CaW5kTWV0aG9kcyIsImF1dG9CaW5kS2V5IiwibmV3U3RhdGUiLCJSZWFjdENsYXNzQ29tcG9uZW50Iiwic3RhdGUiLCJpbml0aWFsU3RhdGUiLCJfaXNNb2NrRnVuY3Rpb24iLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJpbmplY3Rpb24iLCJpbmplY3RNaXhpbiIsImNoaWxkQ29udGV4dCIsImNyZWF0ZURPTUZhY3RvcnkiLCJhYmJyIiwiYXJ0aWNsZSIsImFzaWRlIiwiYXVkaW8iLCJiZGkiLCJiZG8iLCJiaWciLCJibG9ja3F1b3RlIiwiYnIiLCJidXR0b24iLCJjYW52YXMiLCJjYXB0aW9uIiwiY2l0ZSIsImNvbCIsImNvbGdyb3VwIiwiZGF0YWxpc3QiLCJkZCIsImRlbCIsImRldGFpbHMiLCJkZm4iLCJkaWFsb2ciLCJkaXYiLCJkbCIsImR0IiwiZW0iLCJlbWJlZCIsImZpZWxkc2V0IiwiZmlnY2FwdGlvbiIsImZpZ3VyZSIsImZvb3RlciIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImhlYWRlciIsImhncm91cCIsImhyIiwiaHRtbCIsImltZyIsImtiZCIsImtleWdlbiIsImxhYmVsIiwibGVnZW5kIiwibGkiLCJsaW5rIiwibWFyayIsIm1lbnUiLCJtZW51aXRlbSIsIm1ldGEiLCJtZXRlciIsIm5hdiIsIm5vc2NyaXB0Iiwib2wiLCJvcHRncm91cCIsIm9wdGlvbiIsInBhcmFtIiwicGljdHVyZSIsInByZSIsInByb2dyZXNzIiwicnAiLCJydCIsInJ1YnkiLCJzYW1wIiwic2VjdGlvbiIsInNlbGVjdCIsInNtYWxsIiwic3BhbiIsInN0cm9uZyIsInN1YiIsInN1bW1hcnkiLCJzdXAiLCJ0Ym9keSIsInRkIiwidGV4dGFyZWEiLCJ0Zm9vdCIsInRoIiwidGhlYWQiLCJ0ciIsInRyYWNrIiwidWwiLCJ2aWRlbyIsIndiciIsImNpcmNsZSIsImNsaXBQYXRoIiwiZGVmcyIsImVsbGlwc2UiLCJpbWFnZSIsImxpbmUiLCJsaW5lYXJHcmFkaWVudCIsIm1hc2siLCJwYXR0ZXJuIiwicG9seWdvbiIsInBvbHlsaW5lIiwicmFkaWFsR3JhZGllbnQiLCJyZWN0Iiwic3ZnIiwidHNwYW4iLCJSZWFjdENvbXBvbmVudFRyZWVIb29rIiwiY2hlY2tSZWFjdFR5cGVTcGVjIiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudFR5cGUiLCJwYXJlbnROYW1lIiwidmFsaWRhdGVFeHBsaWNpdEtleSIsIm1lbW9pemVyIiwidW5pcXVlS2V5IiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJnZXRDdXJyZW50U3RhY2tBZGRlbmR1bSIsInZhbGlkYXRlQ2hpbGRLZXlzIiwibm9kZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwiY29tcG9uZW50Q2xhc3MiLCJ2YWxpZFR5cGUiLCJ2YWxpZGF0ZWRGYWN0b3J5IiwiaXNOYXRpdmUiLCJmdW5jVG9TdHJpbmciLCJyZUlzTmF0aXZlIiwiY2FuVXNlQ29sbGVjdGlvbnMiLCJNYXAiLCJTZXQiLCJzZXRJdGVtIiwiZ2V0SXRlbSIsImdldEl0ZW1JRHMiLCJhZGRSb290IiwicmVtb3ZlUm9vdCIsImdldFJvb3RJRHMiLCJpdGVtTWFwIiwicm9vdElEU2V0IiwiaXRlbSIsImFkZCIsIml0ZW1CeUtleSIsInJvb3RCeUtleSIsImdldEtleUZyb21JRCIsImdldElERnJvbUtleSIsInVubW91bnRlZElEcyIsInB1cmdlRGVlcCIsImNoaWxkSURzIiwiZGVzY3JpYmVDb21wb25lbnRGcmFtZSIsIm93bmVyTmFtZSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImdldERpc3BsYXlOYW1lIiwiZGVzY3JpYmVJRCIsImdldEVsZW1lbnQiLCJvd25lcklEIiwiZ2V0T3duZXJJRCIsIm9uU2V0Q2hpbGRyZW4iLCJuZXh0Q2hpbGRJRHMiLCJuZXh0Q2hpbGRJRCIsIm5leHRDaGlsZCIsInBhcmVudElEIiwib25CZWZvcmVNb3VudENvbXBvbmVudCIsInVwZGF0ZUNvdW50Iiwib25CZWZvcmVVcGRhdGVDb21wb25lbnQiLCJvbk1vdW50Q29tcG9uZW50IiwiaXNSb290Iiwib25VcGRhdGVDb21wb25lbnQiLCJvblVubW91bnRDb21wb25lbnQiLCJwdXJnZVVubW91bnRlZENvbXBvbmVudHMiLCJfcHJldmVudFB1cmdpbmciLCJ0b3BFbGVtZW50IiwiY3VycmVudE93bmVyIiwiX2RlYnVnSUQiLCJnZXRTdGFja0FkZGVuZHVtQnlJRCIsImdldFBhcmVudElEIiwiZ2V0Q2hpbGRJRHMiLCJnZXRTb3VyY2UiLCJnZXRUZXh0IiwiZ2V0VXBkYXRlQ291bnQiLCJnZXRSZWdpc3RlcmVkSURzIiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJkZWJ1Z0lEIiwidHlwZVNwZWNOYW1lIiwiZXgiLCJjb21wb25lbnRTdGFja0luZm8iLCJBTk9OWU1PVVMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsImJvb2wiLCJzeW1ib2wiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImFycmF5T2YiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJpbnN0YW5jZU9mIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJvbmVPZlR5cGUiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwic2hhcGUiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiaXMiLCJQcm9wVHlwZUVycm9yIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsIm1hbnVhbFByb3BUeXBlQ2FsbENhY2hlIiwiY2hlY2tUeXBlIiwiaXNSZXF1aXJlZCIsInByb3BGdWxsTmFtZSIsInNlY3JldCIsImNhY2hlS2V5IiwibG9jYXRpb25OYW1lIiwiY2hhaW5lZENoZWNrVHlwZSIsImV4cGVjdGVkVHlwZSIsInByb3BWYWx1ZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsImFycmF5T2ZUeXBlQ2hlY2tlcnMiLCJjaGVja2VyIiwiaXNOb2RlIiwic2hhcGVUeXBlcyIsImV2ZXJ5IiwiaXNTeW1ib2wiLCJSZWFjdERPTUNvbXBvbmVudFRyZWUiLCJSZWFjdERlZmF1bHRJbmplY3Rpb24iLCJSZWFjdE1vdW50IiwiUmVhY3RSZWNvbmNpbGVyIiwiUmVhY3RVcGRhdGVzIiwiZmluZERPTU5vZGUiLCJnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSIsInJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwiaW5qZWN0IiwiUmVhY3RET00iLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJiYXRjaGVkVXBkYXRlcyIsInVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiQ29tcG9uZW50VHJlZSIsImdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSIsImluc3QiLCJfcmVuZGVyZWRDb21wb25lbnQiLCJNb3VudCIsIlJlY29uY2lsZXIiLCJFeGVjdXRpb25FbnZpcm9ubWVudCIsImNhblVzZURPTSIsInRvcCIsInNob3dGaWxlVXJsTWVzc2FnZSIsInRlc3RGdW5jIiwidGVzdEZuIiwiaWVDb21wYXRpYmlsaXR5TW9kZSIsImRvY3VtZW50TW9kZSIsImV4cGVjdGVkRmVhdHVyZXMiLCJub3ciLCJSZWFjdEluc3RydW1lbnRhdGlvbiIsIlJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayIsIlJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayIsIlJlYWN0RE9NSW52YWxpZEFSSUFIb29rIiwiZGVidWdUb29sIiwiYWRkSG9vayIsIkRPTVByb3BlcnR5IiwiUmVhY3RET01Db21wb25lbnRGbGFncyIsIkFUVFJfTkFNRSIsIklEX0FUVFJJQlVURV9OQU1FIiwiRmxhZ3MiLCJpbnRlcm5hbEluc3RhbmNlS2V5Iiwic2hvdWxkUHJlY2FjaGVOb2RlIiwibm9kZUlEIiwiZ2V0QXR0cmlidXRlIiwibm9kZVZhbHVlIiwiZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudCIsInJlbmRlcmVkIiwicHJlY2FjaGVOb2RlIiwiaG9zdEluc3QiLCJfaG9zdE5vZGUiLCJ1bmNhY2hlTm9kZSIsInByZWNhY2hlQ2hpbGROb2RlcyIsIl9mbGFncyIsImhhc0NhY2hlZENoaWxkTm9kZXMiLCJfcmVuZGVyZWRDaGlsZHJlbiIsImNoaWxkTm9kZSIsIm91dGVyIiwiY2hpbGRJbnN0IiwiY2hpbGRJRCIsIl9kb21JRCIsIm5leHRTaWJsaW5nIiwicGFyZW50cyIsImNsb3Nlc3QiLCJnZXRJbnN0YW5jZUZyb21Ob2RlIiwiX2hvc3RQYXJlbnQiLCJjaGVja01hc2siLCJiaXRtYXNrIiwiRE9NUHJvcGVydHlJbmplY3Rpb24iLCJNVVNUX1VTRV9QUk9QRVJUWSIsIkhBU19CT09MRUFOX1ZBTFVFIiwiSEFTX05VTUVSSUNfVkFMVUUiLCJIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSIsIkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUiLCJpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyIsImRvbVByb3BlcnR5Q29uZmlnIiwiSW5qZWN0aW9uIiwiRE9NQXR0cmlidXRlTmFtZXNwYWNlcyIsIkRPTUF0dHJpYnV0ZU5hbWVzIiwiRE9NUHJvcGVydHlOYW1lcyIsIkRPTU11dGF0aW9uTWV0aG9kcyIsImlzQ3VzdG9tQXR0cmlidXRlIiwiX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zIiwibG93ZXJDYXNlZCIsInByb3BDb25maWciLCJwcm9wZXJ0eUluZm8iLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZXNwYWNlIiwicHJvcGVydHlOYW1lIiwibXV0YXRpb25NZXRob2QiLCJtdXN0VXNlUHJvcGVydHkiLCJoYXNCb29sZWFuVmFsdWUiLCJoYXNOdW1lcmljVmFsdWUiLCJoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSIsImhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUiLCJnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZSIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJST09UX0FUVFJJQlVURV9OQU1FIiwiQVRUUklCVVRFX05BTUVfQ0hBUiIsImF1dG9mb2N1cyIsImlzQ3VzdG9tQXR0cmlidXRlRm4iLCJBUklBRE9NUHJvcGVydHlDb25maWciLCJCZWZvcmVJbnB1dEV2ZW50UGx1Z2luIiwiQ2hhbmdlRXZlbnRQbHVnaW4iLCJEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciIsIkVudGVyTGVhdmVFdmVudFBsdWdpbiIsIkhUTUxET01Qcm9wZXJ0eUNvbmZpZyIsIlJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50IiwiUmVhY3RET01Db21wb25lbnQiLCJSZWFjdERPTUVtcHR5Q29tcG9uZW50IiwiUmVhY3RET01UcmVlVHJhdmVyc2FsIiwiUmVhY3RET01UZXh0Q29tcG9uZW50IiwiUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSIsIlJlYWN0RXZlbnRMaXN0ZW5lciIsIlJlYWN0SW5qZWN0aW9uIiwiUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiIsIlNWR0RPTVByb3BlcnR5Q29uZmlnIiwiU2VsZWN0RXZlbnRQbHVnaW4iLCJTaW1wbGVFdmVudFBsdWdpbiIsImFscmVhZHlJbmplY3RlZCIsImluamVjdFJlYWN0RXZlbnRMaXN0ZW5lciIsIkV2ZW50UGx1Z2luSHViIiwiaW5qZWN0RXZlbnRQbHVnaW5PcmRlciIsIkV2ZW50UGx1Z2luVXRpbHMiLCJpbmplY3RDb21wb25lbnRUcmVlIiwiaW5qZWN0VHJlZVRyYXZlcnNhbCIsImluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSIsIkhvc3RDb21wb25lbnQiLCJpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MiLCJpbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MiLCJFbXB0eUNvbXBvbmVudCIsImluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeSIsImluc3RhbnRpYXRlIiwiVXBkYXRlcyIsImluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uIiwiaW5qZWN0QmF0Y2hpbmdTdHJhdGVneSIsImluamVjdEVudmlyb25tZW50IiwiRXZlbnRQcm9wYWdhdG9ycyIsIkZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSIsIlN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQiLCJTeW50aGV0aWNJbnB1dEV2ZW50IiwiRU5EX0tFWUNPREVTIiwiU1RBUlRfS0VZQ09ERSIsImNhblVzZUNvbXBvc2l0aW9uRXZlbnQiLCJjYW5Vc2VUZXh0SW5wdXRFdmVudCIsImlzUHJlc3RvIiwidXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEiLCJvcGVyYSIsIlNQQUNFQkFSX0NPREUiLCJTUEFDRUJBUl9DSEFSIiwiZXZlbnRUeXBlcyIsImJlZm9yZUlucHV0IiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMiLCJidWJibGVkIiwiY2FwdHVyZWQiLCJkZXBlbmRlbmNpZXMiLCJjb21wb3NpdGlvbkVuZCIsImNvbXBvc2l0aW9uU3RhcnQiLCJjb21wb3NpdGlvblVwZGF0ZSIsImhhc1NwYWNlS2V5cHJlc3MiLCJpc0tleXByZXNzQ29tbWFuZCIsIm5hdGl2ZUV2ZW50IiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSIsInRvcExldmVsVHlwZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0Iiwia2V5Q29kZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImdldERhdGFGcm9tQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJjdXJyZW50Q29tcG9zaXRpb24iLCJleHRyYWN0Q29tcG9zaXRpb25FdmVudCIsInRhcmdldEluc3QiLCJuYXRpdmVFdmVudFRhcmdldCIsImZhbGxiYWNrRGF0YSIsImdldERhdGEiLCJjdXN0b21EYXRhIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyIsImdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMiLCJ3aGljaCIsImNoYXJzIiwiZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzIiwiZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQiLCJleHRyYWN0RXZlbnRzIiwiYWNjdW11bGF0ZUludG8iLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJnZXRMaXN0ZW5lciIsImxpc3RlbmVyQXRQaGFzZSIsInByb3BhZ2F0aW9uUGhhc2UiLCJyZWdpc3RyYXRpb25OYW1lIiwiZGlzcGF0Y2hDb25maWciLCJhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzIiwicGhhc2UiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMiLCJfZGlzcGF0Y2hJbnN0YW5jZXMiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlIiwidHJhdmVyc2VUd29QaGFzZSIsIl90YXJnZXRJbnN0IiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQiLCJwYXJlbnRJbnN0IiwiZ2V0UGFyZW50SW5zdGFuY2UiLCJhY2N1bXVsYXRlRGlzcGF0Y2hlcyIsImlnbm9yZWREaXJlY3Rpb24iLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSIsImV2ZW50cyIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0IiwiYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzIiwibGVhdmUiLCJlbnRlciIsInRyYXZlcnNlRW50ZXJMZWF2ZSIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzIiwiRXZlbnRQbHVnaW5SZWdpc3RyeSIsIlJlYWN0RXJyb3JVdGlscyIsImxpc3RlbmVyQmFuayIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJzaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIiLCJpc1BlcnNpc3RlbnQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCIsImdldERpY3Rpb25hcnlLZXkiLCJfcm9vdE5vZGVJRCIsImlzSW50ZXJhY3RpdmUiLCJ0YWciLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImRpc2FibGVkIiwicHV0TGlzdGVuZXIiLCJiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSIsIlBsdWdpbk1vZHVsZSIsInJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzIiwiZGlkUHV0TGlzdGVuZXIiLCJfY3VycmVudEVsZW1lbnQiLCJkZWxldGVMaXN0ZW5lciIsIndpbGxEZWxldGVMaXN0ZW5lciIsImRlbGV0ZUFsbExpc3RlbmVycyIsInBsdWdpbnMiLCJwb3NzaWJsZVBsdWdpbiIsImV4dHJhY3RlZEV2ZW50cyIsImVucXVldWVFdmVudHMiLCJwcm9jZXNzRXZlbnRRdWV1ZSIsInByb2Nlc3NpbmdFdmVudFF1ZXVlIiwicmV0aHJvd0NhdWdodEVycm9yIiwiX19wdXJnZSIsIl9fZ2V0TGlzdGVuZXJCYW5rIiwiZXZlbnRQbHVnaW5PcmRlciIsIm5hbWVzVG9QbHVnaW5zIiwicmVjb21wdXRlUGx1Z2luT3JkZXJpbmciLCJwbHVnaW5OYW1lIiwicGx1Z2luTW9kdWxlIiwicGx1Z2luSW5kZXgiLCJwdWJsaXNoZWRFdmVudHMiLCJwdWJsaXNoRXZlbnRGb3JQbHVnaW4iLCJldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MiLCJwaGFzZU5hbWUiLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lIiwicHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUiLCJyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzIiwibG93ZXJDYXNlZE5hbWUiLCJwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIiwib25kYmxjbGljayIsImluamVjdGVkRXZlbnRQbHVnaW5PcmRlciIsImluamVjdGVkTmFtZXNUb1BsdWdpbnMiLCJpc09yZGVyaW5nRGlydHkiLCJnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudCIsIl9yZXNldEV2ZW50UGx1Z2lucyIsIlRyZWVUcmF2ZXJzYWwiLCJJbmplY3RlZCIsImlzQW5jZXN0b3IiLCJnZXRMb3dlc3RDb21tb25BbmNlc3RvciIsImlzRW5kaXNoIiwiaXNNb3ZlaXNoIiwiaXNTdGFydGlzaCIsInZhbGlkYXRlRXZlbnREaXNwYXRjaGVzIiwiZGlzcGF0Y2hMaXN0ZW5lcnMiLCJkaXNwYXRjaEluc3RhbmNlcyIsImxpc3RlbmVyc0lzQXJyIiwibGlzdGVuZXJzTGVuIiwiaW5zdGFuY2VzSXNBcnIiLCJpbnN0YW5jZXNMZW4iLCJleGVjdXRlRGlzcGF0Y2giLCJjdXJyZW50VGFyZ2V0IiwiaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbCIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUiLCJleGVjdXRlRGlyZWN0RGlzcGF0Y2giLCJkaXNwYXRjaExpc3RlbmVyIiwiZGlzcGF0Y2hJbnN0YW5jZSIsImhhc0Rpc3BhdGNoZXMiLCJhcmdGcm9tIiwiYXJnVG8iLCJjYXVnaHRFcnJvciIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJib3VuZEZ1bmMiLCJldnRUeXBlIiwiZXZ0IiwiY2IiLCJzY29wZSIsImNhblVzZVdvcmtlcnMiLCJXb3JrZXIiLCJjYW5Vc2VFdmVudExpc3RlbmVycyIsImNhblVzZVZpZXdwb3J0Iiwic2NyZWVuIiwiaXNJbldvcmtlciIsImdldFRleHRDb250ZW50QWNjZXNzb3IiLCJfcm9vdCIsIl9zdGFydFRleHQiLCJfZmFsbGJhY2tUZXh0Iiwic3RhcnRWYWx1ZSIsInN0YXJ0TGVuZ3RoIiwiZW5kIiwiZW5kVmFsdWUiLCJlbmRMZW5ndGgiLCJtaW5FbmQiLCJzbGljZVRhaWwiLCJjb250ZW50S2V5IiwiU3ludGhldGljRXZlbnQiLCJDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlIiwiZGlzcGF0Y2hNYXJrZXIiLCJhdWdtZW50Q2xhc3MiLCJkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSIsImlzUHJveHlTdXBwb3J0ZWQiLCJQcm94eSIsInNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzIiwiRXZlbnRJbnRlcmZhY2UiLCJldmVudFBoYXNlIiwiZGVmYXVsdFByZXZlbnRlZCIsImlzVHJ1c3RlZCIsIkludGVyZmFjZSIsIm5vcm1hbGl6ZSIsInJldHVyblZhbHVlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiY2FuY2VsQnViYmxlIiwicGVyc2lzdCIsImdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJDbGFzcyIsIlN1cGVyIiwiRSIsImdldFZhbCIsIndhcm5pbmdDb25kaXRpb24iLCJJbnB1dEV2ZW50SW50ZXJmYWNlIiwiZ2V0RXZlbnRUYXJnZXQiLCJpc0V2ZW50U3VwcG9ydGVkIiwiaXNUZXh0SW5wdXRFbGVtZW50IiwiY2hhbmdlIiwiYWN0aXZlRWxlbWVudCIsImFjdGl2ZUVsZW1lbnRJbnN0IiwiYWN0aXZlRWxlbWVudFZhbHVlIiwiYWN0aXZlRWxlbWVudFZhbHVlUHJvcCIsInNob3VsZFVzZUNoYW5nZUV2ZW50IiwiZWxlbSIsIm5vZGVOYW1lIiwiZG9lc0NoYW5nZUV2ZW50QnViYmxlIiwibWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCIsInJ1bkV2ZW50SW5CYXRjaCIsInN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCIsInN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4IiwiZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50IiwiaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgiLCJpc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJuZXdWYWx1ZVByb3AiLCJzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJoYW5kbGVQcm9wZXJ0eUNoYW5nZSIsInN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwic3JjRWxlbWVudCIsImdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50IiwiaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFIiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRSIsInNob3VsZFVzZUNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCIsInRhcmdldE5vZGUiLCJnZXRUYXJnZXRJbnN0RnVuYyIsImhhbmRsZUV2ZW50RnVuYyIsIkNhbGxiYWNrUXVldWUiLCJSZWFjdEZlYXR1cmVGbGFncyIsIlRyYW5zYWN0aW9uIiwiZGlydHlDb21wb25lbnRzIiwidXBkYXRlQmF0Y2hOdW1iZXIiLCJhc2FwQ2FsbGJhY2tRdWV1ZSIsImFzYXBFbnF1ZXVlZCIsImJhdGNoaW5nU3RyYXRlZ3kiLCJlbnN1cmVJbmplY3RlZCIsIk5FU1RFRF9VUERBVEVTIiwiaW5pdGlhbGl6ZSIsImRpcnR5Q29tcG9uZW50c0xlbmd0aCIsImZsdXNoQmF0Y2hlZFVwZGF0ZXMiLCJVUERBVEVfUVVFVUVJTkciLCJjYWxsYmFja1F1ZXVlIiwicmVzZXQiLCJub3RpZnlBbGwiLCJUUkFOU0FDVElPTl9XUkFQUEVSUyIsIlJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24iLCJyZWluaXRpYWxpemVUcmFuc2FjdGlvbiIsInJlY29uY2lsZVRyYW5zYWN0aW9uIiwiZ2V0VHJhbnNhY3Rpb25XcmFwcGVycyIsInBlcmZvcm0iLCJtb3VudE9yZGVyQ29tcGFyYXRvciIsImMxIiwiYzIiLCJfbW91bnRPcmRlciIsInJ1bkJhdGNoZWRVcGRhdGVzIiwidHJhbnNhY3Rpb24iLCJjYWxsYmFja3MiLCJfcGVuZGluZ0NhbGxiYWNrcyIsIm1hcmtlck5hbWUiLCJsb2dUb3BMZXZlbFJlbmRlcnMiLCJuYW1lZENvbXBvbmVudCIsImlzUmVhY3RUb3BMZXZlbFdyYXBwZXIiLCJwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkiLCJ0aW1lRW5kIiwiZW5xdWV1ZSIsImdldFB1YmxpY0luc3RhbmNlIiwiZW5xdWV1ZVVwZGF0ZSIsImlzQmF0Y2hpbmdVcGRhdGVzIiwiX3VwZGF0ZUJhdGNoTnVtYmVyIiwiYXNhcCIsIlJlYWN0VXBkYXRlc0luamVjdGlvbiIsIlJlY29uY2lsZVRyYW5zYWN0aW9uIiwiX2JhdGNoaW5nU3RyYXRlZ3kiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2FsbGJhY2tzIiwiX2NvbnRleHRzIiwiX2FyZyIsImNvbnRleHRzIiwiY2hlY2twb2ludCIsInJvbGxiYWNrIiwiUmVhY3RSZWYiLCJhdHRhY2hSZWZzIiwibW91bnRDb21wb25lbnQiLCJpbnRlcm5hbEluc3RhbmNlIiwiaG9zdFBhcmVudCIsImhvc3RDb250YWluZXJJbmZvIiwicGFyZW50RGVidWdJRCIsIm1hcmt1cCIsImdldFJlYWN0TW91bnRSZWFkeSIsImdldEhvc3ROb2RlIiwidW5tb3VudENvbXBvbmVudCIsInNhZmVseSIsIm9uQmVmb3JlVW5tb3VudENvbXBvbmVudCIsImRldGFjaFJlZnMiLCJyZWNlaXZlQ29tcG9uZW50IiwibmV4dEVsZW1lbnQiLCJwcmV2RWxlbWVudCIsIl9jb250ZXh0IiwicmVmc0NoYW5nZWQiLCJzaG91bGRVcGRhdGVSZWZzIiwiUmVhY3RPd25lciIsImF0dGFjaFJlZiIsImFkZENvbXBvbmVudEFzUmVmVG8iLCJkZXRhY2hSZWYiLCJyZW1vdmVDb21wb25lbnRBc1JlZkZyb20iLCJwcmV2UmVmIiwicHJldk93bmVyIiwibmV4dFJlZiIsIm5leHRPd25lciIsImlzVmFsaWRPd25lciIsIm93bmVyUHVibGljSW5zdGFuY2UiLCJSZWFjdERlYnVnVG9vbCIsIlJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2siLCJSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayIsInBlcmZvcm1hbmNlTm93IiwiaG9va3MiLCJkaWRIb29rVGhyb3dGb3JFdmVudCIsImNhbGxIb29rIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYXJnNCIsImFyZzUiLCJlbWl0RXZlbnQiLCJob29rIiwiaXNQcm9maWxpbmciLCJmbHVzaEhpc3RvcnkiLCJsaWZlQ3ljbGVUaW1lclN0YWNrIiwiY3VycmVudEZsdXNoTmVzdGluZyIsImN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyIsImN1cnJlbnRGbHVzaFN0YXJ0VGltZSIsImN1cnJlbnRUaW1lckRlYnVnSUQiLCJjdXJyZW50VGltZXJTdGFydFRpbWUiLCJjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uIiwiY3VycmVudFRpbWVyVHlwZSIsImxpZmVDeWNsZVRpbWVySGFzV2FybmVkIiwiY2xlYXJIaXN0b3J5IiwiZ2V0VHJlZVNuYXBzaG90IiwicmVnaXN0ZXJlZElEcyIsInJlZHVjZSIsInRyZWUiLCJyZXNldE1lYXN1cmVtZW50cyIsInByZXZpb3VzU3RhcnRUaW1lIiwicHJldmlvdXNNZWFzdXJlbWVudHMiLCJwcmV2aW91c09wZXJhdGlvbnMiLCJnZXRIaXN0b3J5IiwiZHVyYXRpb24iLCJtZWFzdXJlbWVudHMiLCJvcGVyYXRpb25zIiwidHJlZVNuYXBzaG90IiwiY2hlY2tEZWJ1Z0lEIiwiYWxsb3dSb290IiwiYmVnaW5MaWZlQ3ljbGVUaW1lciIsInRpbWVyVHlwZSIsImVuZExpZmVDeWNsZVRpbWVyIiwiaW5zdGFuY2VJRCIsInBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyIiwiY3VycmVudFRpbWVyIiwic3RhcnRUaW1lIiwibmVzdGVkRmx1c2hTdGFydFRpbWUiLCJyZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIiLCJfbGlmZUN5Y2xlVGltZXJTdGFjayQiLCJuZXN0ZWRGbHVzaER1cmF0aW9uIiwibGFzdE1hcmtUaW1lU3RhbXAiLCJjYW5Vc2VQZXJmb3JtYW5jZU1lYXN1cmUiLCJwZXJmb3JtYW5jZSIsImNsZWFyTWFya3MiLCJtZWFzdXJlIiwiY2xlYXJNZWFzdXJlcyIsInNob3VsZE1hcmsiLCJpc0hvc3RFbGVtZW50IiwibWFya0JlZ2luIiwibWFya1R5cGUiLCJtYXJrTmFtZSIsIm1hcmtFbmQiLCJtZWFzdXJlbWVudE5hbWUiLCJyZW1vdmVIb29rIiwiYmVnaW5Qcm9maWxpbmciLCJlbmRQcm9maWxpbmciLCJnZXRGbHVzaEhpc3RvcnkiLCJvbkJlZ2luRmx1c2giLCJvbkVuZEZsdXNoIiwib25CZWdpbkxpZmVDeWNsZVRpbWVyIiwib25FbmRMaWZlQ3ljbGVUaW1lciIsIm9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0Iiwib25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0Iiwib25Ib3N0T3BlcmF0aW9uIiwib3BlcmF0aW9uIiwib25TZXRTdGF0ZSIsImNoaWxkRGVidWdJRHMiLCJvblRlc3RFdmVudCIsImFkZERldnRvb2wiLCJyZW1vdmVEZXZ0b29sIiwicHJvY2Vzc2luZ0NoaWxkQ29udGV4dCIsIndhcm5JbnZhbGlkU2V0U3RhdGUiLCJoaXN0b3J5IiwiX3ByZXZlbnRDbGVhcmluZyIsIm1zUGVyZm9ybWFuY2UiLCJ3ZWJraXRQZXJmb3JtYW5jZSIsIk9CU0VSVkVEX0VSUk9SIiwiVHJhbnNhY3Rpb25JbXBsIiwidHJhbnNhY3Rpb25XcmFwcGVycyIsIndyYXBwZXJJbml0RGF0YSIsIl9pc0luVHJhbnNhY3Rpb24iLCJpc0luVHJhbnNhY3Rpb24iLCJlcnJvclRocm93biIsImluaXRpYWxpemVBbGwiLCJjbG9zZUFsbCIsInN0YXJ0SW5kZXgiLCJ3cmFwcGVyIiwiaW5pdERhdGEiLCJjb3JyZXNwb25kaW5nVXNlRWxlbWVudCIsInVzZUhhc0ZlYXR1cmUiLCJpbXBsZW1lbnRhdGlvbiIsImhhc0ZlYXR1cmUiLCJldmVudE5hbWVTdWZmaXgiLCJjYXB0dXJlIiwic2V0QXR0cmlidXRlIiwic3VwcG9ydGVkSW5wdXRUeXBlcyIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJtb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsIndpbiIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsInJlbGF0ZWQiLCJ0b0VsZW1lbnQiLCJmcm9tTm9kZSIsInRvTm9kZSIsIlN5bnRoZXRpY1VJRXZlbnQiLCJWaWV3cG9ydE1ldHJpY3MiLCJnZXRFdmVudE1vZGlmaWVyU3RhdGUiLCJNb3VzZUV2ZW50SW50ZXJmYWNlIiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsInNoaWZ0S2V5IiwiZ2V0TW9kaWZpZXJTdGF0ZSIsImJ1dHRvbnMiLCJwYWdlWCIsImN1cnJlbnRTY3JvbGxMZWZ0IiwicGFnZVkiLCJjdXJyZW50U2Nyb2xsVG9wIiwiVUlFdmVudEludGVyZmFjZSIsInZpZXciLCJyZWZyZXNoU2Nyb2xsVmFsdWVzIiwic2Nyb2xsUG9zaXRpb24iLCJtb2RpZmllcktleVRvUHJvcCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImtleVByb3AiLCJhY2NlcHQiLCJhY2Nlc3NLZXkiLCJhbGxvd0Z1bGxTY3JlZW4iLCJhbGxvd1RyYW5zcGFyZW5jeSIsImFsdCIsImFzIiwiYXV0b0NvbXBsZXRlIiwiYXV0b1BsYXkiLCJjZWxsUGFkZGluZyIsImNlbGxTcGFjaW5nIiwiY2hhclNldCIsImNoYWxsZW5nZSIsImNoZWNrZWQiLCJjbGFzc0lEIiwiY29scyIsImNvbFNwYW4iLCJjb250ZW50RWRpdGFibGUiLCJjb250ZXh0TWVudSIsImNvbnRyb2xzIiwiY29vcmRzIiwiY3Jvc3NPcmlnaW4iLCJkYXRlVGltZSIsImRlZmVyIiwiZG93bmxvYWQiLCJkcmFnZ2FibGUiLCJlbmNUeXBlIiwiZm9ybUFjdGlvbiIsImZvcm1FbmNUeXBlIiwiZm9ybU1ldGhvZCIsImZvcm1Ob1ZhbGlkYXRlIiwiZm9ybVRhcmdldCIsImZyYW1lQm9yZGVyIiwiaGVpZ2h0IiwiaGlkZGVuIiwiaGlnaCIsImhyZWZMYW5nIiwiaHR0cEVxdWl2IiwiaWNvbiIsImlucHV0TW9kZSIsImludGVncml0eSIsImtleVBhcmFtcyIsImtleVR5cGUiLCJraW5kIiwibGFuZyIsImxpc3QiLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW5IZWlnaHQiLCJtYXJnaW5XaWR0aCIsIm1heExlbmd0aCIsIm1lZGlhIiwibWVkaWFHcm91cCIsIm1pbiIsIm1pbkxlbmd0aCIsIm11bHRpcGxlIiwibXV0ZWQiLCJub25jZSIsIm5vVmFsaWRhdGUiLCJvcHRpbXVtIiwicGxhY2Vob2xkZXIiLCJwbGF5c0lubGluZSIsInBvc3RlciIsInByZWxvYWQiLCJwcm9maWxlIiwicmFkaW9Hcm91cCIsInJlYWRPbmx5IiwicmVmZXJyZXJQb2xpY3kiLCJyZXZlcnNlZCIsInJvbGUiLCJyb3dzIiwicm93U3BhbiIsInNhbmRib3giLCJzY29wZWQiLCJzY3JvbGxpbmciLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2l6ZXMiLCJzcGVsbENoZWNrIiwic3JjRG9jIiwic3JjTGFuZyIsInNyY1NldCIsInRhYkluZGV4IiwidXNlTWFwIiwid21vZGUiLCJ3cmFwIiwiYWJvdXQiLCJkYXRhdHlwZSIsImlubGlzdCIsInJlc291cmNlIiwidm9jYWIiLCJhdXRvQ2FwaXRhbGl6ZSIsImF1dG9Db3JyZWN0IiwiYXV0b1NhdmUiLCJpdGVtUHJvcCIsIml0ZW1TY29wZSIsIml0ZW1UeXBlIiwiaXRlbUlEIiwiaXRlbVJlZiIsInNlY3VyaXR5IiwidW5zZWxlY3RhYmxlIiwiRE9NQ2hpbGRyZW5PcGVyYXRpb25zIiwiUmVhY3RET01JRE9wZXJhdGlvbnMiLCJwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwiZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwicmVwbGFjZU5vZGVXaXRoTWFya3VwIiwiZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAiLCJET01MYXp5VHJlZSIsIkRhbmdlciIsImNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24iLCJzZXRJbm5lckhUTUwiLCJzZXRUZXh0Q29udGVudCIsImdldE5vZGVBZnRlciIsImluc2VydENoaWxkQXQiLCJyZWZlcmVuY2VOb2RlIiwiaW5zZXJ0TGF6eVRyZWVDaGlsZEF0IiwiY2hpbGRUcmVlIiwiaW5zZXJ0VHJlZUJlZm9yZSIsIm1vdmVDaGlsZCIsIm1vdmVEZWxpbWl0ZWRUZXh0IiwiY2xvc2luZ0NvbW1lbnQiLCJyZW1vdmVEZWxpbWl0ZWRUZXh0Iiwib3BlbmluZ0NvbW1lbnQiLCJuZXh0Tm9kZSIsInN0YXJ0Tm9kZSIsInJlcGxhY2VEZWxpbWl0ZWRUZXh0Iiwic3RyaW5nVGV4dCIsIm5vZGVBZnRlckNvbW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsIm9sZENoaWxkIiwicHJldkluc3RhbmNlIiwibmV4dEluc3RhbmNlIiwicHJvY2Vzc1VwZGF0ZXMiLCJ1cGRhdGVzIiwicGFyZW50Tm9kZURlYnVnSUQiLCJhZnRlck5vZGUiLCJ0b0luZGV4IiwiZnJvbUluZGV4IiwiRE9NTmFtZXNwYWNlcyIsIkVMRU1FTlRfTk9ERV9UWVBFIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFIiwiZW5hYmxlTGF6eSIsImluc2VydFRyZWVDaGlsZHJlbiIsIm5hbWVzcGFjZVVSSSIsInJlcGxhY2VDaGlsZFdpdGhUcmVlIiwib2xkTm9kZSIsIm5ld1RyZWUiLCJyZXBsYWNlQ2hpbGQiLCJxdWV1ZUNoaWxkIiwicGFyZW50VHJlZSIsInF1ZXVlSFRNTCIsInF1ZXVlVGV4dCIsIm1hdGhtbCIsIldISVRFU1BBQ0VfVEVTVCIsIk5PTlZJU0lCTEVfVEVTVCIsInJldXNhYmxlU1ZHQ29udGFpbmVyIiwiaW5uZXJIVE1MIiwic3ZnTm9kZSIsInRlc3RFbGVtZW50IiwidGV4dE5vZGUiLCJkZWxldGVEYXRhIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIiLCJsYXN0Q2hpbGQiLCJ0ZXh0Q29udGVudCIsIm1hdGNoSHRtbFJlZ0V4cCIsImVzY2FwZUh0bWwiLCJjcmVhdGVOb2Rlc0Zyb21NYXJrdXAiLCJuZXdDaGlsZCIsImNyZWF0ZUFycmF5RnJvbU1peGVkIiwiZ2V0TWFya3VwV3JhcCIsImR1bW15Tm9kZSIsIm5vZGVOYW1lUGF0dGVybiIsImdldE5vZGVOYW1lIiwibm9kZU5hbWVNYXRjaCIsImhhbmRsZVNjcmlwdCIsIndyYXBEZXB0aCIsInNjcmlwdHMiLCJub2RlcyIsImNoaWxkTm9kZXMiLCJjYWxsZWUiLCJoYXNBcnJheU5hdHVyZSIsInNob3VsZFdyYXAiLCJzZWxlY3RXcmFwIiwidGFibGVXcmFwIiwidHJXcmFwIiwic3ZnV3JhcCIsIm1hcmt1cFdyYXAiLCJzdmdFbGVtZW50cyIsIkF1dG9Gb2N1c1V0aWxzIiwiQ1NTUHJvcGVydHlPcGVyYXRpb25zIiwiRE9NUHJvcGVydHlPcGVyYXRpb25zIiwiUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyIiwiUmVhY3RET01JbnB1dCIsIlJlYWN0RE9NT3B0aW9uIiwiUmVhY3RET01TZWxlY3QiLCJSZWFjdERPTVRleHRhcmVhIiwiUmVhY3RNdWx0aUNoaWxkIiwiUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiIsInNoYWxsb3dFcXVhbCIsInZhbGlkYXRlRE9NTmVzdGluZyIsImdldE5vZGUiLCJsaXN0ZW5UbyIsIkNPTlRFTlRfVFlQRVMiLCJTVFlMRSIsIkhUTUwiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyIsIkRPQ19GUkFHTUVOVF9UWVBFIiwiZnJpZW5kbHlTdHJpbmdpZnkiLCJrZXlFc2NhcGVkIiwic3R5bGVNdXRhdGlvbldhcm5pbmciLCJjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUiLCJzdHlsZTEiLCJzdHlsZTIiLCJfdGFnIiwiYXNzZXJ0VmFsaWRQcm9wcyIsInZvaWRFbGVtZW50VGFncyIsIm9uRm9jdXNJbiIsIm9uRm9jdXNPdXQiLCJlbnF1ZXVlUHV0TGlzdGVuZXIiLCJjb250YWluZXJJbmZvIiwiX2hvc3RDb250YWluZXJJbmZvIiwiaXNEb2N1bWVudEZyYWdtZW50IiwiX25vZGUiLCJfb3duZXJEb2N1bWVudCIsImxpc3RlbmVyVG9QdXQiLCJpbnB1dFBvc3RNb3VudCIsInBvc3RNb3VudFdyYXBwZXIiLCJ0ZXh0YXJlYVBvc3RNb3VudCIsIm9wdGlvblBvc3RNb3VudCIsInNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2IiwiaGFzRXhpc3RpbmdDb250ZW50IiwiX2NvbnRlbnREZWJ1Z0lEIiwiY29udGVudERlYnVnSUQiLCJfYW5jZXN0b3JJbmZvIiwibWVkaWFFdmVudHMiLCJ0b3BBYm9ydCIsInRvcENhblBsYXkiLCJ0b3BDYW5QbGF5VGhyb3VnaCIsInRvcER1cmF0aW9uQ2hhbmdlIiwidG9wRW1wdGllZCIsInRvcEVuY3J5cHRlZCIsInRvcEVuZGVkIiwidG9wRXJyb3IiLCJ0b3BMb2FkZWREYXRhIiwidG9wTG9hZGVkTWV0YWRhdGEiLCJ0b3BMb2FkU3RhcnQiLCJ0b3BQYXVzZSIsInRvcFBsYXkiLCJ0b3BQbGF5aW5nIiwidG9wUHJvZ3Jlc3MiLCJ0b3BSYXRlQ2hhbmdlIiwidG9wU2Vla2VkIiwidG9wU2Vla2luZyIsInRvcFN0YWxsZWQiLCJ0b3BTdXNwZW5kIiwidG9wVGltZVVwZGF0ZSIsInRvcFZvbHVtZUNoYW5nZSIsInRvcFdhaXRpbmciLCJ0cmFwQnViYmxlZEV2ZW50c0xvY2FsIiwiX3dyYXBwZXJTdGF0ZSIsInRyYXBCdWJibGVkRXZlbnQiLCJwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciIsInBvc3RVcGRhdGVXcmFwcGVyIiwib21pdHRlZENsb3NlVGFncyIsIm5ld2xpbmVFYXRpbmdUYWdzIiwiVkFMSURfVEFHX1JFR0VYIiwidmFsaWRhdGVkVGFnQ2FjaGUiLCJ2YWxpZGF0ZURhbmdlcm91c1RhZyIsImlzQ3VzdG9tQ29tcG9uZW50IiwidGFnTmFtZSIsImdsb2JhbElkQ291bnRlciIsIl9uYW1lc3BhY2VVUkkiLCJfcHJldmlvdXNTdHlsZSIsIl9wcmV2aW91c1N0eWxlQ29weSIsIl90b3BMZXZlbFdyYXBwZXIiLCJNaXhpbiIsIl9pZENvdW50ZXIiLCJtb3VudFdyYXBwZXIiLCJnZXRIb3N0UHJvcHMiLCJwYXJlbnRUYWciLCJwYXJlbnRJbmZvIiwidXBkYXRlZEFuY2VzdG9ySW5mbyIsIm1vdW50SW1hZ2UiLCJ1c2VDcmVhdGVFbGVtZW50IiwiZWwiLCJjcmVhdGVFbGVtZW50TlMiLCJzZXRBdHRyaWJ1dGVGb3JSb290IiwiX3VwZGF0ZURPTVByb3BlcnRpZXMiLCJsYXp5VHJlZSIsIl9jcmVhdGVJbml0aWFsQ2hpbGRyZW4iLCJ0YWdPcGVuIiwiX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnMiLCJ0YWdDb250ZW50IiwiX2NyZWF0ZUNvbnRlbnRNYXJrdXAiLCJhdXRvRm9jdXMiLCJmb2N1c0RPTUNvbXBvbmVudCIsInByb3BLZXkiLCJjcmVhdGVNYXJrdXBGb3JTdHlsZXMiLCJjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUiLCJjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eSIsInJlbmRlclRvU3RhdGljTWFya3VwIiwiY3JlYXRlTWFya3VwRm9yUm9vdCIsImNyZWF0ZU1hcmt1cEZvcklEIiwiX19odG1sIiwiY29udGVudFRvVXNlIiwiY2hpbGRyZW5Ub1VzZSIsIm1vdW50SW1hZ2VzIiwibW91bnRDaGlsZHJlbiIsImxhc3RQcm9wcyIsIm5leHRQcm9wcyIsIl91cGRhdGVET01DaGlsZHJlbiIsInVwZGF0ZVdyYXBwZXIiLCJzdHlsZU5hbWUiLCJzdHlsZVVwZGF0ZXMiLCJsYXN0U3R5bGUiLCJkZWxldGVWYWx1ZUZvckF0dHJpYnV0ZSIsImRlbGV0ZVZhbHVlRm9yUHJvcGVydHkiLCJuZXh0UHJvcCIsImxhc3RQcm9wIiwic2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJzZXRWYWx1ZUZvclByb3BlcnR5Iiwic2V0VmFsdWVGb3JTdHlsZXMiLCJsYXN0Q29udGVudCIsIm5leHRDb250ZW50IiwibGFzdEh0bWwiLCJuZXh0SHRtbCIsImxhc3RDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsImxhc3RIYXNDb250ZW50T3JIdG1sIiwibmV4dEhhc0NvbnRlbnRPckh0bWwiLCJ1cGRhdGVDaGlsZHJlbiIsInVwZGF0ZVRleHRDb250ZW50IiwidXBkYXRlTWFya3VwIiwicmVtb3ZlIiwidW5tb3VudENoaWxkcmVuIiwiZm9jdXNOb2RlIiwiZm9jdXMiLCJDU1NQcm9wZXJ0eSIsImNhbWVsaXplU3R5bGVOYW1lIiwiZGFuZ2Vyb3VzU3R5bGVWYWx1ZSIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsIm1lbW9pemVTdHJpbmdPbmx5IiwicHJvY2Vzc1N0eWxlTmFtZSIsImhhc1Nob3J0aGFuZFByb3BlcnR5QnVnIiwic3R5bGVGbG9hdEFjY2Vzc29yIiwidGVtcFN0eWxlIiwiZm9udCIsImNzc0Zsb2F0IiwiYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuIiwiYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuIiwid2FybmVkU3R5bGVOYW1lcyIsIndhcm5lZFN0eWxlVmFsdWVzIiwid2FybmVkRm9yTmFOVmFsdWUiLCJ3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSIsImNoZWNrUmVuZGVyTWVzc2FnZSIsIndhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSIsInRvVXBwZXJDYXNlIiwid2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uIiwid2FyblN0eWxlVmFsdWVJc05hTiIsIndhcm5WYWxpZFN0eWxlIiwic3R5bGVzIiwic3R5bGVWYWx1ZSIsImV4cGFuc2lvbiIsInNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyIsImluZGl2aWR1YWxTdHlsZU5hbWUiLCJpc1VuaXRsZXNzTnVtYmVyIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJib3JkZXJJbWFnZU91dHNldCIsImJvcmRlckltYWdlU2xpY2UiLCJib3JkZXJJbWFnZVdpZHRoIiwiYm94RmxleCIsImJveEZsZXhHcm91cCIsImJveE9yZGluYWxHcm91cCIsImNvbHVtbkNvdW50IiwiZmxleCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRSb3ciLCJncmlkQ29sdW1uIiwiZm9udFdlaWdodCIsImxpbmVDbGFtcCIsImxpbmVIZWlnaHQiLCJvcGFjaXR5Iiwib3JkZXIiLCJvcnBoYW5zIiwidGFiU2l6ZSIsIndpZG93cyIsInpJbmRleCIsInpvb20iLCJmaWxsT3BhY2l0eSIsImZsb29kT3BhY2l0eSIsInN0b3BPcGFjaXR5Iiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCIsInN0cm9rZU1pdGVybGltaXQiLCJzdHJva2VPcGFjaXR5Iiwic3Ryb2tlV2lkdGgiLCJwcmVmaXhLZXkiLCJwcmVmaXhlcyIsImJhY2tncm91bmQiLCJiYWNrZ3JvdW5kQXR0YWNobWVudCIsImJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRJbWFnZSIsImJhY2tncm91bmRQb3NpdGlvblgiLCJiYWNrZ3JvdW5kUG9zaXRpb25ZIiwiYmFja2dyb3VuZFJlcGVhdCIsImJhY2tncm91bmRQb3NpdGlvbiIsImJvcmRlciIsImJvcmRlcldpZHRoIiwiYm9yZGVyU3R5bGUiLCJib3JkZXJDb2xvciIsImJvcmRlckJvdHRvbSIsImJvcmRlckJvdHRvbVdpZHRoIiwiYm9yZGVyQm90dG9tU3R5bGUiLCJib3JkZXJCb3R0b21Db2xvciIsImJvcmRlckxlZnQiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJMZWZ0U3R5bGUiLCJib3JkZXJMZWZ0Q29sb3IiLCJib3JkZXJSaWdodCIsImJvcmRlclJpZ2h0V2lkdGgiLCJib3JkZXJSaWdodFN0eWxlIiwiYm9yZGVyUmlnaHRDb2xvciIsImJvcmRlclRvcCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyVG9wU3R5bGUiLCJib3JkZXJUb3BDb2xvciIsImZvbnRTdHlsZSIsImZvbnRWYXJpYW50IiwiZm9udFNpemUiLCJmb250RmFtaWx5Iiwib3V0bGluZSIsIm91dGxpbmVXaWR0aCIsIm91dGxpbmVTdHlsZSIsIm91dGxpbmVDb2xvciIsImNhbWVsaXplIiwibXNQYXR0ZXJuIiwiX2h5cGhlblBhdHRlcm4iLCJjaGFyYWN0ZXIiLCJzdHlsZVdhcm5pbmdzIiwiaXNFbXB0eSIsImlzTm9uTnVtZXJpYyIsIndhcm5pbmdzIiwiaHlwaGVuYXRlIiwiX3VwcGVyY2FzZVBhdHRlcm4iLCJjYWNoZSIsInF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsInNob3VsZElnbm9yZVZhbHVlIiwic2V0QXR0cmlidXRlRm9ySUQiLCJzZXRBdHRyaWJ1dGVOUyIsInJlbW92ZUF0dHJpYnV0ZSIsIlJlYWN0RXZlbnRFbWl0dGVyTWl4aW4iLCJnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSIsImhhc0V2ZW50UGFnZVhZIiwiYWxyZWFkeUxpc3RlbmluZ1RvIiwiaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUiLCJyZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIiLCJ0b3BFdmVudE1hcHBpbmciLCJ0b3BBbmltYXRpb25FbmQiLCJ0b3BBbmltYXRpb25JdGVyYXRpb24iLCJ0b3BBbmltYXRpb25TdGFydCIsInRvcEJsdXIiLCJ0b3BDaGFuZ2UiLCJ0b3BDbGljayIsInRvcENvbXBvc2l0aW9uRW5kIiwidG9wQ29tcG9zaXRpb25TdGFydCIsInRvcENvbXBvc2l0aW9uVXBkYXRlIiwidG9wQ29udGV4dE1lbnUiLCJ0b3BDb3B5IiwidG9wQ3V0IiwidG9wRG91YmxlQ2xpY2siLCJ0b3BEcmFnIiwidG9wRHJhZ0VuZCIsInRvcERyYWdFbnRlciIsInRvcERyYWdFeGl0IiwidG9wRHJhZ0xlYXZlIiwidG9wRHJhZ092ZXIiLCJ0b3BEcmFnU3RhcnQiLCJ0b3BEcm9wIiwidG9wRm9jdXMiLCJ0b3BJbnB1dCIsInRvcEtleURvd24iLCJ0b3BLZXlQcmVzcyIsInRvcEtleVVwIiwidG9wTW91c2VEb3duIiwidG9wTW91c2VNb3ZlIiwidG9wTW91c2VPdXQiLCJ0b3BNb3VzZU92ZXIiLCJ0b3BNb3VzZVVwIiwidG9wUGFzdGUiLCJ0b3BTY3JvbGwiLCJ0b3BTZWxlY3Rpb25DaGFuZ2UiLCJ0b3BUZXh0SW5wdXQiLCJ0b3BUb3VjaENhbmNlbCIsInRvcFRvdWNoRW5kIiwidG9wVG91Y2hNb3ZlIiwidG9wVG91Y2hTdGFydCIsInRvcFRyYW5zaXRpb25FbmQiLCJ0b3BXaGVlbCIsInRvcExpc3RlbmVyc0lES2V5IiwiZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQiLCJtb3VudEF0Iiwic2V0SGFuZGxlVG9wTGV2ZWwiLCJoYW5kbGVUb3BMZXZlbCIsInNldEVuYWJsZWQiLCJpc0VuYWJsZWQiLCJjb250ZW50RG9jdW1lbnRIYW5kbGUiLCJpc0xpc3RlbmluZyIsImRlcGVuZGVuY3kiLCJ0cmFwQ2FwdHVyZWRFdmVudCIsIldJTkRPV19IQU5ETEUiLCJoYW5kbGVyQmFzZU5hbWUiLCJoYW5kbGUiLCJzdXBwb3J0c0V2ZW50UGFnZVhZIiwiZXYiLCJlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmciLCJyZWZyZXNoIiwibW9uaXRvclNjcm9sbFZhbHVlIiwicnVuRXZlbnRRdWV1ZUluQmF0Y2giLCJtYWtlUHJlZml4TWFwIiwic3R5bGVQcm9wIiwidmVuZG9yUHJlZml4ZXMiLCJhbmltYXRpb25lbmQiLCJhbmltYXRpb25pdGVyYXRpb24iLCJhbmltYXRpb25zdGFydCIsInRyYW5zaXRpb25lbmQiLCJwcmVmaXhlZEV2ZW50TmFtZXMiLCJhbmltYXRpb24iLCJ0cmFuc2l0aW9uIiwicHJlZml4TWFwIiwiTGlua2VkVmFsdWVVdGlscyIsImRpZFdhcm5WYWx1ZUxpbmsiLCJkaWRXYXJuQ2hlY2tlZExpbmsiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUiLCJkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkIiwiZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCIsImRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQiLCJmb3JjZVVwZGF0ZUlmTW91bnRlZCIsImlzQ29udHJvbGxlZCIsInVzZXNDaGVja2VkIiwiZ2V0VmFsdWUiLCJnZXRDaGVja2VkIiwiaG9zdFByb3BzIiwiZGVmYXVsdENoZWNrZWQiLCJkZWZhdWx0VmFsdWUiLCJpbml0aWFsVmFsdWUiLCJpbml0aWFsQ2hlY2tlZCIsIm9uQ2hhbmdlIiwiY2hlY2tQcm9wVHlwZXMiLCJ2YWx1ZUxpbmsiLCJjaGVja2VkTGluayIsIl9oYW5kbGVDaGFuZ2UiLCJjb250cm9sbGVkIiwibmV3VmFsdWUiLCJleGVjdXRlT25DaGFuZ2UiLCJyb290Tm9kZSIsInF1ZXJ5Um9vdCIsImdyb3VwIiwicXVlcnlTZWxlY3RvckFsbCIsIm90aGVyTm9kZSIsIm90aGVySW5zdGFuY2UiLCJoYXNSZWFkT25seVZhbHVlIiwiX2Fzc2VydFNpbmdsZUxpbmsiLCJpbnB1dFByb3BzIiwiX2Fzc2VydFZhbHVlTGluayIsIl9hc3NlcnRDaGVja2VkTGluayIsInJlcXVlc3RDaGFuZ2UiLCJkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuIiwiZmxhdHRlbkNoaWxkcmVuIiwic2VsZWN0VmFsdWUiLCJzZWxlY3RQYXJlbnQiLCJnZXRTZWxlY3RWYWx1ZUNvbnRleHQiLCJ1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCIsInBlbmRpbmdVcGRhdGUiLCJ1cGRhdGVPcHRpb25zIiwiQm9vbGVhbiIsInZhbHVlUHJvcE5hbWVzIiwiY2hlY2tTZWxlY3RQcm9wVHlwZXMiLCJzZWxlY3RlZFZhbHVlIiwid2FzTXVsdGlwbGUiLCJkaWRXYXJuVmFsRGVmYXVsdFZhbCIsIlJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQiLCJSZWFjdEluc3RhbmNlTWFwIiwiUmVhY3RDaGlsZFJlY29uY2lsZXIiLCJtYWtlSW5zZXJ0TWFya3VwIiwibWFrZU1vdmUiLCJfbW91bnRJbmRleCIsIm1ha2VSZW1vdmUiLCJtYWtlU2V0TWFya3VwIiwibWFrZVRleHRDb250ZW50IiwicHJvY2Vzc1F1ZXVlIiwidXBkYXRlUXVldWUiLCJzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbiIsImdldERlYnVnSUQiLCJpbnRlcm5hbCIsIl9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbiIsIm5lc3RlZENoaWxkcmVuIiwic2VsZkRlYnVnSUQiLCJpbnN0YW50aWF0ZUNoaWxkcmVuIiwiX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbiIsInByZXZDaGlsZHJlbiIsIm5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIiwicmVtb3ZlZE5vZGVzIiwibmV4dE1hcmt1cCIsIl91cGRhdGVDaGlsZHJlbiIsIm5leHRJbmRleCIsIm5leHRNb3VudEluZGV4IiwibGFzdFBsYWNlZE5vZGUiLCJwcmV2Q2hpbGQiLCJfbW91bnRDaGlsZEF0SW5kZXgiLCJfdW5tb3VudENoaWxkIiwicmVuZGVyZWRDaGlsZHJlbiIsImNyZWF0ZUNoaWxkIiwiaW5qZWN0ZWQiLCJlbnZpcm9ubWVudCIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Iiwic2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQiLCJpbnN0YW50aWF0ZUNoaWxkIiwiY2hpbGRJbnN0YW5jZXMiLCJrZXlVbmlxdWUiLCJuZXN0ZWRDaGlsZE5vZGVzIiwiY2hpbGRJbnN0cyIsIm5leHRDaGlsZEluc3RhbmNlIiwibmV4dENoaWxkTW91bnRJbWFnZSIsInJlbmRlcmVkQ2hpbGQiLCJSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCIsIlJlYWN0RW1wdHlDb21wb25lbnQiLCJSZWFjdEhvc3RDb21wb25lbnQiLCJnZXROZXh0RGVidWdJRCIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciIsIl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IiwiaXNJbnRlcm5hbENvbXBvbmVudFR5cGUiLCJzaG91bGRIYXZlRGVidWdJRCIsImNyZWF0ZUludGVybmFsQ29tcG9uZW50IiwiZ2V0TmF0aXZlTm9kZSIsImNyZWF0ZUluc3RhbmNlRm9yVGV4dCIsIl9tb3VudEltYWdlIiwicHJldmVudEV4dGVuc2lvbnMiLCJSZWFjdE5vZGVUeXBlcyIsIkNvbXBvc2l0ZVR5cGVzIiwiSW1wdXJlQ2xhc3MiLCJQdXJlQ2xhc3MiLCJTdGF0ZWxlc3NGdW5jdGlvbmFsIiwiU3RhdGVsZXNzQ29tcG9uZW50Iiwid2FybklmSW52YWxpZEVsZW1lbnQiLCJzaG91bGRDb25zdHJ1Y3QiLCJpc1B1cmVDb21wb25lbnQiLCJtZWFzdXJlTGlmZUN5Y2xlUGVyZiIsIm5leHRNb3VudElEIiwiX2NvbXBvc2l0ZVR5cGUiLCJfaW5zdGFuY2UiLCJfcGVuZGluZ0VsZW1lbnQiLCJfcGVuZGluZ1N0YXRlUXVldWUiLCJfcGVuZGluZ1JlcGxhY2VTdGF0ZSIsIl9wZW5kaW5nRm9yY2VVcGRhdGUiLCJfcmVuZGVyZWROb2RlVHlwZSIsIl9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsIl90aGlzIiwicHVibGljUHJvcHMiLCJwdWJsaWNDb250ZXh0IiwiX3Byb2Nlc3NDb250ZXh0IiwiZ2V0VXBkYXRlUXVldWUiLCJkb0NvbnN0cnVjdCIsIl9jb25zdHJ1Y3RDb21wb25lbnQiLCJyZW5kZXJlZEVsZW1lbnQiLCJwcm9wc011dGF0ZWQiLCJjb21wb25lbnREaWRVbm1vdW50IiwidW5zdGFibGVfaGFuZGxlRXJyb3IiLCJwZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmciLCJwZXJmb3JtSW5pdGlhbE1vdW50IiwiX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lciIsIl9wcm9jZXNzUGVuZGluZ1N0YXRlIiwiX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCIsImdldFR5cGUiLCJFTVBUWSIsIl9wcm9jZXNzQ2hpbGRDb250ZXh0IiwiX21hc2tDb250ZXh0IiwibWFza2VkQ29udGV4dCIsImNvbnRleHROYW1lIiwiX2NoZWNrQ29udGV4dFR5cGVzIiwiY3VycmVudENvbnRleHQiLCJuZXh0Q29udGV4dCIsInByZXZDb250ZXh0IiwicHJldlBhcmVudEVsZW1lbnQiLCJuZXh0UGFyZW50RWxlbWVudCIsInByZXZVbm1hc2tlZENvbnRleHQiLCJuZXh0VW5tYXNrZWRDb250ZXh0Iiwid2lsbFJlY2VpdmUiLCJwcmV2UHJvcHMiLCJuZXh0U3RhdGUiLCJzaG91bGRVcGRhdGUiLCJfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZSIsInBhcnRpYWwiLCJ1bm1hc2tlZENvbnRleHQiLCJfdGhpczIiLCJoYXNDb21wb25lbnREaWRVcGRhdGUiLCJwcmV2U3RhdGUiLCJfdXBkYXRlUmVuZGVyZWRDb21wb25lbnQiLCJwcmV2Q29tcG9uZW50SW5zdGFuY2UiLCJwcmV2UmVuZGVyZWRFbGVtZW50IiwibmV4dFJlbmRlcmVkRWxlbWVudCIsIm9sZEhvc3ROb2RlIiwiX3JlcGxhY2VOb2RlV2l0aE1hcmt1cCIsIl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQiLCJwdWJsaWNDb21wb25lbnRJbnN0YW5jZSIsIkhPU1QiLCJDT01QT1NJVEUiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5c0IiLCJwcmV2RW1wdHkiLCJuZXh0RW1wdHkiLCJwcmV2VHlwZSIsIm5leHRUeXBlIiwiZW1wdHlDb21wb25lbnRGYWN0b3J5IiwiUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiIsImdlbmVyaWNDb21wb25lbnRDbGFzcyIsInRleHRDb21wb25lbnRDbGFzcyIsIlJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvbiIsImlzVGV4dENvbXBvbmVudCIsIm5leHREZWJ1Z0lEIiwiZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlIiwibm9vcENhbGxiYWNrUXVldWUiLCJSZWFjdFVwZGF0ZVF1ZXVlIiwiZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50IiwiZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlIiwidmFsaWRhdGVDYWxsYmFjayIsImVucXVldWVDYWxsYmFja0ludGVybmFsIiwiZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbCIsInNwZWNpYWxUYWdzIiwiaW5TY29wZVRhZ3MiLCJidXR0b25TY29wZVRhZ3MiLCJpbXBsaWVkRW5kVGFncyIsImVtcHR5QW5jZXN0b3JJbmZvIiwiZm9ybVRhZyIsImFUYWdJblNjb3BlIiwiYnV0dG9uVGFnSW5TY29wZSIsIm5vYnJUYWdJblNjb3BlIiwicFRhZ0luQnV0dG9uU2NvcGUiLCJsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nIiwiZGxJdGVtVGFnQXV0b2Nsb3NpbmciLCJvbGRJbmZvIiwiYW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZFdpdGhQYXJlbnQiLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZmluZE93bmVyU3RhY2siLCJyZXZlcnNlIiwiZGlkV2FybiIsImNoaWxkVGFnIiwiY2hpbGRUZXh0IiwiY2hpbGRJbnN0YW5jZSIsImludmFsaWRQYXJlbnQiLCJpbnZhbGlkQW5jZXN0b3IiLCJwcm9ibGVtYXRpYyIsImFuY2VzdG9yVGFnIiwiYW5jZXN0b3JJbnN0YW5jZSIsImFuY2VzdG9yT3duZXIiLCJjaGlsZE93bmVycyIsImFuY2VzdG9yT3duZXJzIiwibWluU3RhY2tMZW4iLCJkZWVwZXN0Q29tbW9uIiwiVU5LTk9XTiIsImNoaWxkT3duZXJOYW1lcyIsImFuY2VzdG9yT3duZXJOYW1lcyIsIm93bmVySW5mbyIsIndhcm5LZXkiLCJ0YWdEaXNwbGF5TmFtZSIsIndoaXRlc3BhY2VJbmZvIiwiaXNUYWdWYWxpZEluQ29udGV4dCIsImRvbUlEIiwiY3JlYXRlQ29tbWVudCIsImluc3RBIiwiaW5zdEIiLCJkZXB0aEEiLCJ0ZW1wQSIsImRlcHRoQiIsInRlbXBCIiwiZGVwdGgiLCJjb21tb24iLCJwYXRoRnJvbSIsInBhdGhUbyIsIl9zdHJpbmdUZXh0IiwiX2Nsb3NpbmdDb21tZW50IiwiX2NvbW1lbnROb2RlcyIsIm9wZW5pbmdWYWx1ZSIsImNsb3NpbmdWYWx1ZSIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJlc2NhcGVkVGV4dCIsIm5leHRUZXh0IiwibmV4dFN0cmluZ1RleHQiLCJjb21tZW50Tm9kZXMiLCJob3N0Tm9kZSIsIlJFU0VUX0JBVENIRURfVVBEQVRFUyIsIkZMVVNIX0JBVENIRURfVVBEQVRFUyIsIlJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbiIsImFscmVhZHlCYXRjaGluZ1VwZGF0ZXMiLCJFdmVudExpc3RlbmVyIiwiZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24iLCJmaW5kUGFyZW50IiwiY29udGFpbmVyIiwiVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwiYW5jZXN0b3JzIiwiaGFuZGxlVG9wTGV2ZWxJbXBsIiwiYW5jZXN0b3IiLCJfaGFuZGxlVG9wTGV2ZWwiLCJzY3JvbGxWYWx1ZU1vbml0b3IiLCJfZW5hYmxlZCIsImxpc3RlbiIsInJlZ2lzdGVyRGVmYXVsdCIsInNjcm9sbGFibGUiLCJwYWdlWE9mZnNldCIsInNjcm9sbExlZnQiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsIlJlYWN0SW5wdXRTZWxlY3Rpb24iLCJTRUxFQ1RJT05fUkVTVE9SQVRJT04iLCJnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbiIsInJlc3RvcmVTZWxlY3Rpb24iLCJFVkVOVF9TVVBQUkVTU0lPTiIsImN1cnJlbnRseUVuYWJsZWQiLCJwcmV2aW91c2x5RW5hYmxlZCIsIk9OX0RPTV9SRUFEWV9RVUVVRUlORyIsInJlYWN0TW91bnRSZWFkeSIsIlJlYWN0RE9NU2VsZWN0aW9uIiwiY29udGFpbnNOb2RlIiwiZ2V0QWN0aXZlRWxlbWVudCIsImlzSW5Eb2N1bWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImZvY3VzZWRFbGVtIiwic2VsZWN0aW9uUmFuZ2UiLCJnZXRTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsInNlbGVjdGlvbiIsInNlbGVjdGlvblN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwicmFuZ2UiLCJjcmVhdGVSYW5nZSIsInBhcmVudEVsZW1lbnQiLCJtb3ZlU3RhcnQiLCJtb3ZlRW5kIiwiZ2V0T2Zmc2V0cyIsIm9mZnNldHMiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjb2xsYXBzZSIsInNldE9mZnNldHMiLCJnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0IiwiaXNDb2xsYXBzZWQiLCJhbmNob3JOb2RlIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNPZmZzZXQiLCJnZXRJRU9mZnNldHMiLCJzZWxlY3RlZFJhbmdlIiwic2VsZWN0ZWRMZW5ndGgiLCJmcm9tU3RhcnQiLCJkdXBsaWNhdGUiLCJtb3ZlVG9FbGVtZW50VGV4dCIsInNldEVuZFBvaW50Iiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJnZXRNb2Rlcm5PZmZzZXRzIiwicmFuZ2VDb3VudCIsImN1cnJlbnRSYW5nZSIsImdldFJhbmdlQXQiLCJzdGFydENvbnRhaW5lciIsImVuZENvbnRhaW5lciIsImlzU2VsZWN0aW9uQ29sbGFwc2VkIiwicmFuZ2VMZW5ndGgiLCJ0ZW1wUmFuZ2UiLCJjbG9uZVJhbmdlIiwic2VsZWN0Tm9kZUNvbnRlbnRzIiwic2V0RW5kIiwiaXNUZW1wUmFuZ2VDb2xsYXBzZWQiLCJkZXRlY3Rpb25SYW5nZSIsInNldFN0YXJ0IiwiaXNCYWNrd2FyZCIsImNvbGxhcHNlZCIsInNldElFT2Zmc2V0cyIsInNldE1vZGVybk9mZnNldHMiLCJ0ZW1wIiwic3RhcnRNYXJrZXIiLCJlbmRNYXJrZXIiLCJvZmZzZXQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInVzZUlFT2Zmc2V0cyIsImdldExlYWZOb2RlIiwiZ2V0U2libGluZ05vZGUiLCJub2RlU3RhcnQiLCJub2RlRW5kIiwiaXNUZXh0Tm9kZSIsIm91dGVyTm9kZSIsImlubmVyTm9kZSIsImNvbnRhaW5zIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJOb2RlIiwiTlMiLCJ4bGluayIsInhtbCIsIkFUVFJTIiwiYWNjZW50SGVpZ2h0IiwiYWNjdW11bGF0ZSIsImFkZGl0aXZlIiwiYWxpZ25tZW50QmFzZWxpbmUiLCJhbGxvd1Jlb3JkZXIiLCJhbHBoYWJldGljIiwiYW1wbGl0dWRlIiwiYXJhYmljRm9ybSIsImFzY2VudCIsImF0dHJpYnV0ZVR5cGUiLCJhdXRvUmV2ZXJzZSIsImF6aW11dGgiLCJiYXNlRnJlcXVlbmN5IiwiYmFzZVByb2ZpbGUiLCJiYXNlbGluZVNoaWZ0IiwiYmJveCIsImJ5IiwiY2FsY01vZGUiLCJjYXBIZWlnaHQiLCJjbGlwIiwiY2xpcFJ1bGUiLCJjbGlwUGF0aFVuaXRzIiwiY29sb3JJbnRlcnBvbGF0aW9uIiwiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycyIsImNvbG9yUHJvZmlsZSIsImNvbG9yUmVuZGVyaW5nIiwiY29udGVudFNjcmlwdFR5cGUiLCJjb250ZW50U3R5bGVUeXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZUNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGl2aXNvciIsImRvbWluYW50QmFzZWxpbmUiLCJkdXIiLCJkeCIsImR5IiwiZWRnZU1vZGUiLCJlbGV2YXRpb24iLCJlbmFibGVCYWNrZ3JvdW5kIiwiZXhwb25lbnQiLCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkIiwiZmlsbCIsImZpbGxSdWxlIiwiZmlsdGVyUmVzIiwiZmlsdGVyVW5pdHMiLCJmbG9vZENvbG9yIiwiZm9jdXNhYmxlIiwiZm9udFNpemVBZGp1c3QiLCJmb250U3RyZXRjaCIsImZ4IiwiZnkiLCJnMSIsImcyIiwiZ2x5cGhOYW1lIiwiZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwiLCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWwiLCJnbHlwaFJlZiIsImdyYWRpZW50VHJhbnNmb3JtIiwiZ3JhZGllbnRVbml0cyIsImhhbmdpbmciLCJob3JpekFkdlgiLCJob3Jpek9yaWdpblgiLCJpZGVvZ3JhcGhpYyIsImltYWdlUmVuZGVyaW5nIiwiaW4yIiwiaW50ZXJjZXB0IiwiazEiLCJrMiIsImszIiwiazQiLCJrZXJuZWxNYXRyaXgiLCJrZXJuZWxVbml0TGVuZ3RoIiwia2VybmluZyIsImtleVBvaW50cyIsImtleVNwbGluZXMiLCJrZXlUaW1lcyIsImxlbmd0aEFkanVzdCIsImxldHRlclNwYWNpbmciLCJsaWdodGluZ0NvbG9yIiwibGltaXRpbmdDb25lQW5nbGUiLCJtYXJrZXJFbmQiLCJtYXJrZXJNaWQiLCJtYXJrZXJTdGFydCIsIm1hcmtlckhlaWdodCIsIm1hcmtlclVuaXRzIiwibWFya2VyV2lkdGgiLCJtYXNrQ29udGVudFVuaXRzIiwibWFza1VuaXRzIiwibWF0aGVtYXRpY2FsIiwibW9kZSIsIm51bU9jdGF2ZXMiLCJvcGVyYXRvciIsIm9yaWVudCIsIm9yaWVudGF0aW9uIiwib3ZlcmZsb3ciLCJvdmVybGluZVBvc2l0aW9uIiwib3ZlcmxpbmVUaGlja25lc3MiLCJwYWludE9yZGVyIiwicGFub3NlMSIsInBhdGhMZW5ndGgiLCJwYXR0ZXJuQ29udGVudFVuaXRzIiwicGF0dGVyblRyYW5zZm9ybSIsInBhdHRlcm5Vbml0cyIsInBvaW50ZXJFdmVudHMiLCJwb2ludHMiLCJwb2ludHNBdFgiLCJwb2ludHNBdFkiLCJwb2ludHNBdFoiLCJwcmVzZXJ2ZUFscGhhIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsInByaW1pdGl2ZVVuaXRzIiwicmFkaXVzIiwicmVmWCIsInJlZlkiLCJyZW5kZXJpbmdJbnRlbnQiLCJyZXBlYXRDb3VudCIsInJlcGVhdER1ciIsInJlcXVpcmVkRXh0ZW5zaW9ucyIsInJlcXVpcmVkRmVhdHVyZXMiLCJyZXN0YXJ0Iiwicm90YXRlIiwicngiLCJyeSIsInNjYWxlIiwic2VlZCIsInNoYXBlUmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJDb25zdGFudCIsInNwZWN1bGFyRXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZE1ldGhvZCIsInN0ZERldmlhdGlvbiIsInN0ZW1oIiwic3RlbXYiLCJzdGl0Y2hUaWxlcyIsInN0b3BDb2xvciIsInN0cmlrZXRocm91Z2hQb3NpdGlvbiIsInN0cmlrZXRocm91Z2hUaGlja25lc3MiLCJzdHJva2UiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJzdXJmYWNlU2NhbGUiLCJzeXN0ZW1MYW5ndWFnZSIsInRhYmxlVmFsdWVzIiwidGFyZ2V0WCIsInRhcmdldFkiLCJ0ZXh0QW5jaG9yIiwidGV4dERlY29yYXRpb24iLCJ0ZXh0UmVuZGVyaW5nIiwidGV4dExlbmd0aCIsInRyYW5zZm9ybSIsInUxIiwidTIiLCJ1bmRlcmxpbmVQb3NpdGlvbiIsInVuZGVybGluZVRoaWNrbmVzcyIsInVuaWNvZGUiLCJ1bmljb2RlQmlkaSIsInVuaWNvZGVSYW5nZSIsInVuaXRzUGVyRW0iLCJ2QWxwaGFiZXRpYyIsInZIYW5naW5nIiwidklkZW9ncmFwaGljIiwidk1hdGhlbWF0aWNhbCIsInZlY3RvckVmZmVjdCIsInZlcnRBZHZZIiwidmVydE9yaWdpblgiLCJ2ZXJ0T3JpZ2luWSIsInZpZXdCb3giLCJ2aWV3VGFyZ2V0IiwidmlzaWJpbGl0eSIsIndpZHRocyIsIndvcmRTcGFjaW5nIiwid3JpdGluZ01vZGUiLCJ4SGVpZ2h0IiwieDEiLCJ4MiIsInhDaGFubmVsU2VsZWN0b3IiLCJ4bGlua0FjdHVhdGUiLCJ4bGlua0FyY3JvbGUiLCJ4bGlua0hyZWYiLCJ4bGlua1JvbGUiLCJ4bGlua1Nob3ciLCJ4bGlua1RpdGxlIiwieGxpbmtUeXBlIiwieG1sQmFzZSIsInhtbG5zIiwieG1sbnNYbGluayIsInhtbExhbmciLCJ4bWxTcGFjZSIsInkxIiwieTIiLCJ5Q2hhbm5lbFNlbGVjdG9yIiwieiIsInpvb21BbmRQYW4iLCJza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQiLCJsYXN0U2VsZWN0aW9uIiwibW91c2VEb3duIiwiaGFzTGlzdGVuZXIiLCJib3VuZGluZ1RvcCIsImxlZnQiLCJib3VuZGluZ0xlZnQiLCJjb25zdHJ1Y3RTZWxlY3RFdmVudCIsImN1cnJlbnRTZWxlY3Rpb24iLCJTeW50aGV0aWNBbmltYXRpb25FdmVudCIsIlN5bnRoZXRpY0NsaXBib2FyZEV2ZW50IiwiU3ludGhldGljRm9jdXNFdmVudCIsIlN5bnRoZXRpY0tleWJvYXJkRXZlbnQiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJTeW50aGV0aWNUb3VjaEV2ZW50IiwiU3ludGhldGljVHJhbnNpdGlvbkV2ZW50IiwiU3ludGhldGljV2hlZWxFdmVudCIsImdldEV2ZW50Q2hhckNvZGUiLCJ0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWciLCJjYXBpdGFsaXplZEV2ZW50Iiwib25FdmVudCIsInRvcEV2ZW50Iiwib25DbGlja0xpc3RlbmVycyIsIkV2ZW50Q29uc3RydWN0b3IiLCJBbmltYXRpb25FdmVudEludGVyZmFjZSIsImFuaW1hdGlvbk5hbWUiLCJlbGFwc2VkVGltZSIsInBzZXVkb0VsZW1lbnQiLCJDbGlwYm9hcmRFdmVudEludGVyZmFjZSIsImNsaXBib2FyZERhdGEiLCJGb2N1c0V2ZW50SW50ZXJmYWNlIiwiZ2V0RXZlbnRLZXkiLCJLZXlib2FyZEV2ZW50SW50ZXJmYWNlIiwicmVwZWF0IiwibG9jYWxlIiwibm9ybWFsaXplS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJkYXRhVHJhbnNmZXIiLCJUb3VjaEV2ZW50SW50ZXJmYWNlIiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIlRyYW5zaXRpb25FdmVudEludGVyZmFjZSIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsIlJlYWN0RE9NQ29udGFpbmVySW5mbyIsIlJlYWN0RE9NRmVhdHVyZUZsYWdzIiwiUmVhY3RNYXJrdXBDaGVja3N1bSIsIlJPT1RfQVRUUl9OQU1FIiwiRE9DX05PREVfVFlQRSIsImluc3RhbmNlc0J5UmVhY3RSb290SUQiLCJmaXJzdERpZmZlcmVuY2VJbmRleCIsInN0cmluZzEiLCJzdHJpbmcyIiwibWluTGVuIiwiZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyIiwiaW50ZXJuYWxHZXRJRCIsIm1vdW50Q29tcG9uZW50SW50b05vZGUiLCJ3cmFwcGVySW5zdGFuY2UiLCJzaG91bGRSZXVzZU1hcmt1cCIsIndyYXBwZWRFbGVtZW50IiwiX21vdW50SW1hZ2VJbnRvTm9kZSIsImJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJ1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUiLCJoYXNOb25Sb290UmVhY3RDaGlsZCIsInJvb3RFbCIsIm5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlIiwiaXNSZWFjdE5vZGUiLCJpc1ZhbGlkQ29udGFpbmVyIiwiaGFzQXR0cmlidXRlIiwiZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyIiwicHJldkhvc3RJbnN0YW5jZSIsImdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyIiwidG9wTGV2ZWxSb290Q291bnRlciIsIlRvcExldmVsV3JhcHBlciIsInJvb3RJRCIsIl9pbnN0YW5jZXNCeVJlYWN0Um9vdElEIiwic2Nyb2xsTW9uaXRvciIsInJlbmRlckNhbGxiYWNrIiwiX3VwZGF0ZVJvb3RDb21wb25lbnQiLCJwcmV2Q29tcG9uZW50IiwiX3JlbmRlck5ld1Jvb3RDb21wb25lbnQiLCJ3cmFwcGVySUQiLCJwYXJlbnRDb21wb25lbnQiLCJfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJuZXh0V3JhcHBlZEVsZW1lbnQiLCJwcmV2V3JhcHBlZEVsZW1lbnQiLCJwdWJsaWNJbnN0IiwidXBkYXRlZENhbGxiYWNrIiwicmVhY3RSb290RWxlbWVudCIsImNvbnRhaW5lckhhc1JlYWN0TWFya3VwIiwiY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQiLCJyb290RWxlbWVudFNpYmxpbmciLCJpc0NvbnRhaW5lclJlYWN0Um9vdCIsInJvb3RFbGVtZW50IiwiY2FuUmV1c2VNYXJrdXAiLCJjaGVja3N1bSIsIkNIRUNLU1VNX0FUVFJfTkFNRSIsInJvb3RNYXJrdXAiLCJvdXRlckhUTUwiLCJub3JtYWxpemVkTWFya3VwIiwibm9ybWFsaXplciIsImNvbnRlbnREb2N1bWVudCIsImRpZmZJbmRleCIsImRpZmZlcmVuY2UiLCJ0b3BMZXZlbFdyYXBwZXIiLCJ1c2VGaWJlciIsImFkbGVyMzIiLCJUQUdfRU5EIiwiQ09NTUVOVF9TVEFSVCIsImFkZENoZWNrc3VtVG9NYXJrdXAiLCJleGlzdGluZ0NoZWNrc3VtIiwibWFya3VwQ2hlY2tzdW0iLCJNT0QiLCJjb21wb25lbnRPckVsZW1lbnQiLCJyZWFjdFByb3BzIiwid2FybmVkUHJvcGVydGllcyIsInZhbGlkYXRlUHJvcGVydHkiLCJzdGFuZGFyZE5hbWUiLCJ3YXJuVW5rbm93blByb3BlcnRpZXMiLCJ1bmtub3duUHJvcHMiLCJpc1ZhbGlkIiwidW5rbm93blByb3BTdHJpbmciLCJoYW5kbGVFbGVtZW50IiwiZGlkV2FyblZhbHVlTnVsbCIsInJBUklBIiwid2FybkludmFsaWRBUklBUHJvcHMiLCJpbnZhbGlkUHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSx3RENBQSxVREFBLG1CQ0FBLENEQUEsQ0NBQTtBQUNBLGlCREFBLG1CQ0FBLENEQUEsRUNBQTtBQUNBLGNEQUEsbUJDQUEsQ0RBQSxFQ0FBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSURBQSxJQ0FBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLGlCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxpQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsaUJBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFD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RDtBQUNEOztBQUVEbTJELHdCQUFxQjMzRCxPQUFyQixFQUE4QjFyQixPQUE5QjtBQUNEOztBQUVELEtBQUlveEIsMEJBQTBCO0FBQzVCakgsMkJBQXdCLGdDQUFVdUIsT0FBVixFQUFtQjFyQixPQUFuQixFQUE0QjtBQUNsRCxTQUFJM1gsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDMjZGLHFCQUFjeDNELE9BQWQsRUFBdUIxckIsT0FBdkI7QUFDRDtBQUNGLElBTDJCO0FBTTVCcXFCLDRCQUF5QixpQ0FBVXFCLE9BQVYsRUFBbUIxckIsT0FBbkIsRUFBNEI7QUFDbkQsU0FBSTNYLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzI2RixxQkFBY3gzRCxPQUFkLEVBQXVCMXJCLE9BQXZCO0FBQ0Q7QUFDRjtBQVYyQixFQUE5Qjs7QUFhQXpmLFFBQU9wSSxPQUFQLEdBQWlCaTVDLHVCQUFqQixDIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50P2h0dHA6LzAuMC4wLjA6MTIzNCIsInZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG52YXIgc29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpIHtcblx0Ly8gYGRvY3VtZW50LmN1cnJlbnRTY3JpcHRgIGlzIHRoZSBtb3N0IGFjY3VyYXRlIHdheSB0byBmaW5kIHRoZSBjdXJyZW50IHNjcmlwdCxcblx0Ly8gYnV0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzLlxuXHRpZihkb2N1bWVudC5jdXJyZW50U2NyaXB0KVxuXHRcdHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZShcInNyY1wiKTtcblx0Ly8gRmFsbCBiYWNrIHRvIGdldHRpbmcgYWxsIHNjcmlwdHMgaW4gdGhlIGRvY3VtZW50LlxuXHR2YXIgc2NyaXB0RWxlbWVudHMgPSBkb2N1bWVudC5zY3JpcHRzIHx8IFtdO1xuXHR2YXIgY3VycmVudFNjcmlwdCA9IHNjcmlwdEVsZW1lbnRzW3NjcmlwdEVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuXHRpZihjdXJyZW50U2NyaXB0KVxuXHRcdHJldHVybiBjdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZShcInNyY1wiKTtcblx0Ly8gRmFpbCBhcyB0aGVyZSB3YXMgbm8gc2NyaXB0IHRvIHVzZS5cblx0dGhyb3cgbmV3IEVycm9yKFwiW1dEU10gRmFpbGVkIHRvIGdldCBjdXJyZW50IHNjcmlwdCBzb3VyY2VcIik7XG59XG5cbnZhciB1cmxQYXJ0cztcbmlmKHR5cGVvZiBfX3Jlc291cmNlUXVlcnkgPT09IFwic3RyaW5nXCIgJiYgX19yZXNvdXJjZVF1ZXJ5KSB7XG5cdC8vIElmIHRoaXMgYnVuZGxlIGlzIGlubGluZWQsIHVzZSB0aGUgcmVzb3VyY2UgcXVlcnkgdG8gZ2V0IHRoZSBjb3JyZWN0IHVybC5cblx0dXJsUGFydHMgPSB1cmwucGFyc2UoX19yZXNvdXJjZVF1ZXJ5LnN1YnN0cigxKSk7XG59IGVsc2Uge1xuXHQvLyBFbHNlLCBnZXQgdGhlIHVybCBmcm9tIHRoZSA8c2NyaXB0PiB0aGlzIGZpbGUgd2FzIGNhbGxlZCB3aXRoLlxuXHR2YXIgc2NyaXB0SG9zdCA9IGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKTtcblx0c2NyaXB0SG9zdCA9IHNjcmlwdEhvc3QucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIlwiKTtcblx0dXJsUGFydHMgPSB1cmwucGFyc2UoKHNjcmlwdEhvc3QgPyBzY3JpcHRIb3N0IDogXCIvXCIpLCBmYWxzZSwgdHJ1ZSk7XG59XG5cbnZhciBob3QgPSBmYWxzZTtcbnZhciBpbml0aWFsID0gdHJ1ZTtcbnZhciBjdXJyZW50SGFzaCA9IFwiXCI7XG52YXIgbG9nTGV2ZWwgPSBcImluZm9cIjtcblxuZnVuY3Rpb24gbG9nKGxldmVsLCBtc2cpIHtcblx0aWYobG9nTGV2ZWwgPT09IFwiaW5mb1wiICYmIGxldmVsID09PSBcImluZm9cIilcblx0XHRyZXR1cm4gY29uc29sZS5sb2cobXNnKTtcblx0aWYoW1wiaW5mb1wiLCBcIndhcm5pbmdcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpXG5cdFx0cmV0dXJuIGNvbnNvbGUud2Fybihtc2cpO1xuXHRpZihbXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcImVycm9yXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwiZXJyb3JcIilcblx0XHRyZXR1cm4gY29uc29sZS5lcnJvcihtc2cpO1xufVxuXG52YXIgb25Tb2NrZXRNc2cgPSB7XG5cdGhvdDogZnVuY3Rpb24oKSB7XG5cdFx0aG90ID0gdHJ1ZTtcblx0XHRsb2coXCJpbmZvXCIsIFwiW1dEU10gSG90IE1vZHVsZSBSZXBsYWNlbWVudCBlbmFibGVkLlwiKTtcblx0fSxcblx0aW52YWxpZDogZnVuY3Rpb24oKSB7XG5cdFx0bG9nKFwiaW5mb1wiLCBcIltXRFNdIEFwcCB1cGRhdGVkLiBSZWNvbXBpbGluZy4uLlwiKTtcblx0fSxcblx0aGFzaDogZnVuY3Rpb24oaGFzaCkge1xuXHRcdGN1cnJlbnRIYXNoID0gaGFzaDtcblx0fSxcblx0XCJzdGlsbC1va1wiOiBmdW5jdGlvbigpIHtcblx0XHRsb2coXCJpbmZvXCIsIFwiW1dEU10gTm90aGluZyBjaGFuZ2VkLlwiKVxuXHR9LFxuXHRcImxvZy1sZXZlbFwiOiBmdW5jdGlvbihsZXZlbCkge1xuXHRcdGxvZ0xldmVsID0gbGV2ZWw7XG5cdH0sXG5cdG9rOiBmdW5jdGlvbigpIHtcblx0XHRpZihpbml0aWFsKSByZXR1cm4gaW5pdGlhbCA9IGZhbHNlO1xuXHRcdHJlbG9hZEFwcCgpO1xuXHR9LFxuXHR3YXJuaW5nczogZnVuY3Rpb24od2FybmluZ3MpIHtcblx0XHRsb2coXCJpbmZvXCIsIFwiW1dEU10gV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLlwiKTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgd2FybmluZ3MubGVuZ3RoOyBpKyspXG5cdFx0XHRjb25zb2xlLndhcm4oc3RyaXBBbnNpKHdhcm5pbmdzW2ldKSk7XG5cdFx0aWYoaW5pdGlhbCkgcmV0dXJuIGluaXRpYWwgPSBmYWxzZTtcblx0XHRyZWxvYWRBcHAoKTtcblx0fSxcblx0ZXJyb3JzOiBmdW5jdGlvbihlcnJvcnMpIHtcblx0XHRsb2coXCJpbmZvXCIsIFwiW1dEU10gRXJyb3JzIHdoaWxlIGNvbXBpbGluZy5cIik7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKylcblx0XHRcdGNvbnNvbGUuZXJyb3Ioc3RyaXBBbnNpKGVycm9yc1tpXSkpO1xuXHRcdGlmKGluaXRpYWwpIHJldHVybiBpbml0aWFsID0gZmFsc2U7XG5cdFx0cmVsb2FkQXBwKCk7XG5cdH0sXG5cdFwicHJveHktZXJyb3JcIjogZnVuY3Rpb24oZXJyb3JzKSB7XG5cdFx0bG9nKFwiaW5mb1wiLCBcIltXRFNdIFByb3h5IGVycm9yLlwiKTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSsrKVxuXHRcdFx0bG9nKFwiZXJyb3JcIiwgc3RyaXBBbnNpKGVycm9yc1tpXSkpO1xuXHRcdGlmKGluaXRpYWwpIHJldHVybiBpbml0aWFsID0gZmFsc2U7XG5cdH0sXG5cdGNsb3NlOiBmdW5jdGlvbigpIHtcblx0XHRsb2coXCJlcnJvclwiLCBcIltXRFNdIERpc2Nvbm5lY3RlZCFcIik7XG5cdH1cbn07XG5cbnZhciBob3N0bmFtZSA9IHVybFBhcnRzLmhvc3RuYW1lO1xudmFyIHByb3RvY29sID0gdXJsUGFydHMucHJvdG9jb2w7XG5cbmlmKHVybFBhcnRzLmhvc3RuYW1lID09PSAnMC4wLjAuMCcpIHtcblx0Ly8gd2h5IGRvIHdlIG5lZWQgdGhpcyBjaGVjaz9cblx0Ly8gaG9zdG5hbWUgbi9hIGZvciBmaWxlIHByb3RvY29sIChleGFtcGxlLCB3aGVuIHVzaW5nIGVsZWN0cm9uLCBpb25pYylcblx0Ly8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8zODRcblx0aWYod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICYmICEhfndpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwJykpIHtcblx0XHRob3N0bmFtZSA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcblx0fVxufVxuXG4vLyBgaG9zdG5hbWVgIGNhbiBiZSBlbXB0eSB3aGVuIHRoZSBzY3JpcHQgcGF0aCBpcyByZWxhdGl2ZS4gSW4gdGhhdCBjYXNlLCBzcGVjaWZ5aW5nXG4vLyBhIHByb3RvY29sIHdvdWxkIHJlc3VsdCBpbiBhbiBpbnZhbGlkIFVSTC5cbi8vIFdoZW4gaHR0cHMgaXMgdXNlZCBpbiB0aGUgYXBwLCBzZWN1cmUgd2Vic29ja2V0cyBhcmUgYWx3YXlzIG5lY2Vzc2FyeVxuLy8gYmVjYXVzZSB0aGUgYnJvd3NlciBkb2Vzbid0IGFjY2VwdCBub24tc2VjdXJlIHdlYnNvY2tldHMuXG5pZihob3N0bmFtZSAmJiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSBcImh0dHBzOlwiIHx8IHVybFBhcnRzLmhvc3RuYW1lID09PSAnMC4wLjAuMCcpKSB7XG5cdHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xufVxuXG52YXIgc29ja2V0VXJsID0gdXJsLmZvcm1hdCh7XG5cdHByb3RvY29sOiBwcm90b2NvbCxcblx0YXV0aDogdXJsUGFydHMuYXV0aCxcblx0aG9zdG5hbWU6IGhvc3RuYW1lLFxuXHRwb3J0OiAodXJsUGFydHMucG9ydCA9PT0gJzAnKSA/IHdpbmRvdy5sb2NhdGlvbi5wb3J0IDogdXJsUGFydHMucG9ydCxcblx0cGF0aG5hbWU6IHVybFBhcnRzLnBhdGggPT0gbnVsbCB8fCB1cmxQYXJ0cy5wYXRoID09PSAnLycgPyBcIi9zb2NranMtbm9kZVwiIDogdXJsUGFydHMucGF0aFxufSk7XG5cbnNvY2tldChzb2NrZXRVcmwsIG9uU29ja2V0TXNnKTtcblxuZnVuY3Rpb24gcmVsb2FkQXBwKCkge1xuXHRpZihob3QpIHtcblx0XHRsb2coXCJpbmZvXCIsIFwiW1dEU10gQXBwIGhvdCB1cGRhdGUuLi5cIik7XG5cdFx0d2luZG93LnBvc3RNZXNzYWdlKFwid2VicGFja0hvdFVwZGF0ZVwiICsgY3VycmVudEhhc2gsIFwiKlwiKTtcblx0fSBlbHNlIHtcblx0XHRsb2coXCJpbmZvXCIsIFwiW1dEU10gQXBwIHVwZGF0ZWQuIFJlbG9hZGluZy4uLlwiKTtcblx0XHR3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG5cdH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudD9odHRwOi8vMC4wLjAuMDoxMjM0XG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi91cmwvdXJsLmpzIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3VybC9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi91cmwvdXRpbC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9xdWVyeXN0cmluZy9pbmRleC5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcXVlcnlzdHJpbmcvZGVjb2RlLmpzIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcXVlcnlzdHJpbmcvZW5jb2RlLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnJlcGxhY2UoYW5zaVJlZ2V4LCAnJykgOiBzdHI7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zdHJpcC1hbnNpL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAvW1xcdTAwMWJcXHUwMDliXVtbKCkjOz9dKig/OlswLTldezEsNH0oPzo7WzAtOV17MCw0fSkqKT9bMC05QS1QUlpjZi1ucXJ5PT48XS9nO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5zaS1yZWdleC9pbmRleC5qcyIsInZhciBTb2NrSlMgPSByZXF1aXJlKFwic29ja2pzLWNsaWVudFwiKTtcblxudmFyIHJldHJpZXMgPSAwO1xudmFyIHNvY2sgPSBudWxsO1xuXG5mdW5jdGlvbiBzb2NrZXQodXJsLCBoYW5kbGVycykge1xuXHRzb2NrID0gbmV3IFNvY2tKUyh1cmwpO1xuXG5cdHNvY2sub25vcGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0cmllcyA9IDA7XG5cdH1cblxuXHRzb2NrLm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRpZihyZXRyaWVzID09PSAwKVxuXHRcdFx0aGFuZGxlcnMuY2xvc2UoKTtcblxuXHRcdC8vIFRyeSB0byByZWNvbm5lY3QuXG5cdFx0c29jayA9IG51bGw7XG5cblx0XHQvLyBBZnRlciAxMCByZXRyaWVzIHN0b3AgdHJ5aW5nLCB0byBwcmV2ZW50IGxvZ3NwYW0uXG5cdFx0aWYocmV0cmllcyA8PSAxMCkge1xuXHRcdFx0Ly8gRXhwb25lbnRpYWxseSBpbmNyZWFzZSB0aW1lb3V0IHRvIHJlY29ubmVjdC5cblx0XHRcdC8vIFJlc3BlY3RmdWxseSBjb3BpZWQgZnJvbSB0aGUgcGFja2FnZSBgZ290YC5cblx0XHRcdHZhciByZXRyeUluTXMgPSAxMDAwICogTWF0aC5wb3coMiwgcmV0cmllcykgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xuXHRcdFx0cmV0cmllcyArPSAxO1xuXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzb2NrZXQodXJsLCBoYW5kbGVycyk7XG5cdFx0XHR9LCByZXRyeUluTXMpO1xuXHRcdH1cblx0fTtcblxuXHRzb2NrLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcblx0XHQvLyBUaGlzIGFzc3VtZXMgdGhhdCBhbGwgZGF0YSBzZW50IHZpYSB0aGUgd2Vic29ja2V0IGlzIEpTT04uXG5cdFx0dmFyIG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcblx0XHRpZihoYW5kbGVyc1ttc2cudHlwZV0pXG5cdFx0XHRoYW5kbGVyc1ttc2cudHlwZV0obXNnLmRhdGEpO1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvY2tldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhbnNwb3J0TGlzdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0LWxpc3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21haW4nKSh0cmFuc3BvcnRMaXN0KTtcblxuLy8gVE9ETyBjYW4ndCBnZXQgcmlkIG9mIHRoaXMgdW50aWwgYWxsIHNlcnZlcnMgZG9cbmlmICgnX3NvY2tqc19vbmxvYWQnIGluIGdsb2JhbCkge1xuICBzZXRUaW1lb3V0KGdsb2JhbC5fc29ja2pzX29ubG9hZCwgMSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL2VudHJ5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy8gc3RyZWFtaW5nIHRyYW5zcG9ydHNcbiAgcmVxdWlyZSgnLi90cmFuc3BvcnQvd2Vic29ja2V0JylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJykpXG5cbiAgLy8gcG9sbGluZyB0cmFuc3BvcnRzXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmcnKVxuXTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0LWxpc3QuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgV2Vic29ja2V0RHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXIvd2Vic29ja2V0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OndlYnNvY2tldCcpO1xufVxuXG5mdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQodHJhbnNVcmwsIGlnbm9yZSwgb3B0aW9ucykge1xuICBpZiAoIVdlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICBkZWJ1ZygnY29uc3RydWN0b3InLCB0cmFuc1VybCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgJy93ZWJzb2NrZXQnKTtcbiAgaWYgKHVybC5zbGljZSgwLCA1KSA9PT0gJ2h0dHBzJykge1xuICAgIHVybCA9ICd3c3MnICsgdXJsLnNsaWNlKDUpO1xuICB9IGVsc2Uge1xuICAgIHVybCA9ICd3cycgKyB1cmwuc2xpY2UoNCk7XG4gIH1cbiAgdGhpcy51cmwgPSB1cmw7XG5cbiAgdGhpcy53cyA9IG5ldyBXZWJzb2NrZXREcml2ZXIodGhpcy51cmwsIFtdLCBvcHRpb25zKTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UgZXZlbnQnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGUuZGF0YSk7XG4gIH07XG4gIC8vIEZpcmVmb3ggaGFzIGFuIGludGVyZXN0aW5nIGJ1Zy4gSWYgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpc1xuICAvLyBjcmVhdGVkIGFmdGVyIG9udW5sb2FkLCBpdCBzdGF5cyBhbGl2ZSBldmVuIHdoZW4gdXNlclxuICAvLyBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlLiBJbiBzdWNoIHNpdHVhdGlvbiBsZXQncyBsaWUgLVxuICAvLyBsZXQncyBub3Qgb3BlbiB0aGUgd3MgY29ubmVjdGlvbiBhdCBhbGwuIFNlZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NvY2tqcy9zb2NranMtY2xpZW50L2lzc3Vlcy8yOFxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTYwODVcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCcpO1xuICAgIHNlbGYud3MuY2xvc2UoKTtcbiAgfSk7XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnY2xvc2UgZXZlbnQnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yIGV2ZW50JywgZSk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdXZWJTb2NrZXQgY29ubmVjdGlvbiBicm9rZW4nKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG59XG5cbmluaGVyaXRzKFdlYlNvY2tldFRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgbXNnID0gJ1snICsgZGF0YSArICddJztcbiAgZGVidWcoJ3NlbmQnLCBtc2cpO1xuICB0aGlzLndzLnNlbmQobXNnKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHZhciB3cyA9IHRoaXMud3M7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHdzKSB7XG4gICAgd3MuY2xvc2UoKTtcbiAgfVxufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgaWYgKHdzKSB7XG4gICAgd3Mub25tZXNzYWdlID0gd3Mub25jbG9zZSA9IHdzLm9uZXJyb3IgPSBudWxsO1xuICB9XG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy53cyA9IG51bGw7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnZW5hYmxlZCcpO1xuICByZXR1cm4gISFXZWJzb2NrZXREcml2ZXI7XG59O1xuV2ViU29ja2V0VHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnd2Vic29ja2V0JztcblxuLy8gSW4gdGhlb3J5LCB3cyBzaG91bGQgcmVxdWlyZSAxIHJvdW5kIHRyaXAuIEJ1dCBpbiBjaHJvbWUsIHRoaXMgaXNcbi8vIG5vdCB2ZXJ5IHN0YWJsZSBvdmVyIFNTTC4gTW9zdCBsaWtlbHkgYSB3cyBjb25uZWN0aW9uIHJlcXVpcmVzIGFcbi8vIHNlcGFyYXRlIFNTTCBjb25uZWN0aW9uLCBpbiB3aGljaCBjYXNlIDIgcm91bmQgdHJpcHMgYXJlIGFuXG4vLyBhYnNvbHV0ZSBtaW51bXVtLlxuV2ViU29ja2V0VHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFRyYW5zcG9ydDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3dlYnNvY2tldC5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxudmFyIG9uVW5sb2FkID0ge31cbiAgLCBhZnRlclVubG9hZCA9IGZhbHNlXG4gICAgLy8gZGV0ZWN0IGdvb2dsZSBjaHJvbWUgcGFja2FnZWQgYXBwcyBiZWNhdXNlIHRoZXkgZG9uJ3QgYWxsb3cgdGhlICd1bmxvYWQnIGV2ZW50XG4gICwgaXNDaHJvbWVQYWNrYWdlZEFwcCA9IGdsb2JhbC5jaHJvbWUgJiYgZ2xvYmFsLmNocm9tZS5hcHAgJiYgZ2xvYmFsLmNocm9tZS5hcHAucnVudGltZVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgICAgLy8gSUUgcXVpcmtzLlxuICAgICAgLy8gQWNjb3JkaW5nIHRvOiBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG4gICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cbiAgICAgIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCB1bmxvYWRBZGQ6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZWYgPSByYW5kb20uc3RyaW5nKDgpO1xuICAgIG9uVW5sb2FkW3JlZl0gPSBsaXN0ZW5lcjtcbiAgICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuXG4sIHVubG9hZERlbDogZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG5cbiwgdHJpZ2dlclVubG9hZENhbGxiYWNrczogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBvblVubG9hZFtyZWZdKCk7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB1bmxvYWRUcmlnZ2VyZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFmdGVyVW5sb2FkID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMudHJpZ2dlclVubG9hZENhbGxiYWNrcygpO1xufTtcblxuLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxuLy8gY2FuJ3QgdXNlIGBiZWZvcmV1bmxvYWRgIGFzIElFIGZpcmVzIGl0IG9uIGphdmFzY3JpcHQ6IGxpbmtzLlxuaWYgKCFpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy9ldmVudC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIGNyeXB0bzp0cnVlICovXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbi8vIFRoaXMgc3RyaW5nIGhhcyBsZW5ndGggMzIsIGEgcG93ZXIgb2YgMiwgc28gdGhlIG1vZHVsdXMgZG9lc24ndCBpbnRyb2R1Y2UgYVxuLy8gYmlhcy5cbnZhciBfcmFuZG9tU3RyaW5nQ2hhcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDUnO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZzogZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIG1heCA9IF9yYW5kb21TdHJpbmdDaGFycy5sZW5ndGg7XG4gICAgdmFyIGJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldC5wdXNoKF9yYW5kb21TdHJpbmdDaGFycy5zdWJzdHIoYnl0ZXNbaV0gJSBtYXgsIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgfVxuXG4sIG51bWJlcjogZnVuY3Rpb24obWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XG4gIH1cblxuLCBudW1iZXJTdHJpbmc6IGZ1bmN0aW9uKG1heCkge1xuICAgIHZhciB0ID0gKCcnICsgKG1heCAtIDEpKS5sZW5ndGg7XG4gICAgdmFyIHAgPSBuZXcgQXJyYXkodCArIDEpLmpvaW4oJzAnKTtcbiAgICByZXR1cm4gKHAgKyB0aGlzLm51bWJlcihtYXgpKS5zbGljZSgtdCk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL3JhbmRvbS5qcyIsIid1c2Ugc3RyaWN0JztcblxuaWYgKGdsb2JhbC5jcnlwdG8gJiYgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy9icm93c2VyLWNyeXB0by5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnVybCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0T3JpZ2luOiBmdW5jdGlvbih1cmwpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgVVJMKHVybCk7XG4gICAgaWYgKHAucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwb3J0ID0gcC5wb3J0O1xuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IChwLnByb3RvY29sID09PSAnaHR0cHM6JykgPyAnNDQzJyA6ICc4MCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAucHJvdG9jb2wgKyAnLy8nICsgcC5ob3N0bmFtZSArICc6JyArIHBvcnQ7XG4gIH1cblxuLCBpc09yaWdpbkVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuZ2V0T3JpZ2luKGEpID09PSB0aGlzLmdldE9yaWdpbihiKTtcbiAgICBkZWJ1Zygnc2FtZScsIGEsIGIsIHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4sIGlzU2NoZW1lRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gKGEuc3BsaXQoJzonKVswXSA9PT0gYi5zcGxpdCgnOicpWzBdKTtcbiAgfVxuXG4sIGFkZFBhdGg6IGZ1bmN0aW9uICh1cmwsIHBhdGgpIHtcbiAgICB2YXIgcXMgPSB1cmwuc3BsaXQoJz8nKTtcbiAgICByZXR1cm4gcXNbMF0gKyBwYXRoICsgKHFzWzFdID8gJz8nICsgcXNbMV0gOiAnJyk7XG4gIH1cblxuLCBhZGRRdWVyeTogZnVuY3Rpb24gKHVybCwgcSkge1xuICAgIHJldHVybiB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAoJz8nICsgcSkgOiAoJyYnICsgcSkpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy91cmwuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIGxvbGNhdGlvbiA9IHJlcXVpcmUoJy4vbG9sY2F0aW9uJylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcU1xcc10qKS9pO1xuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQrKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKTtcblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJyxcbiAgICBzbGFzaGVzOiAhIW1hdGNoWzJdLFxuICAgIHJlc3Q6IG1hdGNoWzNdXG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2NhdGlvbiBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHBhcnNlciBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBVUkwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIHJldHVybiBuZXcgVVJMKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbMl0gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblVSTC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgICB1cmwucGF0aG5hbWUgPSB2YWx1ZS5sZW5ndGggJiYgdmFsdWUuY2hhckF0KDApICE9PSAnLycgPyAnLycgKyB2YWx1ZSA6IHZhbHVlO1xuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuVVJMLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVVJMLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVSTC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVSTC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVSTDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdXJsLXBhcnNlL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlcXVpcmVzLXBvcnQvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzbGFzaGVzID0gL15bQS1aYS16XVtBLVphLXowLTkrLS5dKjpcXC9cXC8vO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfVxuICAsIFVSTDtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uIHx8IHt9O1xuICBVUkwgPSBVUkwgfHwgcmVxdWlyZSgnLi8nKTtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVSTCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVSTChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3VybC1wYXJzZS9sb2xjYXRpb24uanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8mXSspPT8oW14mXSopL2dcbiAgICAsIHJlc3VsdCA9IHt9XG4gICAgLCBwYXJ0O1xuXG4gIC8vXG4gIC8vIExpdHRsZSBuaWZ0eSBwYXJzaW5nIGhhY2ssIGxldmVyYWdlIHRoZSBmYWN0IHRoYXQgUmVnRXhwLmV4ZWMgaW5jcmVtZW50c1xuICAvLyB0aGUgbGFzdEluZGV4IHByb3BlcnR5IHNvIHdlIGNhbiBjb250aW51ZSBleGVjdXRpbmcgdGhpcyBsb29wIHVudGlsIHdlJ3ZlXG4gIC8vIHBhcnNlZCBhbGwgcmVzdWx0cy5cbiAgLy9cbiAgZm9yICg7XG4gICAgcGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KTtcbiAgICByZXN1bHRbZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRbMV0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0WzJdKVxuICApO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArJz0nKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHR5cGVvZiB3aW5kb3cucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50ICYmICdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgJiYgd2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICByZXR1cm4gZGVidWc7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9kZWJ1Zy9zcmMvZGVidWcuanMiLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwXG52YXIgbSA9IHMgKiA2MFxudmFyIGggPSBtICogNjBcbnZhciBkID0gaCAqIDI0XG52YXIgeSA9IGQgKiAzNjUuMjVcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWxcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgP1xuXHRcdFx0Zm10TG9uZyh2YWwpIDpcblx0XHRcdGZtdFNob3J0KHZhbClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArIEpTT04uc3RyaW5naWZ5KHZhbCkpXG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKVxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKClcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZFxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbVxuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogc1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCdcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCdcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSdcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncydcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnXG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnXG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWVcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L21zL2luZGV4LmpzIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnR0YXJnZXQnKVxuICA7XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcbn1cblxuaW5oZXJpdHMoRXZlbnRFbWl0dGVyLCBFdmVudFRhcmdldCk7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodHlwZSkge1xuICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub24odHlwZSwgZyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF07XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG4gIGZvciAodmFyIGFpID0gMTsgYWkgPCBsOyBhaSsrKSB7XG4gICAgYXJnc1thaSAtIDFdID0gYXJndW1lbnRzW2FpXTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi9ldmVudC9lbWl0dGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBTaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIERPTTIgRXZlbnRUYXJnZXQuXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0ge307XG59XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIShldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkge1xuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XG4gIH1cbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAvLyAjNFxuICBpZiAoYXJyLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICB9XG4gIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyO1xufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgaWYgKCFhcnIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlkeCA9IGFyci5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyLnNsaWNlKDAsIGlkeCkuY29uY2F0KGFyci5zbGljZShpZHggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnQgPSBhcmd1bWVudHNbMF07XG4gIHZhciB0ID0gZXZlbnQudHlwZTtcbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbZXZlbnRdIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IG1hdGNoIHRoZSByZWFsIGJlaGF2aW9yOyBwZXIgc3BlYywgb25mb28gZ2V0XG4gIC8vIHRoZWlyIHBsYWNlIGluIGxpbmUgZnJvbSB0aGUgL2ZpcnN0LyB0aW1lIHRoZXkncmUgc2V0IGZyb21cbiAgLy8gbm9uLW51bGwuIEFsdGhvdWdoIFdlYktpdCBidW1wcyBpdCB0byB0aGUgZW5kIGV2ZXJ5IHRpbWUgaXQnc1xuICAvLyBzZXQuXG4gIGlmICh0aGlzWydvbicgKyB0XSkge1xuICAgIHRoaXNbJ29uJyArIHRdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIGlmICh0IGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgIC8vIEdyYWIgYSByZWZlcmVuY2UgdG8gdGhlIGxpc3RlbmVycyBsaXN0LiByZW1vdmVFdmVudExpc3RlbmVyIG1heSBhbHRlciB0aGUgbGlzdC5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3RdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi9ldmVudC9ldmVudHRhcmdldC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIERyaXZlciA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcbmlmIChEcml2ZXIpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBXZWJTb2NrZXRCcm93c2VyRHJpdmVyKHVybCkge1xuXHRcdHJldHVybiBuZXcgRHJpdmVyKHVybCk7XG5cdH07XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHVuZGVmaW5lZDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2Jyb3dzZXIvd2Vic29ja2V0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWxzL2Jyb3dzZXInKVxuICA7XG5cbmZ1bmN0aW9uIFhoclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBzdXBwb3J0IHhoci1zdHJlYW1pbmcgIzYwXG4gIC8vIEJ1dCBpdCBtaWdodCBiZSBhYmxlIHRvICM5MlxuICBpZiAoYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXN0cmVhbWluZyc7XG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4vLyBTYWZhcmkgZ2V0cyBjb25mdXNlZCB3aGVuIGEgc3RyZWFtaW5nIGFqYXggcmVxdWVzdCBpcyBzdGFydGVkXG4vLyBiZWZvcmUgb25sb2FkLiBUaGlzIGNhdXNlcyB0aGUgbG9hZCBpbmRpY2F0b3IgdG8gc3BpbiBpbmRlZmluZXRlbHkuXG4vLyBPbmx5IHJlcXVpcmUgYm9keSB3aGVuIHVzZWQgaW4gYSBicm93c2VyXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQubmVlZEJvZHkgPSAhIWdsb2JhbC5kb2N1bWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9zZW5kZXItcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YWpheC1iYXNlZCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBkZWJ1ZygnY3JlYXRlIGFqYXggc2VuZGVyJywgdXJsLCBwYXlsb2FkKTtcbiAgICB2YXIgb3B0ID0ge307XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmhlYWRlcnMgPSB7J0NvbnRlbnQtdHlwZSc6ICd0ZXh0L3BsYWluJ307XG4gICAgfVxuICAgIHZhciBhamF4VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh1cmwsICcveGhyX3NlbmQnKTtcbiAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIGFqYXhVcmwsIHBheWxvYWQsIG9wdCk7XG4gICAgeG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgaWYgKHN0YXR1cyAhPT0gMjAwICYmIHN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2h0dHAgc3RhdHVzICcgKyBzdGF0dXMpKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2Fib3J0Jyk7XG4gICAgICB4by5jbG9zZSgpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XG4gICAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIEFqYXhCYXNlZFRyYW5zcG9ydCh0cmFuc1VybCwgdXJsU3VmZml4LCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCB1cmxTdWZmaXgsIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCksIFJlY2VpdmVyLCBBamF4T2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoQWpheEJhc2VkVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gQWpheEJhc2VkVHJhbnNwb3J0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvbGliL2FqYXgtYmFzZWQuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgQnVmZmVyZWRTZW5kZXIgPSByZXF1aXJlKCcuL2J1ZmZlcmVkLXNlbmRlcicpXG4gICwgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXItcmVjZWl2ZXInKTtcbn1cblxuZnVuY3Rpb24gU2VuZGVyUmVjZWl2ZXIodHJhbnNVcmwsIHVybFN1ZmZpeCwgc2VuZGVyRnVuYywgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgdmFyIHBvbGxVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCB1cmxTdWZmaXgpO1xuICBkZWJ1Zyhwb2xsVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBCdWZmZXJlZFNlbmRlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCBzZW5kZXJGdW5jKTtcblxuICB0aGlzLnBvbGwgPSBuZXcgUG9sbGluZyhSZWNlaXZlciwgcG9sbFVybCwgQWpheE9iamVjdCk7XG4gIHRoaXMucG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdwb2xsIG1lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuICB0aGlzLnBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygncG9sbCBjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgc2VsZi5wb2xsID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhTZW5kZXJSZWNlaXZlciwgQnVmZmVyZWRTZW5kZXIpO1xuXG5TZW5kZXJSZWNlaXZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gICAgdGhpcy5wb2xsID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXJSZWNlaXZlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2xpYi9zZW5kZXItcmVjZWl2ZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJ1ZmZlcmVkLXNlbmRlcicpO1xufVxuXG5mdW5jdGlvbiBCdWZmZXJlZFNlbmRlcih1cmwsIHNlbmRlcikge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICB0aGlzLnVybCA9IHVybDtcbn1cblxuaW5oZXJpdHMoQnVmZmVyZWRTZW5kZXIsIEV2ZW50RW1pdHRlcik7XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnNlbmRCdWZmZXIucHVzaChtZXNzYWdlKTtcbiAgaWYgKCF0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU2NoZWR1bGUoKTtcbiAgfVxufTtcblxuLy8gRm9yIHBvbGxpbmcgdHJhbnNwb3J0cyBpbiBhIHNpdHVhdGlvbiB3aGVuIGluIHRoZSBtZXNzYWdlIGNhbGxiYWNrLFxuLy8gbmV3IG1lc3NhZ2UgaXMgYmVpbmcgc2VuZC4gSWYgdGhlIHNlbmRpbmcgY29ubmVjdGlvbiB3YXMgc3RhcnRlZFxuLy8gYmVmb3JlIHJlY2VpdmluZyBvbmUsIGl0IGlzIHBvc3NpYmxlIHRvIHNhdHVyYXRlIHRoZSBuZXR3b3JrIGFuZFxuLy8gdGltZW91dCBkdWUgdG8gdGhlIGxhY2sgb2YgcmVjZWl2aW5nIHNvY2tldC4gVG8gYXZvaWQgdGhhdCB3ZSBkZWxheVxuLy8gc2VuZGluZyBtZXNzYWdlcyBieSBzb21lIHNtYWxsIHRpbWUsIGluIG9yZGVyIHRvIGxldCByZWNlaXZpbmdcbi8vIGNvbm5lY3Rpb24gYmUgc3RhcnRlZCBiZWZvcmVoYW5kLiBUaGlzIGlzIG9ubHkgYSBoYWxmbWVhc3VyZSBhbmRcbi8vIGRvZXMgbm90IGZpeCB0aGUgYmlnIHByb2JsZW0sIGJ1dCBpdCBkb2VzIG1ha2UgdGhlIHRlc3RzIGdvIG1vcmVcbi8vIHN0YWJsZSBvbiBzbG93IG5ldHdvcmtzLlxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZVdhaXQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZVdhaXQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHJlZjtcbiAgdGhpcy5zZW5kU3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdzZW5kU3RvcCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgfTtcbiAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBzZWxmLnNlbmRTY2hlZHVsZSgpO1xuICB9LCAyNSk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGUnLCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcGF5bG9hZCA9ICdbJyArIHRoaXMuc2VuZEJ1ZmZlci5qb2luKCcsJykgKyAnXSc7XG4gICAgdGhpcy5zZW5kU3RvcCA9IHRoaXMuc2VuZGVyKHRoaXMudXJsLCBwYXlsb2FkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUgfHwgMTAwNiwgJ1NlbmRpbmcgZXJyb3I6ICcgKyBlcnIpO1xuICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlbmRTY2hlZHVsZVdhaXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgfVxufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIGlmICh0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU3RvcCgpO1xuICAgIHRoaXMuc2VuZFN0b3AgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcmVkU2VuZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvbGliL2J1ZmZlcmVkLXNlbmRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cG9sbGluZycpO1xufVxuXG5mdW5jdGlvbiBQb2xsaW5nKFJlY2VpdmVyLCByZWNlaXZlVXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHJlY2VpdmVVcmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5SZWNlaXZlciA9IFJlY2VpdmVyO1xuICB0aGlzLnJlY2VpdmVVcmwgPSByZWNlaXZlVXJsO1xuICB0aGlzLkFqYXhPYmplY3QgPSBBamF4T2JqZWN0O1xuICB0aGlzLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG59XG5cbmluaGVyaXRzKFBvbGxpbmcsIEV2ZW50RW1pdHRlcik7XG5cblBvbGxpbmcucHJvdG90eXBlLl9zY2hlZHVsZVJlY2VpdmVyID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NoZWR1bGVSZWNlaXZlcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwb2xsID0gdGhpcy5wb2xsID0gbmV3IHRoaXMuUmVjZWl2ZXIodGhpcy5yZWNlaXZlVXJsLCB0aGlzLkFqYXhPYmplY3QpO1xuXG4gIHBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG5cbiAgcG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdjbG9zZScsIGNvZGUsIHJlYXNvbiwgc2VsZi5wb2xsSXNDbG9zaW5nKTtcbiAgICBzZWxmLnBvbGwgPSBwb2xsID0gbnVsbDtcblxuICAgIGlmICghc2VsZi5wb2xsSXNDbG9zaW5nKSB7XG4gICAgICBpZiAocmVhc29uID09PSAnbmV0d29yaycpIHtcbiAgICAgICAgc2VsZi5fc2NoZWR1bGVSZWNlaXZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUgfHwgMTAwNiwgcmVhc29uKTtcbiAgICAgICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuUG9sbGluZy5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMucG9sbElzQ2xvc2luZyA9IHRydWU7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvbGliL3BvbGxpbmcuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOnhocicpO1xufVxuXG5mdW5jdGlvbiBYaHJSZWNlaXZlcih1cmwsIEFqYXhPYmplY3QpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLmJ1ZmZlclBvc2l0aW9uID0gMDtcblxuICB0aGlzLnhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCB1cmwsIG51bGwpO1xuICB0aGlzLnhvLm9uKCdjaHVuaycsIHRoaXMuX2NodW5rSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB0ZXh0KTtcbiAgICBzZWxmLl9jaHVua0hhbmRsZXIoc3RhdHVzLCB0ZXh0KTtcbiAgICBzZWxmLnhvID0gbnVsbDtcbiAgICB2YXIgcmVhc29uID0gc3RhdHVzID09PSAyMDAgPyAnbmV0d29yaycgOiAncGVybWFuZW50JztcbiAgICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhoclJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NodW5rSGFuZGxlciA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICBkZWJ1ZygnX2NodW5rSGFuZGxlcicsIHN0YXR1cyk7XG4gIGlmIChzdGF0dXMgIT09IDIwMCB8fCAhdGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGlkeCA9IC0xOyA7IHRoaXMuYnVmZmVyUG9zaXRpb24gKz0gaWR4ICsgMSkge1xuICAgIHZhciBidWYgPSB0ZXh0LnNsaWNlKHRoaXMuYnVmZmVyUG9zaXRpb24pO1xuICAgIGlkeCA9IGJ1Zi5pbmRleE9mKCdcXG4nKTtcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBtc2cgPSBidWYuc2xpY2UoMCwgaWR4KTtcbiAgICBpZiAobXNnKSB7XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIH1cbiAgfVxufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAodGhpcy54bykge1xuICAgIHRoaXMueG8uY2xvc2UoKTtcbiAgICBkZWJ1ZygnY2xvc2UnKTtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ3VzZXInKTtcbiAgICB0aGlzLnhvID0gbnVsbDtcbiAgfVxuICB0aGlzLl9jbGVhbnVwKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclJlY2VpdmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvcmVjZWl2ZXIveGhyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgWGhyRHJpdmVyID0gcmVxdWlyZSgnLi4vZHJpdmVyL3hocicpXG4gIDtcblxuZnVuY3Rpb24gWEhSQ29yc09iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyk7XG59XG5cbmluaGVyaXRzKFhIUkNvcnNPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkNvcnNPYmplY3QuZW5hYmxlZCA9IFhockRyaXZlci5lbmFibGVkICYmIFhockRyaXZlci5zdXBwb3J0c0NPUlM7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSQ29yc09iamVjdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3NlbmRlci94aHItY29ycy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBYSFIgPSBnbG9iYWwuWE1MSHR0cFJlcXVlc3RcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJyb3dzZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIEFic3RyYWN0WEhST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhBYnN0cmFjdFhIUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIHRoaXMueGhyID0gbmV3IFhIUigpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICB9XG5cbiAgaWYgKCF0aGlzLnhocikge1xuICAgIGRlYnVnKCdubyB4aHInKTtcbiAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICdubyB4aHIgc3VwcG9ydCcpO1xuICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzZXZlcmFsIGJyb3dzZXJzIGNhY2hlIFBPU1RzXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xuXG4gIC8vIEV4cGxvcmVyIHRlbmRzIHRvIGtlZXAgY29ubmVjdGlvbiBvcGVuLCBldmVuIGFmdGVyIHRoZVxuICAvLyB0YWIgZ2V0cyBjbG9zZWQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzUyODBcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCBjbGVhbnVwJyk7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgfSk7XG4gIHRyeSB7XG4gICAgdGhpcy54aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgaWYgKHRoaXMudGltZW91dCAmJiAndGltZW91dCcgaW4gdGhpcy54aHIpIHtcbiAgICAgIHRoaXMueGhyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICB0aGlzLnhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVidWcoJ3hociB0aW1lb3V0Jyk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgICAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoJ2V4Y2VwdGlvbicsIGUpO1xuICAgIC8vIElFIHJhaXNlcyBhbiBleGNlcHRpb24gb24gd3JvbmcgcG9ydC5cbiAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoKCFvcHRzIHx8ICFvcHRzLm5vQ3JlZGVudGlhbHMpICYmIEFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUykge1xuICAgIGRlYnVnKCd3aXRoQ3JlZGVudGlhbHMnKTtcbiAgICAvLyBNb3ppbGxhIGRvY3Mgc2F5cyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9YTUxIdHRwUmVxdWVzdCA6XG4gICAgLy8gXCJUaGlzIG5ldmVyIGFmZmVjdHMgc2FtZS1zaXRlIHJlcXVlc3RzLlwiXG5cbiAgICB0aGlzLnhoci53aXRoQ3JlZGVudGlhbHMgPSAndHJ1ZSc7XG4gIH1cbiAgaWYgKG9wdHMgJiYgb3B0cy5oZWFkZXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdHMuaGVhZGVycykge1xuICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdHMuaGVhZGVyc1trZXldKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgIHZhciB4ID0gc2VsZi54aHI7XG4gICAgICB2YXIgdGV4dCwgc3RhdHVzO1xuICAgICAgZGVidWcoJ3JlYWR5U3RhdGUnLCB4LnJlYWR5U3RhdGUpO1xuICAgICAgc3dpdGNoICh4LnJlYWR5U3RhdGUpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgLy8gSUUgZG9lc24ndCBsaWtlIHBlZWtpbmcgaW50byByZXNwb25zZVRleHQgb3Igc3RhdHVzXG4gICAgICAgIC8vIG9uIE1pY3Jvc29mdC5YTUxIVFRQIGFuZCByZWFkeXN0YXRlPTNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgICB0ZXh0ID0geC5yZXNwb25zZVRleHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJRSBkb2VzIHJldHVybiByZWFkeXN0YXRlID09IDMgZm9yIDQwNCBhbnN3ZXJzLlxuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDAgJiYgdGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZWJ1ZygnY2h1bmsnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2NodW5rJywgc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElFIHJldHVybnMgdGhpcyBmb3IgYSBiYWQgcG9ydFxuICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2FhMzgzNzcwKHY9dnMuODUpLmFzcHhcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIwMDUgfHwgc3RhdHVzID09PSAxMjAyOSkge1xuICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBzZWxmLnhoci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH1cbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIGlmICghdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICAvLyBJRSBuZWVkcyB0aGlzIGZpZWxkIHRvIGJlIGEgZnVuY3Rpb25cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7fTtcbiAgaWYgKHRoaXMueGhyLm9udGltZW91dCkge1xuICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gIH1cblxuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54aHIgPSBudWxsO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhWEhSO1xuLy8gb3ZlcnJpZGUgWE1MSHR0cFJlcXVlc3QgZm9yIElFNi83XG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmICghQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCAmJiAoYXhvIGluIGdsb2JhbCkpIHtcbiAgZGVidWcoJ292ZXJyaWRpbmcgeG1saHR0cHJlcXVlc3QnKTtcbiAgWEhSID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW2F4b10oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFuZXcgWEhSKCk7XG59XG5cbnZhciBjb3JzID0gZmFsc2U7XG50cnkge1xuICBjb3JzID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhIUigpO1xufSBjYXRjaCAoaWdub3JlZCkge1xuICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG59XG5cbkFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUyA9IGNvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RYSFJPYmplY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9icm93c2VyL2Fic3RyYWN0LXhoci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkxvY2FsT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkIC8qLCBvcHRzICovKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCB7XG4gICAgbm9DcmVkZW50aWFsczogdHJ1ZVxuICB9KTtcbn1cblxuaW5oZXJpdHMoWEhSTG9jYWxPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJMb2NhbE9iamVjdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09wZXJhOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFsLm5hdmlnYXRvciAmJlxuICAgICAgL29wZXJhL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuLCBpc0tvbnF1ZXJvcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9rb25xdWVyb3IvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8vICMxODcgd3JhcCBkb2N1bWVudC5kb21haW4gaW4gdHJ5L2NhdGNoIGJlY2F1c2Ugb2YgV1A4IGZyb20gZmlsZTovLy9cbiwgaGFzRG9tYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbm9uLWJyb3dzZXIgY2xpZW50IGFsd2F5cyBoYXMgYSBkb21haW5cbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudC5kb21haW47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdXRpbHMvYnJvd3Nlci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuLy8gQWNjb3JkaW5nIHRvOlxuLy8gICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2NDE1MDcvZGV0ZWN0LWJyb3dzZXItc3VwcG9ydC1mb3ItY3Jvc3MtZG9tYWluLXhtbGh0dHByZXF1ZXN0c1xuLy8gICBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cblxuZnVuY3Rpb24gWGRyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLmNvb2tpZV9uZWVkZWQgfHwgaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBYRFJPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVTY2hlbWU7XG59O1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItc3RyZWFtaW5nJztcblhkclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQveGRyLXN0cmVhbWluZy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjp4ZHInKTtcbn1cblxuLy8gUmVmZXJlbmNlczpcbi8vICAgaHR0cDovL2FqYXhpYW4uY29tL2FyY2hpdmVzLzEwMC1saW5lLWFqYXgtd3JhcHBlclxuLy8gICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MyODgwNjAodj1WUy44NSkuYXNweFxuXG5mdW5jdGlvbiBYRFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoWERST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKCdfc3RhcnQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGRyID0gbmV3IGdsb2JhbC5YRG9tYWluUmVxdWVzdCgpO1xuICAvLyBJRSBjYWNoZXMgZXZlbiBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnRpbWVvdXQnKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdwcm9ncmVzcycsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuZW1pdCgnY2h1bmsnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICB9O1xuICB4ZHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2xvYWQnKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH07XG4gIHRoaXMueGRyID0geGRyO1xuICB0aGlzLnVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIC8vIEZhaWxzIHdpdGggQWNjZXNzRGVuaWVkIGlmIHBvcnQgbnVtYmVyIGlzIGJvZ3VzXG4gICAgdGhpcy54ZHIub3BlbihtZXRob2QsIHVybCk7XG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgdGhpcy54ZHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICB9XG4gICAgdGhpcy54ZHIuc2VuZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHRoaXMuX2Vycm9yKCk7XG4gIH1cbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICBkZWJ1ZygnY2xlYW51cCcsIGFib3J0KTtcbiAgaWYgKCF0aGlzLnhkcikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBldmVudFV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgdGhpcy54ZHIub250aW1lb3V0ID0gdGhpcy54ZHIub25lcnJvciA9IHRoaXMueGRyLm9ucHJvZ3Jlc3MgPSB0aGlzLnhkci5vbmxvYWQgPSBudWxsO1xuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54ZHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54ZHIgPSBudWxsO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbn07XG5cbi8vIElFIDgvOSBpZiB0aGUgcmVxdWVzdCB0YXJnZXQgdXNlcyB0aGUgc2FtZSBzY2hlbWUgLSAjNzlcblhEUk9iamVjdC5lbmFibGVkID0gISEoZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmIGJyb3dzZXIuaGFzRG9tYWluKCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhEUk9iamVjdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3NlbmRlci94ZHIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBFdmVudFNvdXJjZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9ldmVudHNvdXJjZScpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhRXZlbnRTb3VyY2VEcml2ZXI7XG59O1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2V2ZW50c291cmNlJztcbkV2ZW50U291cmNlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlVHJhbnNwb3J0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvZXZlbnRzb3VyY2UuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmV2ZW50c291cmNlJyk7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVzID0gdGhpcy5lcyA9IG5ldyBFdmVudFNvdXJjZURyaXZlcih1cmwpO1xuICBlcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRlY29kZVVSSShlLmRhdGEpKTtcbiAgfTtcbiAgZXMub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3InLCBlcy5yZWFkeVN0YXRlLCBlKTtcbiAgICAvLyBFUyBvbiByZWNvbm5lY3Rpb24gaGFzIHJlYWR5U3RhdGUgPSAwIG9yIDEuXG4gICAgLy8gb24gbmV0d29yayBlcnJvciBpdCdzIENMT1NFRCA9IDJcbiAgICB2YXIgcmVhc29uID0gKGVzLnJlYWR5U3RhdGUgIT09IDIgPyAnbmV0d29yaycgOiAncGVybWFuZW50Jyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKHJlYXNvbik7XG4gIH07XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICB2YXIgZXMgPSB0aGlzLmVzO1xuICBpZiAoZXMpIHtcbiAgICBlcy5vbm1lc3NhZ2UgPSBlcy5vbmVycm9yID0gbnVsbDtcbiAgICBlcy5jbG9zZSgpO1xuICAgIHRoaXMuZXMgPSBudWxsO1xuICB9XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgLy8gd2FpdGluZyBmb3IgRVMgY2xlYW51cC4gU2VlOlxuICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODkxNTVcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9LCAyMDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVJlY2VpdmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvcmVjZWl2ZXIvZXZlbnRzb3VyY2UuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5FdmVudFNvdXJjZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2Jyb3dzZXIvZXZlbnRzb3VyY2UuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9pZnJhbWUnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXG4gIGZ1bmN0aW9uIElmcmFtZVdyYXBUcmFuc3BvcnQodHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgICBJZnJhbWVUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICB9XG5cbiAgaW5oZXJpdHMoSWZyYW1lV3JhcFRyYW5zcG9ydCwgSWZyYW1lVHJhbnNwb3J0KTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbih1cmwsIGluZm8pIHtcbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpZnJhbWVJbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKHt9LCBpbmZvKTtcbiAgICBpZnJhbWVJbmZvLnNhbWVPcmlnaW4gPSB0cnVlO1xuICAgIHJldHVybiB0cmFuc3BvcnQuZW5hYmxlZChpZnJhbWVJbmZvKSAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xuICB9O1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtJyArIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgKyB0cmFuc3BvcnQucm91bmRUcmlwcyAtIDE7IC8vIGh0bWwsIGphdmFzY3JpcHQgKDIpICsgdHJhbnNwb3J0IC0gbm8gQ09SUyAoMSlcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmZhY2FkZVRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICByZXR1cm4gSWZyYW1lV3JhcFRyYW5zcG9ydDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAuanMiLCIndXNlIHN0cmljdCc7XG5cbi8vIEZldyBjb29sIHRyYW5zcG9ydHMgZG8gd29yayBvbmx5IGZvciBzYW1lLW9yaWdpbi4gSW4gb3JkZXIgdG8gbWFrZVxuLy8gdGhlbSB3b3JrIGNyb3NzLWRvbWFpbiB3ZSBzaGFsbCB1c2UgaWZyYW1lLCBzZXJ2ZWQgZnJvbSB0aGVcbi8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycyBoYXZlIGNhcGFiaWxpdGllcyB0byBjb21tdW5pY2F0ZSB3aXRoXG4vLyBjcm9zcyBkb21haW4gaWZyYW1lIHVzaW5nIHBvc3RNZXNzYWdlKCkuIEluIElFIGl0IHdhcyBpbXBsZW1lbnRlZFxuLy8gZnJvbSBJRSA4KywgYnV0IG9mIGNvdXJzZSwgSUUgZ290IHNvbWUgZGV0YWlscyB3cm9uZzpcbi8vICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzE5NzAxNSh2PVZTLjg1KS5hc3B4XG4vLyAgICBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vdmVyc2lvbicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvaWZyYW1lJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp0cmFuc3BvcnQ6aWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIElmcmFtZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gIGlmICghSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5vcmlnaW4gPSB1cmxVdGlscy5nZXRPcmlnaW4oYmFzZVVybCk7XG4gIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIHRoaXMudHJhbnNVcmwgPSB0cmFuc1VybDtcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMud2luZG93SWQgPSByYW5kb20uc3RyaW5nKDgpO1xuXG4gIHZhciBpZnJhbWVVcmwgPSB1cmxVdGlscy5hZGRQYXRoKGJhc2VVcmwsICcvaWZyYW1lLmh0bWwnKSArICcjJyArIHRoaXMud2luZG93SWQ7XG4gIGRlYnVnKHRyYW5zcG9ydCwgdHJhbnNVcmwsIGlmcmFtZVVybCk7XG5cbiAgdGhpcy5pZnJhbWVPYmogPSBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWUoaWZyYW1lVXJsLCBmdW5jdGlvbihyKSB7XG4gICAgZGVidWcoJ2VyciBjYWxsYmFjaycpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnVW5hYmxlIHRvIGxvYWQgYW4gaWZyYW1lICgnICsgciArICcpJyk7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcblxuICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5fbWVzc2FnZS5iaW5kKHRoaXMpO1xuICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG59XG5cbmluaGVyaXRzKElmcmFtZVRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgZXZlbnRVdGlscy5kZXRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xuICAgIHRyeSB7XG4gICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgdGhpcy5wb3N0TWVzc2FnZSgnYycpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLl9tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChlLm9yaWdpbiwgdGhpcy5vcmlnaW4pKSB7XG4gICAgZGVidWcoJ25vdCBzYW1lIG9yaWdpbicsIGUub3JpZ2luLCB0aGlzLm9yaWdpbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gIHRyeSB7XG4gICAgaWZyYW1lTWVzc2FnZSA9IEpTT04zLnBhcnNlKGUuZGF0YSk7XG4gIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSB0aGlzLndpbmRvd0lkKSB7XG4gICAgZGVidWcoJ21pc21hdGNoZWQgd2luZG93IGlkJywgaWZyYW1lTWVzc2FnZS53aW5kb3dJZCwgdGhpcy53aW5kb3dJZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgY2FzZSAncyc6XG4gICAgdGhpcy5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgLy8gd2luZG93IGdsb2JhbCBkZXBlbmRlbmN5XG4gICAgdGhpcy5wb3N0TWVzc2FnZSgncycsIEpTT04zLnN0cmluZ2lmeShbXG4gICAgICB2ZXJzaW9uXG4gICAgLCB0aGlzLnRyYW5zcG9ydFxuICAgICwgdGhpcy50cmFuc1VybFxuICAgICwgdGhpcy5iYXNlVXJsXG4gICAgXSkpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0JzpcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgIGJyZWFrO1xuICBjYXNlICdjJzpcbiAgICB2YXIgY2RhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGNkYXRhID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgY2RhdGFbMF0sIGNkYXRhWzFdKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgYnJlYWs7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gIGRlYnVnKCdwb3N0TWVzc2FnZScsIHR5cGUsIGRhdGEpO1xuICB0aGlzLmlmcmFtZU9iai5wb3N0KEpTT04zLnN0cmluZ2lmeSh7XG4gICAgd2luZG93SWQ6IHRoaXMud2luZG93SWRcbiAgLCB0eXBlOiB0eXBlXG4gICwgZGF0YTogZGF0YSB8fCAnJ1xuICB9KSwgdGhpcy5vcmlnaW4pO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnBvc3RNZXNzYWdlKCdtJywgbWVzc2FnZSk7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2lmcmFtZSc7XG5JZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSWZyYW1lVHJhbnNwb3J0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvaWZyYW1lLmpzIiwiLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9qc29uMy9saWIvanNvbjMuanMiLCJtb2R1bGUuZXhwb3J0cyA9ICcxLjEuMic7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3ZlcnNpb24uanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBldmVudFV0aWxzID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczppZnJhbWUnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdQcmVmaXg6ICdfanAnXG4sIGN1cnJlbnRXaW5kb3dJZDogbnVsbFxuXG4sIHBvbGx1dGVHbG9iYWxOYW1lc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKG1vZHVsZS5leHBvcnRzLldQcmVmaXggaW4gZ2xvYmFsKSkge1xuICAgICAgZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0ge307XG4gICAgfVxuICB9XG5cbiwgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICBpZiAoZ2xvYmFsLnBhcmVudCAhPT0gZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucGFyZW50LnBvc3RNZXNzYWdlKEpTT04zLnN0cmluZ2lmeSh7XG4gICAgICAgIHdpbmRvd0lkOiBtb2R1bGUuZXhwb3J0cy5jdXJyZW50V2luZG93SWRcbiAgICAgICwgdHlwZTogdHlwZVxuICAgICAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gICAgICB9KSwgJyonKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ0Nhbm5vdCBwb3N0TWVzc2FnZSwgbm8gcGFyZW50IHdpbmRvdy4nLCB0eXBlLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuLCBjcmVhdGVJZnJhbWU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCd1bmF0dGFjaCcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgLy8gRXhwbG9yZXIgaGFkIHByb2JsZW1zIHdpdGggdGhhdC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IG1ha2VzIGNocm9tZSBmaXJlIG9uYmVmb3JldW5sb2FkIGV2ZW50XG4gICAgICAgIC8vIHdpdGhpbiBpZnJhbWUuIFdpdGhvdXQgdGhlIHRpbWVvdXQgaXQgZ29lcyBzdHJhaWdodCB0b1xuICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIGVycik7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgZGVidWcoJ3Bvc3QnLCBtc2csIG9yaWdpbik7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgICAvLyBgb25sb2FkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNjcmlwdHMgb24gdGhlIGlmcmFtZSBhcmVcbiAgICAgIC8vIGV4ZWN1dGVkLiBHaXZlIGl0IGZldyBzZWNvbmRzIHRvIGFjdHVhbGx5IGxvYWQgc3R1ZmYuXG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb25lcnJvcignb25sb2FkIHRpbWVvdXQnKTtcbiAgICAgIH0sIDIwMDApO1xuICAgIH07XG4gICAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG5cbi8qIGVzbGludCBuby11bmRlZjogXCJvZmZcIiwgbmV3LWNhcDogXCJvZmZcIiAqL1xuLCBjcmVhdGVIdG1sZmlsZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG4gICAgdmFyIGRvYyA9IG5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciBpZnJhbWU7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICBpZnJhbWUgPSBkb2MgPSBudWxsO1xuICAgICAgICBDb2xsZWN0R2FyYmFnZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIHIpO1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2socik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2Mub3BlbigpO1xuICAgIGRvYy53cml0ZSgnPGh0bWw+PHMnICsgJ2NyaXB0PicgK1xuICAgICAgICAgICAgICAnZG9jdW1lbnQuZG9tYWluPVwiJyArIGdsb2JhbC5kb2N1bWVudC5kb21haW4gKyAnXCI7JyArXG4gICAgICAgICAgICAgICc8L3MnICsgJ2NyaXB0PjwvaHRtbD4nKTtcbiAgICBkb2MuY2xvc2UoKTtcbiAgICBkb2MucGFyZW50V2luZG93W21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0gZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdO1xuICAgIHZhciBjID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICAgIGlmcmFtZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBjLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9IGZhbHNlO1xuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAvLyBwb3N0TWVzc2FnZSBtaXNiZWhhdmVzIGluIGtvbnF1ZXJvciA0LjYuNSAtIHRoZSBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIHdpdGhcbiAgLy8gaHVnZSBkZWxheSwgb3Igbm90IGF0IGFsbC5cbiAgbW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9ICh0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgdHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ29iamVjdCcpICYmICghYnJvd3Nlci5pc0tvbnF1ZXJvcigpKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdXRpbHMvaWZyYW1lLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfVxuXG4sIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCF0aGlzLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciBzb3VyY2UsIHByb3A7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdXRpbHMvb2JqZWN0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSHRtbGZpbGVSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvaHRtbGZpbGUnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgO1xuXG5mdW5jdGlvbiBIdG1sRmlsZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2h0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlciwgWEhSTG9jYWxPYmplY3QpO1xufVxuXG5pbmhlcml0cyhIdG1sRmlsZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuSHRtbEZpbGVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgcmV0dXJuIEh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW47XG59O1xuXG5IdG1sRmlsZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2h0bWxmaWxlJztcbkh0bWxGaWxlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxGaWxlVHJhbnNwb3J0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvaHRtbGZpbGUuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpodG1sZmlsZScpO1xufVxuXG5mdW5jdGlvbiBIdG1sZmlsZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZnJhbWVVdGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGRlY29kZVVSSUNvbXBvbmVudChpZnJhbWVVdGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGRlYnVnKCd1c2luZyBodG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkKTtcbiAgdmFyIGNvbnN0cnVjdEZ1bmMgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA/XG4gICAgICBpZnJhbWVVdGlscy5jcmVhdGVIdG1sZmlsZSA6IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZTtcblxuICBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3N0YXJ0Jyk7XG4gICAgICBzZWxmLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICB9XG4gICwgbWVzc2FnZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICAgIH1cbiAgLCBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdG9wJyk7XG4gICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICBzZWxmLl9jbG9zZSgnbmV0d29yaycpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5pZnJhbWVPYmogPSBjb25zdHJ1Y3RGdW5jKHVybCwgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2NhbGxiYWNrJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKCdwZXJtYW5lbnQnKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEh0bWxmaWxlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdfY2xvc2UnLCByZWFzb24pO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gZmFsc2U7XG5cbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKGF4byBpbiBnbG9iYWwpIHtcbiAgdHJ5IHtcbiAgICBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9ICEhbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICB9XG59XG5cbkh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCA9IEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkIHx8IGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbGZpbGVSZWNlaXZlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3JlY2VpdmVyL2h0bWxmaWxlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gIDtcblxuZnVuY3Rpb24gWGhyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItcG9sbGluZyc7XG5YaHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJQb2xsaW5nVHJhbnNwb3J0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQveGhyLXBvbGxpbmcuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYZHJTdHJlYW1pbmdUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3hkci1zdHJlYW1pbmcnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuZnVuY3Rpb24gWGRyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1wb2xsaW5nJztcblhkclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclBvbGxpbmdUcmFuc3BvcnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC94ZHItcG9sbGluZy5qcyIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIHNpbXBsZXN0IGFuZCBtb3N0IHJvYnVzdCB0cmFuc3BvcnQsIHVzaW5nIHRoZSB3ZWxsLWtub3cgY3Jvc3Ncbi8vIGRvbWFpbiBoYWNrIC0gSlNPTlAuIFRoaXMgdHJhbnNwb3J0IGlzIHF1aXRlIGluZWZmaWNpZW50IC0gb25lXG4vLyBtZXNzYWdlIGNvdWxkIHVzZSB1cCB0byBvbmUgaHR0cCByZXF1ZXN0LiBCdXQgYXQgbGVhc3QgaXQgd29ya3MgYWxtb3N0XG4vLyBldmVyeXdoZXJlLlxuLy8gS25vd24gbGltaXRhdGlvbnM6XG4vLyAgIG8geW91IHdpbGwgZ2V0IGEgc3Bpbm5pbmcgY3Vyc29yXG4vLyAgIG8gZm9yIEtvbnF1ZXJvciBhIGR1bWIgdGltZXIgaXMgbmVlZGVkIHRvIGRldGVjdCBlcnJvcnNcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyLXJlY2VpdmVyJylcbiAgLCBKc29ucFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9qc29ucCcpXG4gICwganNvbnBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlci9qc29ucCcpXG4gIDtcblxuZnVuY3Rpb24gSnNvblBUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFKc29uUFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2pzb25wJywganNvbnBTZW5kZXIsIEpzb25wUmVjZWl2ZXIpO1xufVxuXG5pbmhlcml0cyhKc29uUFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5Kc29uUFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudDtcbn07XG5cbkpzb25QVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnanNvbnAtcG9sbGluZyc7XG5Kc29uUFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMTtcbkpzb25QVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29uUFRyYW5zcG9ydDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2pzb25wLXBvbGxpbmcuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6anNvbnAnKTtcbn1cblxuZnVuY3Rpb24gSnNvbnBSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB1dGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHZhciB1cmxXaXRoSWQgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBlbmNvZGVVUklDb21wb25lbnQodXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpO1xuICB0aGlzLl9jcmVhdGVTY3JpcHQodXJsV2l0aElkKTtcblxuICAvLyBGYWxsYmFjayBtb3N0bHkgZm9yIEtvbnF1ZXJvciAtIHN0dXBpZCB0aW1lciwgMzUgc2Vjb25kcyBzaGFsbCBiZSBwbGVudHkuXG4gIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5ICh0aW1lb3V0KScpKTtcbiAgfSwgSnNvbnBSZWNlaXZlci50aW1lb3V0KTtcbn1cblxuaW5oZXJpdHMoSnNvbnBSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmIChnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0pIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdKU09OUCB1c2VyIGFib3J0ZWQgcmVhZCcpO1xuICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICB0aGlzLl9hYm9ydChlcnIpO1xuICB9XG59O1xuXG5Kc29ucFJlY2VpdmVyLnRpbWVvdXQgPSAzNTAwMDtcbkpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0ID0gMTAwMDtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NhbGxiYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICBkZWJ1ZygnX2NhbGxiYWNrJywgZGF0YSk7XG4gIHRoaXMuX2NsZWFudXAoKTtcblxuICBpZiAodGhpcy5hYm9ydGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkYXRhKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgfVxuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ25ldHdvcmsnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9hYm9ydCA9IGZ1bmN0aW9uKGVycikge1xuICBkZWJ1ZygnX2Fib3J0JywgZXJyKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLmFib3J0aW5nID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIGVyci5jb2RlLCBlcnIubWVzc2FnZSk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgaWYgKHRoaXMuc2NyaXB0Mikge1xuICAgIHRoaXMuc2NyaXB0Mi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0Mik7XG4gICAgdGhpcy5zY3JpcHQyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQ7XG4gICAgLy8gVW5mb3J0dW5hdGVseSwgeW91IGNhbid0IHJlYWxseSBhYm9ydCBzY3JpcHQgbG9hZGluZyBvZlxuICAgIC8vIHRoZSBzY3JpcHQuXG4gICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gc2NyaXB0Lm9uZXJyb3IgPVxuICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9uY2xpY2sgPSBudWxsO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX3NjcmlwdEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NyaXB0RXJyb3InKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5lcnJvclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lcnJvclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBpZiAoIXNlbGYubG9hZGVkT2theSkge1xuICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9uZXJyb3IpJykpO1xuICAgIH1cbiAgfSwgSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uKHVybCkge1xuICBkZWJ1ZygnX2NyZWF0ZVNjcmlwdCcsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICB2YXIgc2NyaXB0MjsgIC8vIE9wZXJhIHN5bmNocm9ub3VzIGxvYWQgdHJpY2suXG5cbiAgc2NyaXB0LmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgc2NyaXB0LnNyYyA9IHVybDtcbiAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgc2NyaXB0LmNoYXJzZXQgPSAnVVRGLTgnO1xuICBzY3JpcHQub25lcnJvciA9IHRoaXMuX3NjcmlwdEVycm9yLmJpbmQodGhpcyk7XG4gIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ubG9hZCknKSk7XG4gIH07XG5cbiAgLy8gSUU5IGZpcmVzICdlcnJvcicgZXZlbnQgYWZ0ZXIgb25yZWFkeXN0YXRlY2hhbmdlIG9yIGJlZm9yZSwgaW4gcmFuZG9tIG9yZGVyLlxuICAvLyBVc2UgbG9hZGVkT2theSB0byBkZXRlcm1pbmUgaWYgYWN0dWFsbHkgZXJyb3JlZFxuICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIHNjcmlwdC5yZWFkeVN0YXRlKTtcbiAgICBpZiAoL2xvYWRlZHxjbG9zZWQvLnRlc3Qoc2NyaXB0LnJlYWR5U3RhdGUpKSB7XG4gICAgICBpZiAoc2NyaXB0ICYmIHNjcmlwdC5odG1sRm9yICYmIHNjcmlwdC5vbmNsaWNrKSB7XG4gICAgICAgIHNlbGYubG9hZGVkT2theSA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW4gSUUsIGFjdHVhbGx5IGV4ZWN1dGUgdGhlIHNjcmlwdC5cbiAgICAgICAgICBzY3JpcHQub25jbGljaygpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbnJlYWR5c3RhdGVjaGFuZ2UpJykpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gSUU6IGV2ZW50L2h0bWxGb3Ivb25jbGljayB0cmljay5cbiAgLy8gT25lIGNhbid0IHJlbHkgb24gcHJvcGVyIG9yZGVyIGZvciBvbnJlYWR5c3RhdGVjaGFuZ2UuIEluIG9yZGVyIHRvXG4gIC8vIG1ha2Ugc3VyZSwgc2V0IGEgJ2h0bWxGb3InIGFuZCAnZXZlbnQnIHByb3BlcnRpZXMsIHNvIHRoYXRcbiAgLy8gc2NyaXB0IGNvZGUgd2lsbCBiZSBpbnN0YWxsZWQgYXMgJ29uY2xpY2snIGhhbmRsZXIgZm9yIHRoZVxuICAvLyBzY3JpcHQgb2JqZWN0LiBMYXRlciwgb25yZWFkeXN0YXRlY2hhbmdlLCBtYW51YWxseSBleGVjdXRlIHRoaXNcbiAgLy8gY29kZS4gRkYgYW5kIENocm9tZSBkb2Vzbid0IHdvcmsgd2l0aCAnZXZlbnQnIGFuZCAnaHRtbEZvcidcbiAgLy8gc2V0LiBGb3IgcmVmZXJlbmNlIHNlZTpcbiAgLy8gICBodHRwOi8vamF1Ym91cmcubmV0LzIwMTAvMDcvbG9hZGluZy1zY3JpcHQtYXMtb25jbGljay1oYW5kbGVyLW9mLmh0bWxcbiAgLy8gQWxzbywgcmVhZCBvbiB0aGF0IGFib3V0IHNjcmlwdCBvcmRlcmluZzpcbiAgLy8gICBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvRHluYW1pY19TY3JpcHRfRXhlY3V0aW9uX09yZGVyXG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jID09PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAvLyBBY2NvcmRpbmcgdG8gbW96aWxsYSBkb2NzLCBpbiByZWNlbnQgYnJvd3NlcnMgc2NyaXB0LmFzeW5jIGRlZmF1bHRzXG4gICAgLy8gdG8gJ3RydWUnLCBzbyB3ZSBtYXkgdXNlIGl0IHRvIGRldGVjdCBhIGdvb2QgYnJvd3NlcjpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9IVE1ML0VsZW1lbnQvc2NyaXB0XG4gICAgaWYgKCFicm93c2VyLmlzT3BlcmEoKSkge1xuICAgICAgLy8gTmFpdmVseSBhc3N1bWUgd2UncmUgaW4gSUVcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkO1xuICAgICAgICBzY3JpcHQuZXZlbnQgPSAnb25jbGljayc7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9wZXJhLCBzZWNvbmQgc3luYyBzY3JpcHQgaGFja1xuICAgICAgc2NyaXB0MiA9IHRoaXMuc2NyaXB0MiA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdDIudGV4dCA9IFwidHJ5e3ZhciBhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1wiICsgc2NyaXB0LmlkICsgXCInKTsgaWYoYSlhLm9uZXJyb3IoKTt9Y2F0Y2goeCl7fTtcIjtcbiAgICAgIHNjcmlwdC5hc3luYyA9IHNjcmlwdDIuYXN5bmMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBoZWFkID0gZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbiAgaWYgKHNjcmlwdDIpIHtcbiAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQyLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25wUmVjZWl2ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9yZWNlaXZlci9qc29ucC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOmpzb25wJyk7XG59XG5cbnZhciBmb3JtLCBhcmVhO1xuXG5mdW5jdGlvbiBjcmVhdGVJZnJhbWUoaWQpIHtcbiAgZGVidWcoJ2NyZWF0ZUlmcmFtZScsIGlkKTtcbiAgdHJ5IHtcbiAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICByZXR1cm4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxpZnJhbWUgbmFtZT1cIicgKyBpZCArICdcIj4nKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLm5hbWUgPSBpZDtcbiAgICByZXR1cm4gaWZyYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcm0oKSB7XG4gIGRlYnVnKCdjcmVhdGVGb3JtJyk7XG4gIGZvcm0gPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgZm9ybS5lbmN0eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gIGZvcm0uYWNjZXB0Q2hhcnNldCA9ICdVVEYtOCc7XG5cbiAgYXJlYSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICBhcmVhLm5hbWUgPSAnZCc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG5cbiAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICBkZWJ1Zyh1cmwsIHBheWxvYWQpO1xuICBpZiAoIWZvcm0pIHtcbiAgICBjcmVhdGVGb3JtKCk7XG4gIH1cbiAgdmFyIGlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgZm9ybS50YXJnZXQgPSBpZDtcbiAgZm9ybS5hY3Rpb24gPSB1cmxVdGlscy5hZGRRdWVyeSh1cmxVdGlscy5hZGRQYXRoKHVybCwgJy9qc29ucF9zZW5kJyksICdpPScgKyBpZCk7XG5cbiAgdmFyIGlmcmFtZSA9IGNyZWF0ZUlmcmFtZShpZCk7XG4gIGlmcmFtZS5pZCA9IGlkO1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gIHRyeSB7XG4gICAgYXJlYS52YWx1ZSA9IHBheWxvYWQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBzZXJpb3VzbHkgYnJva2VuIGJyb3dzZXJzIGdldCBoZXJlXG4gIH1cbiAgZm9ybS5zdWJtaXQoKTtcblxuICB2YXIgY29tcGxldGVkID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgZGVidWcoJ2NvbXBsZXRlZCcsIGlkLCBlcnIpO1xuICAgIGlmICghaWZyYW1lLm9uZXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmVycm9yID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgLy8gT3BlcmEgbWluaSBkb2Vzbid0IGxpa2UgaWYgd2UgR0MgaWZyYW1lXG4gICAgLy8gaW1tZWRpYXRlbHksIHRodXMgdGhpcyB0aW1lb3V0LlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnY2xlYW5pbmcgdXAnLCBpZCk7XG4gICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICB9LCA1MDApO1xuICAgIGFyZWEudmFsdWUgPSAnJztcbiAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGlmIHRoZSBpZnJhbWUgc3VjY2VlZGVkIG9yXG4gICAgLy8gZmFpbGVkIHRvIHN1Ym1pdCBvdXIgZm9ybS5cbiAgICBjYWxsYmFjayhlcnIpO1xuICB9O1xuICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgaWQsIGlmcmFtZS5yZWFkeVN0YXRlLCBlKTtcbiAgICBpZiAoaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdhYm9ydGVkJywgaWQpO1xuICAgIGNvbXBsZXRlZChuZXcgRXJyb3IoJ0Fib3J0ZWQnKSk7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvc2VuZGVyL2pzb25wLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3NoaW1zJyk7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4vdXRpbHMvcmFuZG9tJylcbiAgLCBlc2NhcGUgPSByZXF1aXJlKCcuL3V0aWxzL2VzY2FwZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIHRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdXRpbHMvdHJhbnNwb3J0JylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJylcbiAgLCBsb2cgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50JylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnR0YXJnZXQnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICAsIENsb3NlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2Nsb3NlJylcbiAgLCBUcmFuc3BvcnRNZXNzYWdlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L3RyYW5zLW1lc3NhZ2UnKVxuICAsIEluZm9SZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDptYWluJyk7XG59XG5cbnZhciB0cmFuc3BvcnRzO1xuXG4vLyBmb2xsb3cgY29uc3RydWN0b3Igc3RlcHMgZGVmaW5lZCBhdCBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJzb2NrZXRzLyN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuZnVuY3Rpb24gU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrSlMpKSB7XG4gICAgcmV0dXJuIG5ldyBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdTb2NrSlM6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudFwiKTtcbiAgfVxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xuICB0aGlzLmV4dGVuc2lvbnMgPSAnJztcbiAgdGhpcy5wcm90b2NvbCA9ICcnO1xuXG4gIC8vIG5vbi1zdGFuZGFyZCBleHRlbnNpb25cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QpIHtcbiAgICBsb2cud2FybihcIidwcm90b2NvbHNfd2hpdGVsaXN0JyBpcyBERVBSRUNBVEVELiBVc2UgJ3RyYW5zcG9ydHMnIGluc3RlYWQuXCIpO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QgPSBvcHRpb25zLnRyYW5zcG9ydHM7XG4gIHRoaXMuX3RyYW5zcG9ydE9wdGlvbnMgPSBvcHRpb25zLnRyYW5zcG9ydE9wdGlvbnMgfHwge307XG5cbiAgdmFyIHNlc3Npb25JZCA9IG9wdGlvbnMuc2Vzc2lvbklkIHx8IDg7XG4gIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmRvbS5zdHJpbmcoc2Vzc2lvbklkKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lmIHNlc3Npb25JZCBpcyB1c2VkIGluIHRoZSBvcHRpb25zLCBpdCBuZWVkcyB0byBiZSBhIG51bWJlciBvciBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXIgfHwgcmFuZG9tLm51bWJlclN0cmluZygxMDAwKTtcblxuICAvLyBTdGVwIDEgb2YgV1Mgc3BlYyAtIHBhcnNlIGFuZCB2YWxpZGF0ZSB0aGUgdXJsLiBJc3N1ZSAjOFxuICB2YXIgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICBpZiAoIXBhcnNlZFVybC5ob3N0IHx8ICFwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMICdcIiArIHVybCArIFwiJyBpcyBpbnZhbGlkXCIpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5oYXNoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUaGUgVVJMIG11c3Qgbm90IGNvbnRhaW4gYSBmcmFnbWVudCcpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCdzIHNjaGVtZSBtdXN0IGJlIGVpdGhlciAnaHR0cDonIG9yICdodHRwczonLiAnXCIgKyBwYXJzZWRVcmwucHJvdG9jb2wgKyBcIicgaXMgbm90IGFsbG93ZWQuXCIpO1xuICB9XG5cbiAgdmFyIHNlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIC8vIFN0ZXAgMiAtIGRvbid0IGFsbG93IHNlY3VyZSBvcmlnaW4gd2l0aCBhbiBpbnNlY3VyZSBwcm90b2NvbFxuICBpZiAobG9jLnByb3RvY29sID09PSAnaHR0cHMnICYmICFzZWN1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyaXR5RXJyb3I6IEFuIGluc2VjdXJlIFNvY2tKUyBjb25uZWN0aW9uIG1heSBub3QgYmUgaW5pdGlhdGVkIGZyb20gYSBwYWdlIGxvYWRlZCBvdmVyIEhUVFBTJyk7XG4gIH1cblxuICAvLyBTdGVwIDMgLSBjaGVjayBwb3J0IGFjY2VzcyAtIG5vIG5lZWQgaGVyZVxuICAvLyBTdGVwIDQgLSBwYXJzZSBwcm90b2NvbHMgYXJndW1lbnRcbiAgaWYgKCFwcm90b2NvbHMpIHtcbiAgICBwcm90b2NvbHMgPSBbXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gIH1cblxuICAvLyBTdGVwIDUgLSBjaGVjayBwcm90b2NvbHMgYXJndW1lbnRcbiAgdmFyIHNvcnRlZFByb3RvY29scyA9IHByb3RvY29scy5zb3J0KCk7XG4gIHNvcnRlZFByb3RvY29scy5mb3JFYWNoKGZ1bmN0aW9uKHByb3RvLCBpKSB7XG4gICAgaWYgKCFwcm90bykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCAoc29ydGVkUHJvdG9jb2xzLmxlbmd0aCAtIDEpICYmIHByb3RvID09PSBzb3J0ZWRQcm90b2NvbHNbaSArIDFdKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGR1cGxpY2F0ZWQuXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3RlcCA2IC0gY29udmVydCBvcmlnaW5cbiAgdmFyIG8gPSB1cmxVdGlscy5nZXRPcmlnaW4obG9jLmhyZWYpO1xuICB0aGlzLl9vcmlnaW4gPSBvID8gby50b0xvd2VyQ2FzZSgpIDogbnVsbDtcblxuICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoXG4gIHBhcnNlZFVybC5zZXQoJ3BhdGhuYW1lJywgcGFyc2VkVXJsLnBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgJycpKTtcblxuICAvLyBzdG9yZSB0aGUgc2FuaXRpemVkIHVybFxuICB0aGlzLnVybCA9IHBhcnNlZFVybC5ocmVmO1xuICBkZWJ1ZygndXNpbmcgdXJsJywgdGhpcy51cmwpO1xuXG4gIC8vIFN0ZXAgNyAtIHN0YXJ0IGNvbm5lY3Rpb24gaW4gYmFja2dyb3VuZFxuICAvLyBvYnRhaW4gc2VydmVyIGluZm9cbiAgLy8gaHR0cDovL3NvY2tqcy5naXRodWIuaW8vc29ja2pzLXByb3RvY29sL3NvY2tqcy1wcm90b2NvbC0wLjMuMy5odG1sI3NlY3Rpb24tMjZcbiAgdGhpcy5fdXJsSW5mbyA9IHtcbiAgICBudWxsT3JpZ2luOiAhYnJvd3Nlci5oYXNEb21haW4oKVxuICAsIHNhbWVPcmlnaW46IHVybFV0aWxzLmlzT3JpZ2luRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICAsIHNhbWVTY2hlbWU6IHVybFV0aWxzLmlzU2NoZW1lRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICB9O1xuXG4gIHRoaXMuX2lyID0gbmV3IEluZm9SZWNlaXZlcih0aGlzLnVybCwgdGhpcy5fdXJsSW5mbyk7XG4gIHRoaXMuX2lyLm9uY2UoJ2ZpbmlzaCcsIHRoaXMuX3JlY2VpdmVJbmZvLmJpbmQodGhpcykpO1xufVxuXG5pbmhlcml0cyhTb2NrSlMsIEV2ZW50VGFyZ2V0KTtcblxuZnVuY3Rpb24gdXNlclNldENvZGUoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAwMCB8fCAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSk7XG59XG5cblNvY2tKUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgLy8gU3RlcCAxXG4gIGlmIChjb2RlICYmICF1c2VyU2V0Q29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZEFjY2Vzc0Vycm9yOiBJbnZhbGlkIGNvZGUnKTtcbiAgfVxuICAvLyBTdGVwIDIuNCBzdGF0ZXMgdGhlIG1heCBpcyAxMjMgYnl0ZXMsIGJ1dCB3ZSBhcmUganVzdCBjaGVja2luZyBsZW5ndGhcbiAgaWYgKHJlYXNvbiAmJiByZWFzb24ubGVuZ3RoID4gMTIzKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdyZWFzb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgbGVuZ3RoJyk7XG4gIH1cblxuICAvLyBTdGVwIDMuMVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0lORyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPIGxvb2sgYXQgZG9jcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGlzXG4gIHZhciB3YXNDbGVhbiA9IHRydWU7XG4gIHRoaXMuX2Nsb3NlKGNvZGUgfHwgMTAwMCwgcmVhc29uIHx8ICdOb3JtYWwgY2xvc3VyZScsIHdhc0NsZWFuKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gIzEzIC0gY29udmVydCBhbnl0aGluZyBub24tc3RyaW5nIHRvIHN0cmluZ1xuICAvLyBUT0RPIHRoaXMgY3VycmVudGx5IHR1cm5zIG9iamVjdHMgaW50byBbb2JqZWN0IE9iamVjdF1cbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBUaGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgeWV0Jyk7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZXNjYXBlLnF1b3RlKGRhdGEpKTtcbn07XG5cblNvY2tKUy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cblNvY2tKUy5DT05ORUNUSU5HID0gMDtcblNvY2tKUy5PUEVOID0gMTtcblNvY2tKUy5DTE9TSU5HID0gMjtcblNvY2tKUy5DTE9TRUQgPSAzO1xuXG5Tb2NrSlMucHJvdG90eXBlLl9yZWNlaXZlSW5mbyA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICBkZWJ1ZygnX3JlY2VpdmVJbmZvJywgcnR0KTtcbiAgdGhpcy5faXIgPSBudWxsO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aGlzLl9jbG9zZSgxMDAyLCAnQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXN0YWJsaXNoIGEgcm91bmQtdHJpcCB0aW1lb3V0IChSVE8pIGJhc2VkIG9uIHRoZVxuICAvLyByb3VuZC10cmlwIHRpbWUgKFJUVClcbiAgdGhpcy5fcnRvID0gdGhpcy5jb3VudFJUTyhydHQpO1xuICAvLyBhbGxvdyBzZXJ2ZXIgdG8gb3ZlcnJpZGUgdXJsIHVzZWQgZm9yIHRoZSBhY3R1YWwgdHJhbnNwb3J0XG4gIHRoaXMuX3RyYW5zVXJsID0gaW5mby5iYXNlX3VybCA/IGluZm8uYmFzZV91cmwgOiB0aGlzLnVybDtcbiAgaW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZChpbmZvLCB0aGlzLl91cmxJbmZvKTtcbiAgZGVidWcoJ2luZm8nLCBpbmZvKTtcbiAgLy8gZGV0ZXJtaW5lIGxpc3Qgb2YgZGVzaXJlZCBhbmQgc3VwcG9ydGVkIHRyYW5zcG9ydHNcbiAgdmFyIGVuYWJsZWRUcmFuc3BvcnRzID0gdHJhbnNwb3J0cy5maWx0ZXJUb0VuYWJsZWQodGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbyk7XG4gIHRoaXMuX3RyYW5zcG9ydHMgPSBlbmFibGVkVHJhbnNwb3J0cy5tYWluO1xuICBkZWJ1Zyh0aGlzLl90cmFuc3BvcnRzLmxlbmd0aCArICcgZW5hYmxlZCB0cmFuc3BvcnRzJyk7XG5cbiAgdGhpcy5fY29ubmVjdCgpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCk7IFRyYW5zcG9ydDsgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpKSB7XG4gICAgZGVidWcoJ2F0dGVtcHQnLCBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSk7XG4gICAgaWYgKFRyYW5zcG9ydC5uZWVkQm9keSkge1xuICAgICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSB8fFxuICAgICAgICAgICh0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdpbnRlcmFjdGl2ZScpKSB7XG4gICAgICAgIGRlYnVnKCd3YWl0aW5nIGZvciBib2R5Jyk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydHMudW5zaGlmdChUcmFuc3BvcnQpO1xuICAgICAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgdGhpcy5fY29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aW1lb3V0IGJhc2VkIG9uIFJUTyBhbmQgcm91bmQgdHJpcHMuIERlZmF1bHQgdG8gNXNcbiAgICB2YXIgdGltZW91dE1zID0gKHRoaXMuX3J0byAqIFRyYW5zcG9ydC5yb3VuZFRyaXBzKSB8fCA1MDAwO1xuICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dC5iaW5kKHRoaXMpLCB0aW1lb3V0TXMpO1xuICAgIGRlYnVnKCd1c2luZyB0aW1lb3V0JywgdGltZW91dE1zKTtcblxuICAgIHZhciB0cmFuc3BvcnRVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRoaXMuX3RyYW5zVXJsLCAnLycgKyB0aGlzLl9zZXJ2ZXIgKyAnLycgKyB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCgpKTtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX3RyYW5zcG9ydE9wdGlvbnNbVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWVdO1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgdXJsJywgdHJhbnNwb3J0VXJsKTtcbiAgICB2YXIgdHJhbnNwb3J0T2JqID0gbmV3IFRyYW5zcG9ydCh0cmFuc3BvcnRVcmwsIHRoaXMuX3RyYW5zVXJsLCBvcHRpb25zKTtcbiAgICB0cmFuc3BvcnRPYmoub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai5vbmNlKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai50cmFuc3BvcnROYW1lID0gVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0T2JqO1xuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2Nsb3NlKDIwMDAsICdBbGwgdHJhbnNwb3J0cyBmYWlsZWQnLCBmYWxzZSk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0VGltZW91dCcpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX3RyYW5zcG9ydENsb3NlKDIwMDcsICdUcmFuc3BvcnQgdGltZWQgb3V0Jyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgZGVidWcoJ190cmFuc3BvcnRNZXNzYWdlJywgbXNnKTtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB0eXBlID0gbXNnLnNsaWNlKDAsIDEpXG4gICAgLCBjb250ZW50ID0gbXNnLnNsaWNlKDEpXG4gICAgLCBwYXlsb2FkXG4gICAgO1xuXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBtZXNzYWdlcyB0aGF0IGRvbid0IG5lZWQgYSBwYXlsb2FkXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ28nOlxuICAgICAgdGhpcy5fb3BlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaGVhcnRiZWF0JykpO1xuICAgICAgZGVidWcoJ2hlYXJ0YmVhdCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHBheWxvYWQgPSBKU09OMy5wYXJzZShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVidWcoJ2VtcHR5IHBheWxvYWQnLCBjb250ZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdhJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgIHBheWxvYWQuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgZGVidWcoJ21lc3NhZ2UnLCBzZWxmLnRyYW5zcG9ydCwgcCk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ20nOlxuICAgICAgZGVidWcoJ21lc3NhZ2UnLCB0aGlzLnRyYW5zcG9ydCwgcGF5bG9hZCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFRyYW5zcG9ydE1lc3NhZ2VFdmVudChwYXlsb2FkKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0Q2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uKTtcbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdXNlclNldENvZGUoY29kZSkgJiYgY29kZSAhPT0gMjAwMCAmJiB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhpcy5fY29ubmVjdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2Nsb3NlKGNvZGUsIHJlYXNvbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfb3BlbicsIHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLk9QRU47XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdvcGVuJykpO1xuICAgIGRlYnVnKCdjb25uZWN0ZWQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHNlcnZlciBtaWdodCBoYXZlIGJlZW4gcmVzdGFydGVkLCBhbmQgbG9zdCB0cmFjayBvZiBvdXJcbiAgICAvLyBjb25uZWN0aW9uLlxuICAgIHRoaXMuX2Nsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uLCB3YXNDbGVhbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4sIHRoaXMucmVhZHlTdGF0ZSk7XG4gIHZhciBmb3JjZUZhaWwgPSBmYWxzZTtcblxuICBpZiAodGhpcy5faXIpIHtcbiAgICBmb3JjZUZhaWwgPSB0cnVlO1xuICAgIHRoaXMuX2lyLmNsb3NlKCk7XG4gICAgdGhpcy5faXIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBTb2NrSlMgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQnKTtcbiAgfVxuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TSU5HO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TRUQ7XG5cbiAgICBpZiAoZm9yY2VGYWlsKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKTtcbiAgICB9XG5cbiAgICB2YXIgZSA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScpO1xuICAgIGUud2FzQ2xlYW4gPSB3YXNDbGVhbiB8fCBmYWxzZTtcbiAgICBlLmNvZGUgPSBjb2RlIHx8IDEwMDA7XG4gICAgZS5yZWFzb24gPSByZWFzb247XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgdGhpcy5vbm1lc3NhZ2UgPSB0aGlzLm9uY2xvc2UgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgIGRlYnVnKCdkaXNjb25uZWN0ZWQnKTtcbiAgfS5iaW5kKHRoaXMpLCAwKTtcbn07XG5cbi8vIFNlZTogaHR0cDovL3d3dy5lcmcuYWJkbi5hYy51ay9+Z2Vycml0L2RjY3Avbm90ZXMvY2NpZDIvcnRvX2VzdGltYXRvci9cbi8vIGFuZCBSRkMgMjk4OC5cblNvY2tKUy5wcm90b3R5cGUuY291bnRSVE8gPSBmdW5jdGlvbihydHQpIHtcbiAgLy8gSW4gYSBsb2NhbCBlbnZpcm9ubWVudCwgd2hlbiB1c2luZyBJRTgvOSBhbmQgdGhlIGBqc29ucC1wb2xsaW5nYFxuICAvLyB0cmFuc3BvcnQgdGhlIHRpbWUgbmVlZGVkIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gKHRoZSB0aW1lIHRoYXQgcGFzc1xuICAvLyBmcm9tIHRoZSBvcGVuaW5nIG9mIHRoZSB0cmFuc3BvcnQgdG8gdGhlIGNhbGwgb2YgYF9kaXNwYXRjaE9wZW5gKSBpc1xuICAvLyBhcm91bmQgMjAwbXNlYyAodGhlIGxvd2VyIGJvdW5kIHVzZWQgaW4gdGhlIGFydGljbGUgYWJvdmUpIGFuZCB0aGlzXG4gIC8vIGNhdXNlcyBzcHVyaW91cyB0aW1lb3V0cy4gRm9yIHRoaXMgcmVhc29uIHdlIGNhbGN1bGF0ZSBhIHZhbHVlIHNsaWdodGx5XG4gIC8vIGxhcmdlciB0aGFuIHRoYXQgdXNlZCBpbiB0aGUgYXJ0aWNsZS5cbiAgaWYgKHJ0dCA+IDEwMCkge1xuICAgIHJldHVybiA0ICogcnR0OyAvLyBydG8gPiA0MDBtc2VjXG4gIH1cbiAgcmV0dXJuIDMwMCArIHJ0dDsgLy8gMzAwbXNlYyA8IHJ0byA8PSA0MDBtc2VjXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgdHJhbnNwb3J0cyA9IHRyYW5zcG9ydChhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmVxdWlyZSgnLi9pZnJhbWUtYm9vdHN0cmFwJykoU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmV0dXJuIFNvY2tKUztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL21haW4uanMiLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoganNjczogZGlzYWJsZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBwdWxsZWQgc3BlY2lmaWMgc2hpbXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcbnZhciBhcnJheV9zbGljZSA9IEFycmF5UHJvdG90eXBlLnNsaWNlO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIE9iamVjdFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcblxuLy8gRGVmaW5lIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4vLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxudmFyIGRlZmluZVByb3BlcnR5O1xuaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxuICAgICAgICB9KTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgfTtcbn1cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgICAgIGlmIChPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciB0b09iamVjdCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyBvICsgJyB0byBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdChvKTtcbn07XG5cbi8vXG4vLyBVdGlsXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSA5LjRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxuLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuXG5mdW5jdGlvbiB0b0ludGVnZXIobnVtKSB7XG4gICAgdmFyIG4gPSArbnVtO1xuICAgIGlmIChuICE9PSBuKSB7IC8vIGlzTmFOXG4gICAgICAgIG4gPSAwO1xuICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XG4gICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgcmV0dXJuIHggPj4+IDA7XG59XG5cbi8vXG4vLyBGdW5jdGlvblxuLy8gPT09PT09PT1cbi8vXG5cbi8vIEVTLTUgMTUuMy40LjVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG5cbmZ1bmN0aW9uIEVtcHR5KCkge31cblxuZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQodGhhdCkgeyAvLyAubGVuZ3RoIGlzIDFcbiAgICAgICAgLy8gMS4gTGV0IFRhcmdldCBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgIC8vIDIuIElmIElzQ2FsbGFibGUoVGFyZ2V0KSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBMZXQgQSBiZSBhIG5ldyAocG9zc2libHkgZW1wdHkpIGludGVybmFsIGxpc3Qgb2YgYWxsIG9mIHRoZVxuICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxuICAgICAgICAvLyBYWFggc2xpY2VkQXJncyB3aWxsIHN0YW5kIGluIGZvciBcIkFcIiBpZiB1c2VkXG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3Igbm9ybWFsIGNhbGxcbiAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAvLyAxMS4gU2V0IHRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdGhlIHN0YW5kYXJkXG4gICAgICAgIC8vICAgYnVpbHQtaW4gRnVuY3Rpb24gcHJvdG90eXBlIG9iamVjdCBhcyBzcGVjaWZpZWQgaW4gMTUuMy4zLjEuXG4gICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMS5cbiAgICAgICAgLy8gMTMuIFNldCB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgIC8vIDE0LiBTZXQgdGhlIFtbSGFzSW5zdGFuY2VdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjMuXG4gICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAvLyBGIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXVxuICAgICAgICAgICAgICAgIC8vICAgaW50ZXJuYWwgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxuICAgICAgICAgICAgICAgIC8vICAgVHlwZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBtZXRob2Qgb2YgdGFyZ2V0IHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4xIFtbQ2FsbF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LCBGLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHZhbHVlIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gTGV0IGJvdW5kVGhpcyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRUaGlzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyAgIG9mIHRhcmdldCBwcm92aWRpbmcgYm91bmRUaGlzIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxuICAgICAgICAgICAgICAgIC8vICAgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIC8vIGVxdWl2OiB0YXJnZXQuY2FsbCh0aGlzLCAuLi5ib3VuZEFyZ3MsIC4uLmFyZ3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDE1LiBJZiB0aGUgW1tDbGFzc11dIGludGVybmFsIHByb3BlcnR5IG9mIFRhcmdldCBpcyBcIkZ1bmN0aW9uXCIsIHRoZW5cbiAgICAgICAgLy8gICAgIGEuIExldCBMIGJlIHRoZSBsZW5ndGggcHJvcGVydHkgb2YgVGFyZ2V0IG1pbnVzIHRoZSBsZW5ndGggb2YgQS5cbiAgICAgICAgLy8gICAgIGIuIFNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIGVpdGhlciAwIG9yIEwsIHdoaWNoZXZlciBpc1xuICAgICAgICAvLyAgICAgICBsYXJnZXIuXG4gICAgICAgIC8vIDE2LiBFbHNlIHNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIDAuXG5cbiAgICAgICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cbiAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAvLyB3YXkgdG8gc2V0IHRoZSBsZW5ndGggcHJvcGVydHkgb2YgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIENvbnRlbnQgU2VjdXJpdHkgUG9saWNpZXMgZW5hYmxlZCAoQ2hyb21lIGV4dGVuc2lvbnMsXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIgaW4gYWxsIG9mIHRoZXNlIGVudmlyb25tZW50cyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBleGlzdHNcbiAgICAgICAgLy8gYW5kIHNvIHRoaXMgY29kZSB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxuICAgICAgICB2YXIgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZGFuZ2xpbmcgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE4LiBTZXQgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdHJ1ZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE5LiBMZXQgdGhyb3dlciBiZSB0aGUgW1tUaHJvd1R5cGVFcnJvcl1dIGZ1bmN0aW9uIE9iamVjdCAoMTMuMi4zKS5cbiAgICAgICAgLy8gMjAuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgLy8gICB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSwgYW5kXG4gICAgICAgIC8vICAgZmFsc2UuXG4gICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImFyZ3VtZW50c1wiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsXG4gICAgICAgIC8vICAgW1tTZXRdXTogdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sXG4gICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XG4gICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgIC8vIFtbU2NvcGVdXSBpbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxuXG4gICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cbn0pO1xuXG4vL1xuLy8gQXJyYXlcbi8vID09PT09XG4vL1xuXG4vLyBFUzUgMTUuNC4zLjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuMy4yXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5LCB7IGlzQXJyYXk6IGlzQXJyYXkgfSk7XG5cblxudmFyIGJveGVkU3RyaW5nID0gT2JqZWN0KCdhJyk7XG52YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbnZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgLy8gQ2hlY2sgbm9kZSAwLjYuMjEgYnVnIHdoZXJlIHRoaXJkIHBhcmFtZXRlciBpcyBub3QgYm94ZWRcbiAgICB2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG4gICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmNhbGwoJ2ZvbycsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JykgeyBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgICB9LCAneCcpO1xuICAgIH1cbiAgICByZXR1cm4gISFtZXRob2QgJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZnVuIC8qLCB0aGlzcCovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogb2JqZWN0LFxuICAgICAgICAgICAgdGhpc3AgPSBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBUT0RPIG1lc3NhZ2VcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xuXG4vLyBFUzUgMTUuNC40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcbnZhciBoYXNGaXJlZm94MkluZGV4T2ZCdWcgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJiBbMCwgMV0uaW5kZXhPZigxLCAyKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzb3VnaHQgLyosIGZyb21JbmRleCAqLyApIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGkgPSB0b0ludGVnZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogTWF0aC5tYXgoMCwgbGVuZ3RoICsgaSk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VsZltpXSA9PT0gc291Z2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbi8vXG4vLyBTdHJpbmdcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDE1LjUuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbi8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cbi8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4vLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbi8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxuLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxuLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbi8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbnZhciBzdHJpbmdfc3BsaXQgPSBTdHJpbmdQcm90b3R5cGUuc3BsaXQ7XG5pZiAoXG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fFxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT09IDQgfHxcbiAgICAndGVzc3QnLnNwbGl0KC8ocykqLylbMV0gPT09ICd0JyB8fFxuICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGggfHxcbiAgICAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxXG4pIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHZvaWQgMDsgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcblxuICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSAgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5leHRlbmRlZCAgID8gJ3gnIDogJycpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgICAgID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrXG4gICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJyc7IC8vIFR5cGUtY29udmVydFxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvci5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxpbWl0ID0gbGltaXQgPT09IHZvaWQgMCA/XG4gICAgICAgICAgICAgICAgLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgICAgVG9VaW50MzIobGltaXQpO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5UHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbi8vIFtidWdmaXgsIGNocm9tZV1cbi8vIElmIHNlcGFyYXRvciBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIHJlc3VsdCBhcnJheSBjb250YWlucyBqdXN0IG9uZSBTdHJpbmcsXG4vLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbi8vIGVsZW1lbnRzLlxuLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxufSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG59XG5cbi8vIEVDTUEtMjYyLCAzcmQgQi4yLjNcbi8vIE5vdCBhbiBFQ01BU2NyaXB0IHN0YW5kYXJkLCBhbHRob3VnaCBFQ01BU2NyaXB0IDNyZCBFZGl0aW9uIGhhcyBhXG4vLyBub24tbm9ybWF0aXZlIHNlY3Rpb24gc3VnZ2VzdGluZyB1bmlmb3JtIHNlbWFudGljcyBhbmQgaXQgc2hvdWxkIGJlXG4vLyBub3JtYWxpemVkIGFjcm9zcyBhbGwgYnJvd3NlcnNcbi8vIFtidWdmaXgsIElFIGx0IDldIElFIDwgOSBzdWJzdHIoKSB3aXRoIG5lZ2F0aXZlIHZhbHVlIG5vdCB3b3JraW5nIGluIElFXG52YXIgc3RyaW5nX3N1YnN0ciA9IFN0cmluZ1Byb3RvdHlwZS5zdWJzdHI7XG52YXIgaGFzTmVnYXRpdmVTdWJzdHJCdWcgPSAnJy5zdWJzdHIgJiYgJzBiJy5zdWJzdHIoLTEpICE9PSAnYic7XG5kZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgIHN1YnN0cjogZnVuY3Rpb24gc3Vic3RyKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ19zdWJzdHIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBzdGFydCA8IDAgPyAoKHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydCkgPCAwID8gMCA6IHN0YXJ0KSA6IHN0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgICk7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVTdWJzdHJCdWcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi9zaGltcy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKTtcblxuLy8gU29tZSBleHRyYSBjaGFyYWN0ZXJzIHRoYXQgQ2hyb21lIGdldHMgd3JvbmcsIGFuZCBzdWJzdGl0dXRlcyB3aXRoXG4vLyBzb21ldGhpbmcgZWxzZSBvbiB0aGUgd2lyZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG52YXIgZXh0cmFFc2NhcGFibGUgPSAvW1xceDAwLVxceDFmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZcXHUwMzAwLVxcdTAzMzNcXHUwMzNkLVxcdTAzNDZcXHUwMzRhLVxcdTAzNGNcXHUwMzUwLVxcdTAzNTJcXHUwMzU3LVxcdTAzNThcXHUwMzVjLVxcdTAzNjJcXHUwMzc0XFx1MDM3ZVxcdTAzODdcXHUwNTkxLVxcdTA1YWZcXHUwNWM0XFx1MDYxMC1cXHUwNjE3XFx1MDY1My1cXHUwNjU0XFx1MDY1Ny1cXHUwNjViXFx1MDY1ZC1cXHUwNjVlXFx1MDZkZi1cXHUwNmUyXFx1MDZlYi1cXHUwNmVjXFx1MDczMFxcdTA3MzItXFx1MDczM1xcdTA3MzUtXFx1MDczNlxcdTA3M2FcXHUwNzNkXFx1MDczZi1cXHUwNzQxXFx1MDc0M1xcdTA3NDVcXHUwNzQ3XFx1MDdlYi1cXHUwN2YxXFx1MDk1MVxcdTA5NTgtXFx1MDk1ZlxcdTA5ZGMtXFx1MDlkZFxcdTA5ZGZcXHUwYTMzXFx1MGEzNlxcdTBhNTktXFx1MGE1YlxcdTBhNWVcXHUwYjVjLVxcdTBiNWRcXHUwZTM4LVxcdTBlMzlcXHUwZjQzXFx1MGY0ZFxcdTBmNTJcXHUwZjU3XFx1MGY1Y1xcdTBmNjlcXHUwZjcyLVxcdTBmNzZcXHUwZjc4XFx1MGY4MC1cXHUwZjgzXFx1MGY5M1xcdTBmOWRcXHUwZmEyXFx1MGZhN1xcdTBmYWNcXHUwZmI5XFx1MTkzOS1cXHUxOTNhXFx1MWExN1xcdTFiNmJcXHUxY2RhLVxcdTFjZGJcXHUxZGMwLVxcdTFkY2ZcXHUxZGZjXFx1MWRmZVxcdTFmNzFcXHUxZjczXFx1MWY3NVxcdTFmNzdcXHUxZjc5XFx1MWY3YlxcdTFmN2RcXHUxZmJiXFx1MWZiZVxcdTFmYzlcXHUxZmNiXFx1MWZkM1xcdTFmZGJcXHUxZmUzXFx1MWZlYlxcdTFmZWUtXFx1MWZlZlxcdTFmZjlcXHUxZmZiXFx1MWZmZFxcdTIwMDAtXFx1MjAwMVxcdTIwZDAtXFx1MjBkMVxcdTIwZDQtXFx1MjBkN1xcdTIwZTctXFx1MjBlOVxcdTIxMjZcXHUyMTJhLVxcdTIxMmJcXHUyMzI5LVxcdTIzMmFcXHUyYWRjXFx1MzAyYi1cXHUzMDJjXFx1YWFiMi1cXHVhYWIzXFx1ZjkwMC1cXHVmYTBkXFx1ZmExMFxcdWZhMTJcXHVmYTE1LVxcdWZhMWVcXHVmYTIwXFx1ZmEyMlxcdWZhMjUtXFx1ZmEyNlxcdWZhMmEtXFx1ZmEyZFxcdWZhMzAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMWRcXHVmYjFmXFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmI0ZVxcdWZmZjAtXFx1ZmZmZl0vZ1xuICAsIGV4dHJhTG9va3VwO1xuXG4vLyBUaGlzIG1heSBiZSBxdWl0ZSBzbG93LCBzbyBsZXQncyBkZWxheSB1bnRpbCB1c2VyIGFjdHVhbGx5IHVzZXMgYmFkXG4vLyBjaGFyYWN0ZXJzLlxudmFyIHVucm9sbExvb2t1cCA9IGZ1bmN0aW9uKGVzY2FwYWJsZSkge1xuICB2YXIgaTtcbiAgdmFyIHVucm9sbGVkID0ge307XG4gIHZhciBjID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCA2NTUzNjsgaSsrKSB7XG4gICAgYy5wdXNoKCBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICk7XG4gIH1cbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIGMuam9pbignJykucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICB1bnJvbGxlZFsgYSBdID0gJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB1bnJvbGxlZDtcbn07XG5cbi8vIFF1b3RlIHN0cmluZywgYWxzbyB0YWtpbmcgY2FyZSBvZiB1bmljb2RlIGNoYXJhY3RlcnMgdGhhdCBicm93c2Vyc1xuLy8gb2Z0ZW4gYnJlYWsuIEVzcGVjaWFsbHksIHRha2UgY2FyZSBvZiB1bmljb2RlIHN1cnJvZ2F0ZXM6XG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcHBpbmdfb2ZfVW5pY29kZV9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBxdW90ZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHF1b3RlZCA9IEpTT04zLnN0cmluZ2lmeShzdHJpbmcpO1xuXG4gICAgLy8gSW4gbW9zdCBjYXNlcyB0aGlzIHNob3VsZCBiZSB2ZXJ5IGZhc3QgYW5kIGdvb2QgZW5vdWdoLlxuICAgIGV4dHJhRXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgaWYgKCFleHRyYUVzY2FwYWJsZS50ZXN0KHF1b3RlZCkpIHtcbiAgICAgIHJldHVybiBxdW90ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFleHRyYUxvb2t1cCkge1xuICAgICAgZXh0cmFMb29rdXAgPSB1bnJvbGxMb29rdXAoZXh0cmFFc2NhcGFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiBxdW90ZWQucmVwbGFjZShleHRyYUVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGV4dHJhTG9va3VwW2FdO1xuICAgIH0pO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy9lc2NhcGUuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dHJhbnNwb3J0Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICByZXR1cm4ge1xuICAgIGZpbHRlclRvRW5hYmxlZDogZnVuY3Rpb24odHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbykge1xuICAgICAgdmFyIHRyYW5zcG9ydHMgPSB7XG4gICAgICAgIG1haW46IFtdXG4gICAgICAsIGZhY2FkZTogW11cbiAgICAgIH07XG4gICAgICBpZiAoIXRyYW5zcG9ydHNXaGl0ZWxpc3QpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFtdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNwb3J0c1doaXRlbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFt0cmFuc3BvcnRzV2hpdGVsaXN0XTtcbiAgICAgIH1cblxuICAgICAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICAgIGlmICghdHJhbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMudHJhbnNwb3J0TmFtZSA9PT0gJ3dlYnNvY2tldCcgJiYgaW5mby53ZWJzb2NrZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkIGZyb20gc2VydmVyJywgJ3dlYnNvY2tldCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc3BvcnRzV2hpdGVsaXN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdC5pbmRleE9mKHRyYW5zLnRyYW5zcG9ydE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGRlYnVnKCdub3QgaW4gd2hpdGVsaXN0JywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLmVuYWJsZWQoaW5mbykpIHtcbiAgICAgICAgICBkZWJ1ZygnZW5hYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHRyYW5zcG9ydHMubWFpbi5wdXNoKHRyYW5zKTtcbiAgICAgICAgICBpZiAodHJhbnMuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRzLmZhY2FkZS5wdXNoKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmFuc3BvcnRzO1xuICAgIH1cbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL3RyYW5zcG9ydC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ09iamVjdCA9IHt9O1xuWydsb2cnLCAnZGVidWcnLCAnd2FybiddLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gIHZhciBsZXZlbEV4aXN0cztcblxuICB0cnkge1xuICAgIGxldmVsRXhpc3RzID0gZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseTtcbiAgfSBjYXRjaChlKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgbG9nT2JqZWN0W2xldmVsXSA9IGxldmVsRXhpc3RzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHkoZ2xvYmFsLmNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIH0gOiAobGV2ZWwgPT09ICdsb2cnID8gZnVuY3Rpb24gKCkge30gOiBsb2dPYmplY3QubG9nKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ09iamVjdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdXRpbHMvbG9nLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBFdmVudChldmVudFR5cGUpIHtcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xufVxuXG5FdmVudC5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBjYW5CdWJibGUsIGNhbmNlbGFibGUpIHtcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xuICB0aGlzLmJ1YmJsZXMgPSBjYW5CdWJibGU7XG4gIHRoaXMuY2FuY2VsYWJsZSA9IGNhbmNlbGFibGU7XG4gIHRoaXMudGltZVN0YW1wID0gK25ldyBEYXRlKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge307XG5FdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHt9O1xuXG5FdmVudC5DQVBUVVJJTkdfUEhBU0UgPSAxO1xuRXZlbnQuQVRfVEFSR0VUID0gMjtcbkV2ZW50LkJVQkJMSU5HX1BIQVNFID0gMztcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvZXZlbnQvZXZlbnQuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmxvY2F0aW9uIHx8IHtcbiAgb3JpZ2luOiAnaHR0cDovL2xvY2FsaG9zdDo4MCdcbiwgcHJvdG9jb2w6ICdodHRwJ1xuLCBob3N0OiAnbG9jYWxob3N0J1xuLCBwb3J0OiA4MFxuLCBocmVmOiAnaHR0cDovL2xvY2FsaG9zdC8nXG4sIGhhc2g6ICcnXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi9sb2NhdGlvbi5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gQ2xvc2VFdmVudCgpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy53YXNDbGVhbiA9IGZhbHNlO1xuICB0aGlzLmNvZGUgPSAwO1xuICB0aGlzLnJlYXNvbiA9ICcnO1xufVxuXG5pbmhlcml0cyhDbG9zZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvc2VFdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvZXZlbnQvY2xvc2UuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICA7XG5cbmZ1bmN0aW9uIFRyYW5zcG9ydE1lc3NhZ2VFdmVudChkYXRhKSB7XG4gIEV2ZW50LmNhbGwodGhpcyk7XG4gIHRoaXMuaW5pdEV2ZW50KCdtZXNzYWdlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn1cblxuaW5oZXJpdHMoVHJhbnNwb3J0TWVzc2FnZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0TWVzc2FnZUV2ZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi9ldmVudC90cmFucy1tZXNzYWdlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgWERSID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hkcicpXG4gICwgWEhSQ29ycyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWwgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBYSFJGYWtlID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlJylcbiAgLCBJbmZvSWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZScpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIGRlYnVnKGJhc2VVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuLy8gVE9ETyB0aGlzIGlzIGN1cnJlbnRseSBpZ25vcmluZyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBhbmQgdGhlIHdoaXRlbGlzdFxuXG5JbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsLCB1cmxJbmZvKSB7XG4gIC8vIGRldGVybWluZSBtZXRob2Qgb2YgQ09SUyBzdXBwb3J0IChpZiBuZWVkZWQpXG4gIGlmICh1cmxJbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSTG9jYWwpO1xuICB9XG4gIGlmIChYSFJDb3JzLmVuYWJsZWQpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSQ29ycyk7XG4gIH1cbiAgaWYgKFhEUi5lbmFibGVkICYmIHVybEluZm8uc2FtZVNjaGVtZSkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYRFIpO1xuICB9XG4gIGlmIChJbmZvSWZyYW1lLmVuYWJsZWQoKSkge1xuICAgIHJldHVybiBuZXcgSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpO1xuICB9XG4gIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJGYWtlKTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuZG9YaHIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2luZm8nKVxuICAgIDtcbiAgZGVidWcoJ2RvWGhyJywgdXJsKTtcblxuICB0aGlzLnhvID0gSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlcihiYXNlVXJsLCB1cmwsIHVybEluZm8pO1xuXG4gIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICB9LCBJbmZvUmVjZWl2ZXIudGltZW91dCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgfSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24od2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRSZWYpO1xuICB0aGlzLnRpbWVvdXRSZWYgPSBudWxsO1xuICBpZiAoIXdhc0NsZWFuICYmIHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy54byA9IG51bGw7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cbkluZm9SZWNlaXZlci50aW1lb3V0ID0gODAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL2luZm8tcmVjZWl2ZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJGYWtlKC8qIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzICovKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy50byA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsICd7fScpO1xuICB9LCBYSFJGYWtlLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhYSFJGYWtlLCBFdmVudEVtaXR0ZXIpO1xuXG5YSFJGYWtlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy50byk7XG59O1xuXG5YSFJGYWtlLnRpbWVvdXQgPSAyMDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkZha2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2UuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L2lmcmFtZScpXG4gICwgSW5mb1JlY2VpdmVySWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZnIgPSBzZWxmLmlmciA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUsIHVybCwgYmFzZVVybCk7XG5cbiAgICBpZnIub25jZSgnbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgICAgaWYgKG1zZykge1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkID0gSlNPTjMucGFyc2UobXNnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIG1zZyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICB9XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBpZnIub25jZSgnY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETyB0aGlzIHNlZW1zIHRoZSBzYW1lIGFzIHRoZSAnbmVlZEJvZHknIGZyb20gdHJhbnNwb3J0c1xuICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5KSB7XG4gICAgdXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCBnbyk7XG4gIH0gZWxzZSB7XG4gICAgZ28oKTtcbiAgfVxufVxuXG5pbmhlcml0cyhJbmZvSWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvSWZyYW1lLmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG59O1xuXG5JbmZvSWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pZnIpIHtcbiAgICB0aGlzLmlmci5jbG9zZSgpO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuaWZyID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0lmcmFtZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvaW5mby1pZnJhbWUuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcklmcmFtZSh0cmFuc1VybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaXIgPSBuZXcgSW5mb0FqYXgodHJhbnNVcmwsIFhIUkxvY2FsT2JqZWN0KTtcbiAgdGhpcy5pci5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBzZWxmLmlyID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBKU09OMy5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlcklmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLWluZm8tcmVjZWl2ZXInO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlyKSB7XG4gICAgdGhpcy5pci5jbG9zZSgpO1xuICAgIHRoaXMuaXIgPSBudWxsO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcklmcmFtZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvaW5mby1pZnJhbWUtcmVjZWl2ZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tYWpheCcpO1xufVxuXG5mdW5jdGlvbiBJbmZvQWpheCh1cmwsIEFqYXhPYmplY3QpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdDAgPSArbmV3IERhdGUoKTtcbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdHRVQnLCB1cmwpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgdmFyIGluZm8sIHJ0dDtcbiAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJ0dCA9ICgrbmV3IERhdGUoKSkgLSB0MDtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5mbyA9IEpTT04zLnBhcnNlKHRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3RVdGlscy5pc09iamVjdChpbmZvKSkge1xuICAgICAgICBpbmZvID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb0FqYXgsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnhvLmNsb3NlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9BamF4O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi9pbmZvLWFqYXguanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRmFjYWRlSlMgPSByZXF1aXJlKCcuL2ZhY2FkZScpXG4gICwgSW5mb0lmcmFtZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppZnJhbWUtYm9vdHN0cmFwJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHZhciB0cmFuc3BvcnRNYXAgPSB7fTtcbiAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKGF0KSB7XG4gICAgaWYgKGF0LmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNwb3J0TWFwW2F0LmZhY2FkZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lXSA9IGF0LmZhY2FkZVRyYW5zcG9ydDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGhhcmQtY29kZWQgZm9yIHRoZSBpbmZvIGlmcmFtZVxuICAvLyBUT0RPIHNlZSBpZiB3ZSBjYW4gbWFrZSB0aGlzIG1vcmUgZHluYW1pY1xuICB0cmFuc3BvcnRNYXBbSW5mb0lmcmFtZVJlY2VpdmVyLnRyYW5zcG9ydE5hbWVdID0gSW5mb0lmcmFtZVJlY2VpdmVyO1xuICB2YXIgcGFyZW50T3JpZ2luO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICBTb2NrSlMuYm9vdHN0cmFwX2lmcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgdmFyIGZhY2FkZTtcbiAgICBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQgPSBsb2MuaGFzaC5zbGljZSgxKTtcbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuc291cmNlICE9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnRPcmlnaW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmVudE9yaWdpbiA9IGUub3JpZ2luO1xuICAgICAgfVxuICAgICAgaWYgKGUub3JpZ2luICE9PSBwYXJlbnRPcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICB2YXIgcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnNpb24gPSBwWzBdO1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gcFsxXTtcbiAgICAgICAgdmFyIHRyYW5zVXJsID0gcFsyXTtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBwWzNdO1xuICAgICAgICBkZWJ1Zyh2ZXJzaW9uLCB0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgICAgICAgLy8gY2hhbmdlIHRoaXMgdG8gc2VtdmVyIGxvZ2ljXG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSBTb2NrSlMudmVyc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIFNvY2tKUyEgTWFpbiBzaXRlIHVzZXM6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgdmVyc2lvbiArICdcIiwgdGhlIGlmcmFtZTonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyBTb2NrSlMudmVyc2lvbiArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0cmFuc1VybCwgbG9jLmhyZWYpIHx8XG4gICAgICAgICAgICAhdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChiYXNlVXJsLCBsb2MuaHJlZikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY29ubmVjdCB0byBkaWZmZXJlbnQgZG9tYWluIGZyb20gd2l0aGluIGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLiAoJyArIGxvYy5ocmVmICsgJywgJyArIHRyYW5zVXJsICsgJywgJyArIGJhc2VVcmwgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG5ldyBGYWNhZGVKUyhuZXcgdHJhbnNwb3J0TWFwW3RyYW5zcG9ydF0odHJhbnNVcmwsIGJhc2VVcmwpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgZmFjYWRlLl9zZW5kKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGlmIChmYWNhZGUpIHtcbiAgICAgICAgICBmYWNhZGUuX2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuXG4gICAgLy8gU3RhcnRcbiAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgncycpO1xuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvaWZyYW1lLWJvb3RzdHJhcC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICA7XG5cbmZ1bmN0aW9uIEZhY2FkZUpTKHRyYW5zcG9ydCkge1xuICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gIHRyYW5zcG9ydC5vbignY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbn1cblxuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgnYycsIEpTT04zLnN0cmluZ2lmeShbY29kZSwgcmVhc29uXSkpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCd0JywgZnJhbWUpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZGF0YSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgdGhpcy5fdHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWNhZGVKUztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvZmFjYWRlLmpzIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLypnbG9iYWxzIHdpbmRvdyBfX3dlYnBhY2tfaGFzaF9fICovXHJcbmlmKG1vZHVsZS5ob3QpIHtcclxuXHR2YXIgbGFzdERhdGE7XHJcblx0dmFyIHVwVG9EYXRlID0gZnVuY3Rpb24gdXBUb0RhdGUoKSB7XHJcblx0XHRyZXR1cm4gbGFzdERhdGEuaW5kZXhPZihfX3dlYnBhY2tfaGFzaF9fKSA+PSAwO1xyXG5cdH07XHJcblx0dmFyIGNoZWNrID0gZnVuY3Rpb24gY2hlY2soKSB7XHJcblx0XHRtb2R1bGUuaG90LmNoZWNrKGZ1bmN0aW9uKGVyciwgdXBkYXRlZE1vZHVsZXMpIHtcclxuXHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0aWYobW9kdWxlLmhvdC5zdGF0dXMoKSBpbiB7XHJcblx0XHRcdFx0XHRcdGFib3J0OiAxLFxyXG5cdFx0XHRcdFx0XHRmYWlsOiAxXHJcblx0XHRcdFx0XHR9KSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJbSE1SXSBDYW5ub3QgY2hlY2sgZm9yIHVwZGF0ZS4gTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIFwiICsgZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gVXBkYXRlIGNoZWNrIGZhaWxlZDogXCIgKyBlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKCF1cGRhdGVkTW9kdWxlcykge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIENhbm5vdCBmaW5kIHVwZGF0ZS4gTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiKTtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJbSE1SXSAoUHJvYmFibHkgYmVjYXVzZSBvZiByZXN0YXJ0aW5nIHRoZSB3ZWJwYWNrLWRldi1zZXJ2ZXIpXCIpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bW9kdWxlLmhvdC5hcHBseSh7XHJcblx0XHRcdFx0aWdub3JlVW5hY2NlcHRlZDogdHJ1ZVxyXG5cdFx0XHR9LCBmdW5jdGlvbihlcnIsIHJlbmV3ZWRNb2R1bGVzKSB7XHJcblx0XHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0XHRpZihtb2R1bGUuaG90LnN0YXR1cygpIGluIHtcclxuXHRcdFx0XHRcdFx0XHRhYm9ydDogMSxcclxuXHRcdFx0XHRcdFx0XHRmYWlsOiAxXHJcblx0XHRcdFx0XHRcdH0pIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gQ2Fubm90IGFwcGx5IHVwZGF0ZS4gTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiKTtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gXCIgKyBlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gVXBkYXRlIGZhaWxlZDogXCIgKyBlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYoIXVwVG9EYXRlKCkpIHtcclxuXHRcdFx0XHRcdGNoZWNrKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXF1aXJlKFwiLi9sb2ctYXBwbHktcmVzdWx0XCIpKHVwZGF0ZWRNb2R1bGVzLCByZW5ld2VkTW9kdWxlcyk7XHJcblxyXG5cdFx0XHRcdGlmKHVwVG9EYXRlKCkpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiW0hNUl0gQXBwIGlzIHVwIHRvIGRhdGUuXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cdHZhciBhZGRFdmVudExpc3RlbmVyID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyBmdW5jdGlvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XHJcblx0fSA6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuXHRcdHdpbmRvdy5hdHRhY2hFdmVudChcIm9uXCIgKyBldmVudE5hbWUsIGxpc3RlbmVyKTtcclxuXHR9O1xyXG5cdGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRpZih0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBldmVudC5kYXRhLmluZGV4T2YoXCJ3ZWJwYWNrSG90VXBkYXRlXCIpID09PSAwKSB7XHJcblx0XHRcdGxhc3REYXRhID0gZXZlbnQuZGF0YTtcclxuXHRcdFx0aWYoIXVwVG9EYXRlKCkgJiYgbW9kdWxlLmhvdC5zdGF0dXMoKSA9PT0gXCJpZGxlXCIpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIltITVJdIENoZWNraW5nIGZvciB1cGRhdGVzIG9uIHRoZSBzZXJ2ZXIuLi5cIik7XHJcblx0XHRcdFx0Y2hlY2soKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdGNvbnNvbGUubG9nKFwiW0hNUl0gV2FpdGluZyBmb3IgdXBkYXRlIHNpZ25hbCBmcm9tIFdEUy4uLlwiKTtcclxufSBlbHNlIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJbSE1SXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGlzIGRpc2FibGVkLlwiKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2hvdC9vbmx5LWRldi1zZXJ2ZXIuanMiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVwZGF0ZWRNb2R1bGVzLCByZW5ld2VkTW9kdWxlcykge1xyXG5cdHZhciB1bmFjY2VwdGVkTW9kdWxlcyA9IHVwZGF0ZWRNb2R1bGVzLmZpbHRlcihmdW5jdGlvbihtb2R1bGVJZCkge1xyXG5cdFx0cmV0dXJuIHJlbmV3ZWRNb2R1bGVzICYmIHJlbmV3ZWRNb2R1bGVzLmluZGV4T2YobW9kdWxlSWQpIDwgMDtcclxuXHR9KTtcclxuXHJcblx0aWYodW5hY2NlcHRlZE1vZHVsZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gVGhlIGZvbGxvd2luZyBtb2R1bGVzIGNvdWxkbid0IGJlIGhvdCB1cGRhdGVkOiAoVGhleSB3b3VsZCBuZWVkIGEgZnVsbCByZWxvYWQhKVwiKTtcclxuXHRcdHVuYWNjZXB0ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlSWQpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGlmKCFyZW5ld2VkTW9kdWxlcyB8fCByZW5ld2VkTW9kdWxlcy5sZW5ndGggPT09IDApIHtcclxuXHRcdGNvbnNvbGUubG9nKFwiW0hNUl0gTm90aGluZyBob3QgdXBkYXRlZC5cIik7XHJcblx0fSBlbHNlIHtcclxuXHRcdGNvbnNvbGUubG9nKFwiW0hNUl0gVXBkYXRlZCBtb2R1bGVzOlwiKTtcclxuXHRcdHJlbmV3ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlSWQpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9ob3QvbG9nLWFwcGx5LXJlc3VsdC5qcyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IExpdWtleWkgb24gMjAxNy8yLzguXHJcbiAqL1xyXG5pbXBvcnQgJy4vbGVzcy90ZXN0Lmxlc3MnXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXHJcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nXHJcblxyXG5yZW5kZXIoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiPjwvZGl2PixcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290JylcclxuKVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VudHJ5LmpzIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xlc3MvdGVzdC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3QnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvcmVhY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdFB1cmVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0UHVyZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHJlcXVpcmUoJy4vUmVhY3RET01GYWN0b3JpZXMnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQ7XG52YXIgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xudmFyIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuICBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQ7XG4gIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbiAgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNsb25lRWxlbWVudDtcbn1cblxudmFyIF9fc3ByZWFkID0gX2Fzc2lnbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuZWQsICdSZWFjdC5fX3NwcmVhZCBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQuIFVzZSAnICsgJ09iamVjdC5hc3NpZ24gZGlyZWN0bHkgb3IgYW5vdGhlciBoZWxwZXIgZnVuY3Rpb24gd2l0aCBzaW1pbGFyICcgKyAnc2VtYW50aWNzLiBZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIHlvdXIgY29tcGlsZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtc3ByZWFkLWRlcHJlY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJykgOiB2b2lkIDA7XG4gICAgd2FybmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gX2Fzc2lnbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgUmVhY3QgPSB7XG5cbiAgLy8gTW9kZXJuXG5cbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IFJlYWN0Q2hpbGRyZW4ubWFwLFxuICAgIGZvckVhY2g6IFJlYWN0Q2hpbGRyZW4uZm9yRWFjaCxcbiAgICBjb3VudDogUmVhY3RDaGlsZHJlbi5jb3VudCxcbiAgICB0b0FycmF5OiBSZWFjdENoaWxkcmVuLnRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUmVhY3RQdXJlQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuICBpc1ZhbGlkRWxlbWVudDogUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50LFxuXG4gIC8vIENsYXNzaWNcblxuICBQcm9wVHlwZXM6IFJlYWN0UHJvcFR5cGVzLFxuICBjcmVhdGVDbGFzczogUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyxcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcbiAgY3JlYXRlTWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIC8vIEN1cnJlbnRseSBhIG5vb3AuIFdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdHJhY2UgbWl4aW5zLlxuICAgIHJldHVybiBtaXhpbjtcbiAgfSxcblxuICAvLyBUaGlzIGxvb2tzIERPTSBzcGVjaWZpYyBidXQgdGhlc2UgYXJlIGFjdHVhbGx5IGlzb21vcnBoaWMgaGVscGVyc1xuICAvLyBzaW5jZSB0aGV5IGFyZSBqdXN0IGdlbmVyYXRpbmcgRE9NIHN0cmluZ3MuXG4gIERPTTogUmVhY3RET01GYWN0b3JpZXMsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8vIERlcHJlY2F0ZWQgaG9vayBmb3IgSlNYIHNwcmVhZCwgZG9uJ3QgdXNlIHRoaXMgZm9yIGFueXRoaW5nLlxuICBfX3NwcmVhZDogX19zcHJlYWRcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3QuanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXI7XG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIHRyYXZlcnNhbC4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBGb3JFYWNoQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBmb3JFYWNoRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSB0cmF2ZXJzYWwgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBjb250ZXh0IHdpdGguXG4gKi9cbmZ1bmN0aW9uIEZvckVhY2hCb29rS2VlcGluZyhmb3JFYWNoRnVuY3Rpb24sIGZvckVhY2hDb250ZXh0KSB7XG4gIHRoaXMuZnVuYyA9IGZvckVhY2hGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gZm9yRWFjaENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuRm9yRWFjaEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRm9yRWFjaEJvb2tLZWVwaW5nLCB0d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IEZvckVhY2hCb29rS2VlcGluZy5nZXRQb29sZWQoZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICBGb3JFYWNoQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogbWFwcGluZy4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBNYXBCb29rS2VlcGluZ1xuICogQHBhcmFtIHshKn0gbWFwUmVzdWx0IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICogQHBhcmFtIHshZnVuY3Rpb259IG1hcEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICogQHBhcmFtIHs/Kn0gbWFwQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICovXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgdGhpcy5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5NYXBCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZXN1bHQgPSBudWxsO1xuICB0aGlzLmtleVByZWZpeCA9IG51bGw7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhNYXBCb29rS2VlcGluZywgZm91ckFyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZER1bW15LCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsOiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBTdGF0aWMgcG9vbGVycy4gU2V2ZXJhbCBjdXN0b20gdmVyc2lvbnMgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZlxuICogYXJndW1lbnRzLiBBIGNvbXBsZXRlbHkgZ2VuZXJpYyBwb29sZXIgaXMgZWFzeSB0byBpbXBsZW1lbnQsIGJ1dCB3b3VsZFxuICogcmVxdWlyZSBhY2Nlc3NpbmcgdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gSW4gZWFjaCBvZiB0aGVzZSwgYHRoaXNgIHJlZmVycyB0b1xuICogdGhlIENsYXNzIGl0c2VsZiwgbm90IGFuIGluc3RhbmNlLiBJZiBhbnkgb3RoZXJzIGFyZSBuZWVkZWQsIHNpbXBseSBhZGQgdGhlbVxuICogaGVyZSwgb3IgaW4gdGhlaXIgb3duIGZpbGVzLlxuICovXG52YXIgb25lQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoY29weUZpZWxkc0Zyb20pIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgY29weUZpZWxkc0Zyb20pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGNvcHlGaWVsZHNGcm9tKTtcbiAgfVxufTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMyk7XG4gIH1cbn07XG5cbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0KTtcbiAgfVxufTtcblxudmFyIHN0YW5kYXJkUmVsZWFzZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogX3Byb2RJbnZhcmlhbnQoJzI1JykgOiB2b2lkIDA7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIC8vIENhc3RpbmcgYXMgYW55IHNvIHRoYXQgZmxvdyBpZ25vcmVzIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gYW5kIHRydXN0c1xuICAvLyBpdCB0byBtYXRjaCB0aGUgdHlwZSB3ZSBkZWNsYXJlZFxuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbmZ1bmN0aW9uIHJlYWN0UHJvZEludmFyaWFudChjb2RlKSB7XG4gIHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXG4gIHZhciBtZXNzYWdlID0gJ01pbmlmaWVkIFJlYWN0IGVycm9yICMnICsgY29kZSArICc7IHZpc2l0ICcgKyAnaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9JyArIGNvZGU7XG5cbiAgZm9yICh2YXIgYXJnSWR4ID0gMDsgYXJnSWR4IDwgYXJnQ291bnQ7IGFyZ0lkeCsrKSB7XG4gICAgbWVzc2FnZSArPSAnJmFyZ3NbXT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1thcmdJZHggKyAxXSk7XG4gIH1cblxuICBtZXNzYWdlICs9ICcgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50JyArICcgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJztcblxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCByZWFjdFByb2RJbnZhcmlhbnQncyBvd24gZnJhbWVcblxuICB0aHJvdyBlcnJvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdFByb2RJbnZhcmlhbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgIH0pO1xuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcbiAgICAgIGVsZW1lbnQuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZWxlbWVudFxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZmFjdG9yeVxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBmYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgLy8gRXhwb3NlIHRoZSB0eXBlIG9uIHRoZSBmYWN0b3J5IGFuZCB0aGUgcHJvdG90eXBlIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIGVhc2lseSBhY2Nlc3NlZCBvbiBlbGVtZW50cy4gRS5nLiBgPEZvbyAvPi50eXBlID09PSBGb29gLlxuICAvLyBUaGlzIHNob3VsZCBub3QgYmUgbmFtZWQgYGNvbnN0cnVjdG9yYCBzaW5jZSB0aGlzIG1heSBub3QgYmUgdGhlIGZ1bmN0aW9uXG4gIC8vIHRoYXQgY3JlYXRlZCB0aGUgZWxlbWVudCwgYW5kIGl0IG1heSBub3QgZXZlbiBiZSBhIGNvbnN0cnVjdG9yLlxuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5ID0gZnVuY3Rpb24gKG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jbG9uZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5pc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH07XG5cbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvd2FybmluZy5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XG5cbm1vZHVsZS5leHBvcnRzID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFN5bWJvbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRoaXMgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudCBzaW5jZSB0aGlzIGZpbGUgaXMgc2hhcmVkIGJldHdlZW5cbiAqIGlzb21vcnBoaWMgYW5kIHJlbmRlcmVycy4gV2UgY291bGQgZXh0cmFjdCB0aGlzIHRvIGFcbiAqXG4gKi9cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fFxuICAvLyBUaGUgZm9sbG93aW5nIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQuIFRoaXMgbWVhbnMgd2UgY2FuIG9wdGltaXplXG4gIC8vIHNvbWUgY2hlY2tzLiBSZWFjdCBGaWJlciBhbHNvIGlubGluZXMgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBwdXJwb3Nlcy5cbiAgdHlwZSA9PT0gJ29iamVjdCcgJiYgY2hpbGRyZW4uJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGlpID0gMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcnO1xuICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICAgIGlmIChtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XG4gICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogX3Byb2RJbnZhcmlhbnQoJzMxJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZUFsbENoaWxkcmVuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBTeW1ib2wgKi9cblxudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFVuZXNjYXBlIGFuZCB1bndyYXAga2V5IGZvciBodW1hbi1yZWFkYWJsZSBkaXNwbGF5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byB1bmVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHVuZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKGtleSkge1xuICB2YXIgdW5lc2NhcGVSZWdleCA9IC8oPTB8PTIpL2c7XG4gIHZhciB1bmVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0wJzogJz0nLFxuICAgICc9Mic6ICc6J1xuICB9O1xuICB2YXIga2V5U3Vic3RyaW5nID0ga2V5WzBdID09PSAnLicgJiYga2V5WzFdID09PSAnJCcgPyBrZXkuc3Vic3RyaW5nKDIpIDoga2V5LnN1YnN0cmluZygxKTtcblxuICByZXR1cm4gKCcnICsga2V5U3Vic3RyaW5nKS5yZXBsYWNlKHVuZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiB1bmVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbn1cblxudmFyIEtleUVzY2FwZVV0aWxzID0ge1xuICBlc2NhcGU6IGVzY2FwZSxcbiAgdW5lc2NhcGU6IHVuZXNjYXBlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleUVzY2FwZVV0aWxzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL0tleUVzY2FwZVV0aWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Q29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IF9wcm9kSW52YXJpYW50KCc4NScpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBSZWFjdENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWFjdFB1cmVDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24oUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlKTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHVyZUNvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdFB1cmVDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBNSVhJTlNfS0VZID0gJ21peGlucyc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBhbGxvdyB0aGUgY3JlYXRpb24gb2YgYW5vbnltb3VzIGZ1bmN0aW9ucyB3aGljaCBkbyBub3Rcbi8vIGhhdmUgLm5hbWUgc2V0IHRvIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSBiZWluZyBhc3NpZ25lZCB0by5cbmZ1bmN0aW9uIGlkZW50aXR5KGZuKSB7XG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICovXG5cblxudmFyIGluamVjdGVkTWl4aW5zID0gW107XG5cbi8qKlxuICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcbiAqIG9yIGhvc3QgY29tcG9uZW50cy5cbiAqXG4gKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gKiB5b3VyIG5ldyBjbGFzcyB0byBgUmVhY3QuY3JlYXRlQ2xhc3NgLiBUaGUgb25seSByZXF1aXJlbWVudCBvZiB5b3VyIGNsYXNzXG4gKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBzdXBwb3J0cyBhIHNwZWNpZmljIHByb3RvY29sIG9mIG1ldGhvZHMgdGhhdCBoYXZlXG4gKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG4gKlxuICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7YXJyYXl9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgbWl4aW5zOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHN0YXRpY3M6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgcHJvcFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjaGlsZENvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgKlxuICAgKiAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4ge1xuICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICogICAgICAgZm9vQmF6OiBuZXcgQmF6Rm9vKClcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRJbml0aWFsU3RhdGU6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0Q2hpbGRDb250ZXh0OiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAvKipcbiAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgKiBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgKiBpdCBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICpcbiAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgKiBAcmVxdWlyZWRcbiAgICovXG4gIHJlbmRlcjogJ0RFRklORV9PTkNFJyxcblxuICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIGFuZCBoYXMgYSBET00gcmVwcmVzZW50YXRpb24uXG4gICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgKlxuICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxuICAgKiAgICAgfSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICogdXBkYXRlLlxuICAgKlxuICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogJ0RFRklORV9PTkNFJyxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAqIGFuZCBgbmV4dENvbnRleHRgLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVwZGF0ZTogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXG4gICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAvLyA9PT09IEFkdmFuY2VkIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6ICdPVkVSUklERV9CQVNFJ1xuXG59O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBjbGFzcyBzcGVjaWZpY2F0aW9uIGtleXMgdG8gc3BlY2lhbCBwcm9jZXNzaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbHRob3VnaCB0aGVzZSBhcmUgZGVjbGFyZWQgbGlrZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGluIHRoZSBzcGVjaWZpY2F0aW9uXG4gKiB3aGVuIGRlZmluaW5nIGNsYXNzZXMgdXNpbmcgYFJlYWN0LmNyZWF0ZUNsYXNzYCwgdGhleSBhcmUgYWN0dWFsbHkgc3RhdGljXG4gKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICogYmVpbmcgc3RhdGljLCB0aGV5IG11c3QgYmUgZGVmaW5lZCBvdXRzaWRlIG9mIHRoZSBcInN0YXRpY3NcIiBrZXkgdW5kZXJcbiAqIHdoaWNoIGFsbCBvdGhlciBzdGF0aWMgbWV0aG9kcyBhcmUgZGVmaW5lZC5cbiAqL1xudmFyIFJFU0VSVkVEX1NQRUNfS0VZUyA9IHtcbiAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICB9LFxuICBtaXhpbnM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XG4gICAgaWYgKG1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzLCAnY2hpbGRDb250ZXh0Jyk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dFR5cGVzKTtcbiAgfSxcbiAgY29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgJ2NvbnRleHQnKTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzLCBjb250ZXh0VHlwZXMpO1xuICB9LFxuICAvKipcbiAgICogU3BlY2lhbCBjYXNlIGdldERlZmF1bHRQcm9wcyB3aGljaCBzaG91bGQgbW92ZSBpbnRvIHN0YXRpY3MgYnV0IHJlcXVpcmVzXG4gICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcywgZ2V0RGVmYXVsdFByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzO1xuICAgIH1cbiAgfSxcbiAgcHJvcFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHByb3BUeXBlcywgJ3Byb3AnKTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICB9LFxuICBzdGF0aWNzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG4gIH0sXG4gIGF1dG9iaW5kOiBmdW5jdGlvbiAoKSB7fSB9O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHR5cGVEZWYsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIC8vIHVzZSBhIHdhcm5pbmcgaW5zdGVhZCBvZiBhbiBpbnZhcmlhbnQgc28gY29tcG9uZW50c1xuICAgICAgLy8gZG9uJ3Qgc2hvdyB1cCBpbiBwcm9kIGJ1dCBvbmx5IGluIF9fREVWX19cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKSB7XG4gIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV0gOiBudWxsO1xuXG4gIC8vIERpc2FsbG93IG92ZXJyaWRpbmcgb2YgYmFzZSBjbGFzcyBtZXRob2RzIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChSZWFjdENsYXNzTWl4aW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09ICdPVkVSUklERV9CQVNFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIG92ZXJyaWRlIGAlc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzIGRvIG5vdCBvdmVybGFwIHdpdGggUmVhY3QgbWV0aG9kcy4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3MycsIG5hbWUpIDogdm9pZCAwO1xuICB9XG5cbiAgLy8gRGlzYWxsb3cgZGVmaW5pbmcgbWV0aG9kcyBtb3JlIHRoYW4gb25jZSB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJyB8fCBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3NCcsIG5hbWUpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gKiBzcGVjaWZpY2F0aW9uIGtleXMgd2hlbiBidWlsZGluZyBSZWFjdCBjbGFzc2VzLlxuICovXG5mdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICBpZiAoIXNwZWMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHR5cGVvZlNwZWMgPSB0eXBlb2Ygc3BlYztcbiAgICAgIHZhciBpc01peGluVmFsaWQgPSB0eXBlb2ZTcGVjID09PSAnb2JqZWN0JyAmJiBzcGVjICE9PSBudWxsO1xuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpc01peGluVmFsaWQsICclczogWW91XFwncmUgYXR0ZW1wdGluZyB0byBpbmNsdWRlIGEgbWl4aW4gdGhhdCBpcyBlaXRoZXIgbnVsbCAnICsgJ29yIG5vdCBhbiBvYmplY3QuIENoZWNrIHRoZSBtaXhpbnMgaW5jbHVkZWQgYnkgdGhlIGNvbXBvbmVudCwgJyArICdhcyB3ZWxsIGFzIGFueSBtaXhpbnMgdGhleSBpbmNsdWRlIHRoZW1zZWx2ZXMuICcgKyAnRXhwZWN0ZWQgb2JqZWN0IGJ1dCBnb3QgJXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBzcGVjID09PSBudWxsID8gbnVsbCA6IHR5cGVvZlNwZWMpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gICEodHlwZW9mIHNwZWMgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdXNlIGEgY29tcG9uZW50IGNsYXNzIG9yIGZ1bmN0aW9uIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBfcHJvZEludmFyaWFudCgnNzUnKSA6IHZvaWQgMDtcbiAgISFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3BlYykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgYSBjb21wb25lbnQgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IF9wcm9kSW52YXJpYW50KCc3NicpIDogdm9pZCAwO1xuXG4gIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgdmFyIGF1dG9CaW5kUGFpcnMgPSBwcm90by5fX3JlYWN0QXV0b0JpbmRQYWlycztcblxuICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXG4gIC8vIG1peGlucyBhcmUgbGlzdGVkIGJlZm9yZSBvciBhZnRlciB0aGVzZSBtZXRob2RzIGluIHRoZSBzcGVjLlxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcbiAgfVxuXG4gIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpO1xuXG4gICAgaWYgKFJFU0VSVkVEX1NQRUNfS0VZUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldHVwIG1ldGhvZHMgb24gcHJvdG90eXBlOlxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAvLyAxLiBFeHBlY3RlZCBSZWFjdENsYXNzIG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cbiAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG4gICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPSBpc0Z1bmN0aW9uICYmICFpc1JlYWN0Q2xhc3NNZXRob2QgJiYgIWlzQWxyZWFkeURlZmluZWQgJiYgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuICAgICAgICBhdXRvQmluZFBhaXJzLnB1c2gobmFtZSwgcHJvcGVydHkpO1xuICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cbiAgICAgICAgICAhKGlzUmVhY3RDbGFzc01ldGhvZCAmJiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcgfHwgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyB3aGVuIG1peGluZyBpbiBjb21wb25lbnQgc3BlY3MuJywgc3BlY1BvbGljeSwgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzcnLCBzcGVjUG9saWN5LCBuYW1lKSA6IHZvaWQgMDtcblxuICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgIC8vIG1ldGhvZHMgYmVmb3JlIGNhbGxpbmcgdGhlIG5ldyBwcm9wZXJ0eSwgbWVyZ2luZyBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEFkZCB2ZXJib3NlIGRpc3BsYXlOYW1lIHRvIHRoZSBmdW5jdGlvbiwgd2hpY2ggaGVscHMgd2hlbiBsb29raW5nXG4gICAgICAgICAgICAvLyBhdCBwcm9maWxpbmcgdG9vbHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0uZGlzcGxheU5hbWUgPSBzcGVjLmRpc3BsYXlOYW1lICsgJ18nICsgbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgaWYgKCFzdGF0aWNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIG5hbWUgaW4gc3RhdGljcykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG4gICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IG5hbWUgaW4gUkVTRVJWRURfU1BFQ19LRVlTO1xuICAgICEhaXNSZXNlcnZlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgcHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0IGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IGluc3RlYWQ7IGl0IHdpbGwgc3RpbGwgYmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IuJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzgnLCBuYW1lKSA6IHZvaWQgMDtcblxuICAgIHZhciBpc0luaGVyaXRlZCA9IG5hbWUgaW4gQ29uc3RydWN0b3I7XG4gICAgISFpc0luaGVyaXRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGAlc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc5JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgIShvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nKSA6IF9wcm9kSW52YXJpYW50KCc4MCcpIDogdm9pZCAwO1xuXG4gIGZvciAodmFyIGtleSBpbiB0d28pIHtcbiAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICEob25lW2tleV0gPT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogYCVzYC4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gZ2V0SW5pdGlhbFN0YXRlKCkgb3IgZ2V0RGVmYXVsdFByb3BzKCkgbWV0aG9kcyByZXR1cm5pbmcgb2JqZWN0cyB3aXRoIGNsYXNoaW5nIGtleXMuJywga2V5KSA6IF9wcm9kSW52YXJpYW50KCc4MScsIGtleSkgOiB2b2lkIDA7XG4gICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb25lO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XG4gICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgYiA9IHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgdmFyIGMgPSB7fTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGEpO1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBpZ25vcmVzIHRoZWlyIHJldHVybiB2YWxlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQmluZHMgYSBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBib3VuZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xuICB2YXIgYm91bmRNZXRob2QgPSBtZXRob2QuYmluZChjb21wb25lbnQpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgdmFyIF9iaW5kID0gYm91bmRNZXRob2QuYmluZDtcbiAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24gKG5ld1RoaXMpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlciBpcyB0cnlpbmcgdG8gYmluZCgpIGFuIGF1dG9ib3VuZCBtZXRob2Q7IHdlIGVmZmVjdGl2ZWx5IHdpbGxcbiAgICAgIC8vIGlnbm9yZSB0aGUgdmFsdWUgb2YgXCJ0aGlzXCIgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlLCBzb1xuICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgIGlmIChuZXdUaGlzICE9PSBjb21wb25lbnQgJiYgbmV3VGhpcyAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgKyAnY29tcG9uZW50IGluc3RhbmNlLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBZb3UgYXJlIGJpbmRpbmcgYSBjb21wb25lbnQgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuICcgKyAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArICd3YXksIHNvIHlvdSBjYW4gc2FmZWx5IHJlbW92ZSB0aGlzIGNhbGwuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgICB9XG4gICAgICB2YXIgcmVib3VuZE1ldGhvZCA9IF9iaW5kLmFwcGx5KGJvdW5kTWV0aG9kLCBhcmd1bWVudHMpO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICByZXR1cm4gcmVib3VuZE1ldGhvZDtcbiAgICB9O1xuICB9XG4gIHJldHVybiBib3VuZE1ldGhvZDtcbn1cblxuLyoqXG4gKiBCaW5kcyBhbGwgYXV0by1ib3VuZCBtZXRob2RzIGluIGEgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcbiAgdmFyIHBhaXJzID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGF1dG9CaW5kS2V5ID0gcGFpcnNbaV07XG4gICAgdmFyIG1ldGhvZCA9IHBhaXJzW2kgKyAxXTtcbiAgICBjb21wb25lbnRbYXV0b0JpbmRLZXldID0gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxuICogdGhlcmVmb3JlIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIG1vZGVybiBSZWFjdENvbXBvbmVudC5cbiAqL1xudmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcblxuICAvKipcbiAgICogVE9ETzogVGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgYmVjYXVzZSBzdGF0ZSBzaG91bGQgYWx3YXlzIGtlZXAgYSBjb25zaXN0ZW50XG4gICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cbiAgICovXG4gIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVyLmlzTW91bnRlZCh0aGlzKTtcbiAgfVxufTtcblxudmFyIFJlYWN0Q2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7fTtcbl9hc3NpZ24oUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDbGFzc01peGluKTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIGNyZWF0aW5nIGNvbXBvc2l0ZSBjb21wb25lbnRzLlxuICpcbiAqIEBjbGFzcyBSZWFjdENsYXNzXG4gKi9cbnZhciBSZWFjdENsYXNzID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNyZWF0ZUNsYXNzOiBmdW5jdGlvbiAoc3BlYykge1xuICAgIC8vIFRvIGtlZXAgb3VyIHdhcm5pbmdzIG1vcmUgdW5kZXJzdGFuZGFibGUsIHdlJ2xsIHVzZSBhIGxpdHRsZSBoYWNrIGhlcmUgdG9cbiAgICAvLyBlbnN1cmUgdGhhdCBDb25zdHJ1Y3Rvci5uYW1lICE9PSAnQ29uc3RydWN0b3InLiBUaGlzIG1ha2VzIHN1cmUgd2UgZG9uJ3RcbiAgICAvLyB1bm5lY2Vzc2FyaWx5IGlkZW50aWZ5IGEgY2xhc3Mgd2l0aG91dCBkaXNwbGF5TmFtZSBhcyAnQ29uc3RydWN0b3InLlxuICAgIHZhciBDb25zdHJ1Y3RvciA9IGlkZW50aXR5KGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgLy8gVGhpcyBjb25zdHJ1Y3RvciBnZXRzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHRoaXMgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvciwgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgKyAnSlNYIGluc3RlYWQuIFNlZTogaHR0cHM6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5JykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRQYWlycy5sZW5ndGgpIHtcbiAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgIC8vIFJlYWN0Q2xhc3NlcyBkb2Vzbid0IGhhdmUgY29uc3RydWN0b3JzLiBJbnN0ZWFkLCB0aGV5IHVzZSB0aGVcbiAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxuXG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRJbml0aWFsU3RhdGUuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnODInLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICB9KTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5fX3JlYWN0QXV0b0JpbmRQYWlycyA9IFtdO1xuXG4gICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKSk7XG5cbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nKSA6IF9wcm9kSW52YXJpYW50KCc4MycpIDogdm9pZCAwO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50U2hvdWxkVXBkYXRlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/Jywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIFJlYWN0Q2xhc3NJbnRlcmZhY2UpIHtcbiAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdE1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIGluamVjdGVkTWl4aW5zLnB1c2gobWl4aW4pO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2xhc3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhY3RvcnkgdGhhdCBjcmVhdGVzIEhUTUwgdGFnIGVsZW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjcmVhdGVET01GYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbiAgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXBwaW5nIGZyb20gc3VwcG9ydGVkIEhUTUwgdGFncyB0byBgUmVhY3RET01Db21wb25lbnRgIGNsYXNzZXMuXG4gKiBUaGlzIGlzIGFsc28gYWNjZXNzaWJsZSB2aWEgYFJlYWN0LkRPTWAuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSB7XG4gIGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2EnKSxcbiAgYWJicjogY3JlYXRlRE9NRmFjdG9yeSgnYWJicicpLFxuICBhZGRyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdhZGRyZXNzJyksXG4gIGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ2FyZWEnKSxcbiAgYXJ0aWNsZTogY3JlYXRlRE9NRmFjdG9yeSgnYXJ0aWNsZScpLFxuICBhc2lkZTogY3JlYXRlRE9NRmFjdG9yeSgnYXNpZGUnKSxcbiAgYXVkaW86IGNyZWF0ZURPTUZhY3RvcnkoJ2F1ZGlvJyksXG4gIGI6IGNyZWF0ZURPTUZhY3RvcnkoJ2InKSxcbiAgYmFzZTogY3JlYXRlRE9NRmFjdG9yeSgnYmFzZScpLFxuICBiZGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JkaScpLFxuICBiZG86IGNyZWF0ZURPTUZhY3RvcnkoJ2JkbycpLFxuICBiaWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2JpZycpLFxuICBibG9ja3F1b3RlOiBjcmVhdGVET01GYWN0b3J5KCdibG9ja3F1b3RlJyksXG4gIGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JvZHknKSxcbiAgYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2JyJyksXG4gIGJ1dHRvbjogY3JlYXRlRE9NRmFjdG9yeSgnYnV0dG9uJyksXG4gIGNhbnZhczogY3JlYXRlRE9NRmFjdG9yeSgnY2FudmFzJyksXG4gIGNhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2NhcHRpb24nKSxcbiAgY2l0ZTogY3JlYXRlRE9NRmFjdG9yeSgnY2l0ZScpLFxuICBjb2RlOiBjcmVhdGVET01GYWN0b3J5KCdjb2RlJyksXG4gIGNvbDogY3JlYXRlRE9NRmFjdG9yeSgnY29sJyksXG4gIGNvbGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdjb2xncm91cCcpLFxuICBkYXRhOiBjcmVhdGVET01GYWN0b3J5KCdkYXRhJyksXG4gIGRhdGFsaXN0OiBjcmVhdGVET01GYWN0b3J5KCdkYXRhbGlzdCcpLFxuICBkZDogY3JlYXRlRE9NRmFjdG9yeSgnZGQnKSxcbiAgZGVsOiBjcmVhdGVET01GYWN0b3J5KCdkZWwnKSxcbiAgZGV0YWlsczogY3JlYXRlRE9NRmFjdG9yeSgnZGV0YWlscycpLFxuICBkZm46IGNyZWF0ZURPTUZhY3RvcnkoJ2RmbicpLFxuICBkaWFsb2c6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpYWxvZycpLFxuICBkaXY6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpdicpLFxuICBkbDogY3JlYXRlRE9NRmFjdG9yeSgnZGwnKSxcbiAgZHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2R0JyksXG4gIGVtOiBjcmVhdGVET01GYWN0b3J5KCdlbScpLFxuICBlbWJlZDogY3JlYXRlRE9NRmFjdG9yeSgnZW1iZWQnKSxcbiAgZmllbGRzZXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZWxkc2V0JyksXG4gIGZpZ2NhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ2NhcHRpb24nKSxcbiAgZmlndXJlOiBjcmVhdGVET01GYWN0b3J5KCdmaWd1cmUnKSxcbiAgZm9vdGVyOiBjcmVhdGVET01GYWN0b3J5KCdmb290ZXInKSxcbiAgZm9ybTogY3JlYXRlRE9NRmFjdG9yeSgnZm9ybScpLFxuICBoMTogY3JlYXRlRE9NRmFjdG9yeSgnaDEnKSxcbiAgaDI6IGNyZWF0ZURPTUZhY3RvcnkoJ2gyJyksXG4gIGgzOiBjcmVhdGVET01GYWN0b3J5KCdoMycpLFxuICBoNDogY3JlYXRlRE9NRmFjdG9yeSgnaDQnKSxcbiAgaDU6IGNyZWF0ZURPTUZhY3RvcnkoJ2g1JyksXG4gIGg2OiBjcmVhdGVET01GYWN0b3J5KCdoNicpLFxuICBoZWFkOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkJyksXG4gIGhlYWRlcjogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZGVyJyksXG4gIGhncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnaGdyb3VwJyksXG4gIGhyOiBjcmVhdGVET01GYWN0b3J5KCdocicpLFxuICBodG1sOiBjcmVhdGVET01GYWN0b3J5KCdodG1sJyksXG4gIGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2knKSxcbiAgaWZyYW1lOiBjcmVhdGVET01GYWN0b3J5KCdpZnJhbWUnKSxcbiAgaW1nOiBjcmVhdGVET01GYWN0b3J5KCdpbWcnKSxcbiAgaW5wdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucHV0JyksXG4gIGluczogY3JlYXRlRE9NRmFjdG9yeSgnaW5zJyksXG4gIGtiZDogY3JlYXRlRE9NRmFjdG9yeSgna2JkJyksXG4gIGtleWdlbjogY3JlYXRlRE9NRmFjdG9yeSgna2V5Z2VuJyksXG4gIGxhYmVsOiBjcmVhdGVET01GYWN0b3J5KCdsYWJlbCcpLFxuICBsZWdlbmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2xlZ2VuZCcpLFxuICBsaTogY3JlYXRlRE9NRmFjdG9yeSgnbGknKSxcbiAgbGluazogY3JlYXRlRE9NRmFjdG9yeSgnbGluaycpLFxuICBtYWluOiBjcmVhdGVET01GYWN0b3J5KCdtYWluJyksXG4gIG1hcDogY3JlYXRlRE9NRmFjdG9yeSgnbWFwJyksXG4gIG1hcms6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcmsnKSxcbiAgbWVudTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudScpLFxuICBtZW51aXRlbTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudWl0ZW0nKSxcbiAgbWV0YTogY3JlYXRlRE9NRmFjdG9yeSgnbWV0YScpLFxuICBtZXRlcjogY3JlYXRlRE9NRmFjdG9yeSgnbWV0ZXInKSxcbiAgbmF2OiBjcmVhdGVET01GYWN0b3J5KCduYXYnKSxcbiAgbm9zY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ25vc2NyaXB0JyksXG4gIG9iamVjdDogY3JlYXRlRE9NRmFjdG9yeSgnb2JqZWN0JyksXG4gIG9sOiBjcmVhdGVET01GYWN0b3J5KCdvbCcpLFxuICBvcHRncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnb3B0Z3JvdXAnKSxcbiAgb3B0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdvcHRpb24nKSxcbiAgb3V0cHV0OiBjcmVhdGVET01GYWN0b3J5KCdvdXRwdXQnKSxcbiAgcDogY3JlYXRlRE9NRmFjdG9yeSgncCcpLFxuICBwYXJhbTogY3JlYXRlRE9NRmFjdG9yeSgncGFyYW0nKSxcbiAgcGljdHVyZTogY3JlYXRlRE9NRmFjdG9yeSgncGljdHVyZScpLFxuICBwcmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3ByZScpLFxuICBwcm9ncmVzczogY3JlYXRlRE9NRmFjdG9yeSgncHJvZ3Jlc3MnKSxcbiAgcTogY3JlYXRlRE9NRmFjdG9yeSgncScpLFxuICBycDogY3JlYXRlRE9NRmFjdG9yeSgncnAnKSxcbiAgcnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3J0JyksXG4gIHJ1Ynk6IGNyZWF0ZURPTUZhY3RvcnkoJ3J1YnknKSxcbiAgczogY3JlYXRlRE9NRmFjdG9yeSgncycpLFxuICBzYW1wOiBjcmVhdGVET01GYWN0b3J5KCdzYW1wJyksXG4gIHNjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnc2NyaXB0JyksXG4gIHNlY3Rpb246IGNyZWF0ZURPTUZhY3RvcnkoJ3NlY3Rpb24nKSxcbiAgc2VsZWN0OiBjcmVhdGVET01GYWN0b3J5KCdzZWxlY3QnKSxcbiAgc21hbGw6IGNyZWF0ZURPTUZhY3RvcnkoJ3NtYWxsJyksXG4gIHNvdXJjZTogY3JlYXRlRE9NRmFjdG9yeSgnc291cmNlJyksXG4gIHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3NwYW4nKSxcbiAgc3Ryb25nOiBjcmVhdGVET01GYWN0b3J5KCdzdHJvbmcnKSxcbiAgc3R5bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0eWxlJyksXG4gIHN1YjogY3JlYXRlRE9NRmFjdG9yeSgnc3ViJyksXG4gIHN1bW1hcnk6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1bW1hcnknKSxcbiAgc3VwOiBjcmVhdGVET01GYWN0b3J5KCdzdXAnKSxcbiAgdGFibGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RhYmxlJyksXG4gIHRib2R5OiBjcmVhdGVET01GYWN0b3J5KCd0Ym9keScpLFxuICB0ZDogY3JlYXRlRE9NRmFjdG9yeSgndGQnKSxcbiAgdGV4dGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHRhcmVhJyksXG4gIHRmb290OiBjcmVhdGVET01GYWN0b3J5KCd0Zm9vdCcpLFxuICB0aDogY3JlYXRlRE9NRmFjdG9yeSgndGgnKSxcbiAgdGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoZWFkJyksXG4gIHRpbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpbWUnKSxcbiAgdGl0bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpdGxlJyksXG4gIHRyOiBjcmVhdGVET01GYWN0b3J5KCd0cicpLFxuICB0cmFjazogY3JlYXRlRE9NRmFjdG9yeSgndHJhY2snKSxcbiAgdTogY3JlYXRlRE9NRmFjdG9yeSgndScpLFxuICB1bDogY3JlYXRlRE9NRmFjdG9yeSgndWwnKSxcbiAgJ3Zhcic6IGNyZWF0ZURPTUZhY3RvcnkoJ3ZhcicpLFxuICB2aWRlbzogY3JlYXRlRE9NRmFjdG9yeSgndmlkZW8nKSxcbiAgd2JyOiBjcmVhdGVET01GYWN0b3J5KCd3YnInKSxcblxuICAvLyBTVkdcbiAgY2lyY2xlOiBjcmVhdGVET01GYWN0b3J5KCdjaXJjbGUnKSxcbiAgY2xpcFBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ2NsaXBQYXRoJyksXG4gIGRlZnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlZnMnKSxcbiAgZWxsaXBzZTogY3JlYXRlRE9NRmFjdG9yeSgnZWxsaXBzZScpLFxuICBnOiBjcmVhdGVET01GYWN0b3J5KCdnJyksXG4gIGltYWdlOiBjcmVhdGVET01GYWN0b3J5KCdpbWFnZScpLFxuICBsaW5lOiBjcmVhdGVET01GYWN0b3J5KCdsaW5lJyksXG4gIGxpbmVhckdyYWRpZW50OiBjcmVhdGVET01GYWN0b3J5KCdsaW5lYXJHcmFkaWVudCcpLFxuICBtYXNrOiBjcmVhdGVET01GYWN0b3J5KCdtYXNrJyksXG4gIHBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdGgnKSxcbiAgcGF0dGVybjogY3JlYXRlRE9NRmFjdG9yeSgncGF0dGVybicpLFxuICBwb2x5Z29uOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5Z29uJyksXG4gIHBvbHlsaW5lOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5bGluZScpLFxuICByYWRpYWxHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgncmFkaWFsR3JhZGllbnQnKSxcbiAgcmVjdDogY3JlYXRlRE9NRmFjdG9yeSgncmVjdCcpLFxuICBzdG9wOiBjcmVhdGVET01GYWN0b3J5KCdzdG9wJyksXG4gIHN2ZzogY3JlYXRlRE9NRmFjdG9yeSgnc3ZnJyksXG4gIHRleHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHQnKSxcbiAgdHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3RzcGFuJylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GYWN0b3JpZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBjaGVja1JlYWN0VHlwZVNwZWMgPSByZXF1aXJlKCcuL2NoZWNrUmVhY3RUeXBlU3BlYycpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJyBDaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBtZW1vaXplciA9IG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgfHwgKG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgPSB7fSk7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAobWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBlbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLic7XG4gIH1cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpKSA6IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICAvLyBFbnRyeSBpdGVyYXRvcnMgcHJvdmlkZSBpbXBsaWNpdCBrZXlzLlxuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIGlmIChjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMpIHtcbiAgICBjaGVja1JlYWN0VHlwZVNwZWMoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQsIG51bGwpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSB7XG5cbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbic7XG4gICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyAnaXRcXCdzIGRlZmluZWQgaW4uJztcbiAgICAgICAgfVxuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdm9pZCAwO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gaXNOYXRpdmUoZm4pIHtcbiAgLy8gQmFzZWQgb24gaXNOYXRpdmUoKSBmcm9tIExvZGFzaFxuICB2YXIgZnVuY1RvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgKyBmdW5jVG9TdHJpbmdcbiAgLy8gVGFrZSBhbiBleGFtcGxlIG5hdGl2ZSBmdW5jdGlvbiBzb3VyY2UgZm9yIGNvbXBhcmlzb25cbiAgLmNhbGwoaGFzT3duUHJvcGVydHkpXG4gIC8vIFN0cmlwIHJlZ2V4IGNoYXJhY3RlcnMgc28gd2UgY2FuIHVzZSBpdCBmb3IgcmVnZXhcbiAgLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLy8gUmVtb3ZlIGhhc093blByb3BlcnR5IGZyb20gdGhlIHRlbXBsYXRlIHRvIG1ha2UgaXQgZ2VuZXJpY1xuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCcpO1xuICB0cnkge1xuICAgIHZhciBzb3VyY2UgPSBmdW5jVG9TdHJpbmcuY2FsbChmbik7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChzb3VyY2UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxudmFyIGNhblVzZUNvbGxlY3Rpb25zID1cbi8vIEFycmF5LmZyb21cbnR5cGVvZiBBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nICYmXG4vLyBNYXBcbnR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwKSAmJlxuLy8gTWFwLnByb3RvdHlwZS5rZXlzXG5NYXAucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXAucHJvdG90eXBlLmtleXMpICYmXG4vLyBTZXRcbnR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoU2V0KSAmJlxuLy8gU2V0LnByb3RvdHlwZS5rZXlzXG5TZXQucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQucHJvdG90eXBlLmtleXMpO1xuXG52YXIgc2V0SXRlbTtcbnZhciBnZXRJdGVtO1xudmFyIHJlbW92ZUl0ZW07XG52YXIgZ2V0SXRlbUlEcztcbnZhciBhZGRSb290O1xudmFyIHJlbW92ZVJvb3Q7XG52YXIgZ2V0Um9vdElEcztcblxuaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gIHZhciBpdGVtTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgcm9vdElEU2V0ID0gbmV3IFNldCgpO1xuXG4gIHNldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcbiAgICBpdGVtTWFwLnNldChpZCwgaXRlbSk7XG4gIH07XG4gIGdldEl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gaXRlbU1hcC5nZXQoaWQpO1xuICB9O1xuICByZW1vdmVJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaXRlbU1hcFsnZGVsZXRlJ10oaWQpO1xuICB9O1xuICBnZXRJdGVtSURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZW1NYXAua2V5cygpKTtcbiAgfTtcblxuICBhZGRSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcm9vdElEU2V0LmFkZChpZCk7XG4gIH07XG4gIHJlbW92ZVJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByb290SURTZXRbJ2RlbGV0ZSddKGlkKTtcbiAgfTtcbiAgZ2V0Um9vdElEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShyb290SURTZXQua2V5cygpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBpdGVtQnlLZXkgPSB7fTtcbiAgdmFyIHJvb3RCeUtleSA9IHt9O1xuXG4gIC8vIFVzZSBub24tbnVtZXJpYyBrZXlzIHRvIHByZXZlbnQgVjggcGVyZm9ybWFuY2UgaXNzdWVzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXG4gIHZhciBnZXRLZXlGcm9tSUQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gJy4nICsgaWQ7XG4gIH07XG4gIHZhciBnZXRJREZyb21LZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGtleS5zdWJzdHIoMSksIDEwKTtcbiAgfTtcblxuICBzZXRJdGVtID0gZnVuY3Rpb24gKGlkLCBpdGVtKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgaXRlbUJ5S2V5W2tleV0gPSBpdGVtO1xuICB9O1xuICBnZXRJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgcmV0dXJuIGl0ZW1CeUtleVtrZXldO1xuICB9O1xuICByZW1vdmVJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgZGVsZXRlIGl0ZW1CeUtleVtrZXldO1xuICB9O1xuICBnZXRJdGVtSURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtQnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xuICB9O1xuXG4gIGFkZFJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICByb290QnlLZXlba2V5XSA9IHRydWU7XG4gIH07XG4gIHJlbW92ZVJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgcm9vdEJ5S2V5W2tleV07XG4gIH07XG4gIGdldFJvb3RJRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvb3RCeUtleSkubWFwKGdldElERnJvbUtleSk7XG4gIH07XG59XG5cbnZhciB1bm1vdW50ZWRJRHMgPSBbXTtcblxuZnVuY3Rpb24gcHVyZ2VEZWVwKGlkKSB7XG4gIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gIGlmIChpdGVtKSB7XG4gICAgdmFyIGNoaWxkSURzID0gaXRlbS5jaGlsZElEcztcblxuICAgIHJlbW92ZUl0ZW0oaWQpO1xuICAgIGNoaWxkSURzLmZvckVhY2gocHVyZ2VEZWVwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiAnI2VtcHR5JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICcjdGV4dCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlSUQoaWQpIHtcbiAgdmFyIG5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKTtcbiAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcklEKSB7XG4gICAgb3duZXJOYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShvd25lcklEKTtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50LCAnUmVhY3RDb21wb25lbnRUcmVlSG9vazogTWlzc2luZyBSZWFjdCBlbGVtZW50IGZvciBkZWJ1Z0lEICVzIHdoZW4gJyArICdidWlsZGluZyBzdGFjaycsIGlkKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgZWxlbWVudCAmJiBlbGVtZW50Ll9zb3VyY2UsIG93bmVyTmFtZSk7XG59XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0ge1xuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoaWQsIG5leHRDaGlsZElEcykge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgIWl0ZW0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSXRlbSBtdXN0IGhhdmUgYmVlbiBzZXQnKSA6IF9wcm9kSW52YXJpYW50KCcxNDQnKSA6IHZvaWQgMDtcbiAgICBpdGVtLmNoaWxkSURzID0gbmV4dENoaWxkSURzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Q2hpbGRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRJRCA9IG5leHRDaGlsZElEc1tpXTtcbiAgICAgIHZhciBuZXh0Q2hpbGQgPSBnZXRJdGVtKG5leHRDaGlsZElEKTtcbiAgICAgICFuZXh0Q2hpbGQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9vayBldmVudHMgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDAnKSA6IHZvaWQgMDtcbiAgICAgICEobmV4dENoaWxkLmNoaWxkSURzICE9IG51bGwgfHwgdHlwZW9mIG5leHRDaGlsZC5lbGVtZW50ICE9PSAnb2JqZWN0JyB8fCBuZXh0Q2hpbGQuZWxlbWVudCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvblNldENoaWxkcmVuKCkgdG8gZmlyZSBmb3IgYSBjb250YWluZXIgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MScpIDogdm9pZCAwO1xuICAgICAgIW5leHRDaGlsZC5pc01vdW50ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25Nb3VudENvbXBvbmVudCgpIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnNzEnKSA6IHZvaWQgMDtcbiAgICAgIGlmIChuZXh0Q2hpbGQucGFyZW50SUQgPT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGQucGFyZW50SUQgPSBpZDtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IGJ1dCBtb3VudGluZyBhIG5ldyByb290IGR1cmluZyBpblxuICAgICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgY3VycmVudGx5IGNhdXNlcyBub3QteWV0LW1vdW50ZWQgY29tcG9uZW50cyB0b1xuICAgICAgICAvLyBiZSBwdXJnZWQgZnJvbSBvdXIgdHJlZSBkYXRhIHNvIHRoZWlyIHBhcmVudCBpZCBpcyBtaXNzaW5nLlxuICAgICAgfVxuICAgICAgIShuZXh0Q2hpbGQucGFyZW50SUQgPT09IGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbkJlZm9yZU1vdW50Q29tcG9uZW50KCkgcGFyZW50IGFuZCBvblNldENoaWxkcmVuKCkgdG8gYmUgY29uc2lzdGVudCAoJXMgaGFzIHBhcmVudHMgJXMgYW5kICVzKS4nLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiBfcHJvZEludmFyaWFudCgnMTQyJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogdm9pZCAwO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBwYXJlbnRJRCkge1xuICAgIHZhciBpdGVtID0ge1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICAgIHRleHQ6IG51bGwsXG4gICAgICBjaGlsZElEczogW10sXG4gICAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgICAgdXBkYXRlQ291bnQ6IDBcbiAgICB9O1xuICAgIHNldEl0ZW0oaWQsIGl0ZW0pO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50KSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0uZWxlbWVudCA9IGVsZW1lbnQ7XG4gIH0sXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgIWl0ZW0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSXRlbSBtdXN0IGhhdmUgYmVlbiBzZXQnKSA6IF9wcm9kSW52YXJpYW50KCcxNDQnKSA6IHZvaWQgMDtcbiAgICBpdGVtLmlzTW91bnRlZCA9IHRydWU7XG4gICAgdmFyIGlzUm9vdCA9IGl0ZW0ucGFyZW50SUQgPT09IDA7XG4gICAgaWYgKGlzUm9vdCkge1xuICAgICAgYWRkUm9vdChpZCk7XG4gICAgfVxuICB9LFxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0udXBkYXRlQ291bnQrKztcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIGl0IGV4aXN0cy5cbiAgICAgIC8vIGBpdGVtYCBtaWdodCBub3QgZXhpc3QgaWYgaXQgaXMgaW5zaWRlIGFuIGVycm9yIGJvdW5kYXJ5LCBhbmQgYSBzaWJsaW5nXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSBjaGlsZCB0aHJldyB3aGlsZSBtb3VudGluZy4gVGhlbiB0aGlzIGluc3RhbmNlIG5ldmVyXG4gICAgICAvLyBnb3QgYSBjaGFuY2UgdG8gbW91bnQsIGJ1dCBpdCBzdGlsbCBnZXRzIGFuIHVubW91bnRpbmcgZXZlbnQgZHVyaW5nXG4gICAgICAvLyB0aGUgZXJyb3IgYm91bmRhcnkgY2xlYW51cC5cbiAgICAgIGl0ZW0uaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcbiAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgcmVtb3ZlUm9vdChpZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5wdXNoKGlkKTtcbiAgfSxcbiAgcHVyZ2VVbm1vdW50ZWRDb21wb25lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0Q29tcG9uZW50VHJlZUhvb2suX3ByZXZlbnRQdXJnaW5nKSB7XG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0aW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5tb3VudGVkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSB1bm1vdW50ZWRJRHNbaV07XG4gICAgICBwdXJnZURlZXAoaWQpO1xuICAgIH1cbiAgICB1bm1vdW50ZWRJRHMubGVuZ3RoID0gMDtcbiAgfSxcbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5pc01vdW50ZWQgOiBmYWxzZTtcbiAgfSxcbiAgZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW06IGZ1bmN0aW9uICh0b3BFbGVtZW50KSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodG9wRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZSh0b3BFbGVtZW50KTtcbiAgICAgIHZhciBvd25lciA9IHRvcEVsZW1lbnQuX293bmVyO1xuICAgICAgaW5mbyArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHRvcEVsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudE93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB2YXIgaWQgPSBjdXJyZW50T3duZXIgJiYgY3VycmVudE93bmVyLl9kZWJ1Z0lEO1xuXG4gICAgaW5mbyArPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGlkKTtcbiAgICByZXR1cm4gaW5mbztcbiAgfSxcbiAgZ2V0U3RhY2tBZGRlbmR1bUJ5SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgd2hpbGUgKGlkKSB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlSUQoaWQpO1xuICAgICAgaWQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldENoaWxkSURzOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5jaGlsZElEcyA6IFtdO1xuICB9LFxuICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXREaXNwbGF5TmFtZShlbGVtZW50KTtcbiAgfSxcbiAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XG4gIH0sXG4gIGdldE93bmVySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuX293bmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQuX293bmVyLl9kZWJ1Z0lEO1xuICB9LFxuICBnZXRQYXJlbnRJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0ucGFyZW50SUQgOiBudWxsO1xuICB9LFxuICBnZXRTb3VyY2U6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgdmFyIGVsZW1lbnQgPSBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudCAhPSBudWxsID8gZWxlbWVudC5fc291cmNlIDogbnVsbDtcbiAgICByZXR1cm4gc291cmNlO1xuICB9LFxuICBnZXRUZXh0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnJyArIGVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgZ2V0VXBkYXRlQ291bnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnVwZGF0ZUNvdW50IDogMDtcbiAgfSxcblxuXG4gIGdldFJvb3RJRHM6IGdldFJvb3RJRHMsXG4gIGdldFJlZ2lzdGVyZWRJRHM6IGdldEl0ZW1JRHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9vYmplY3R9IGVsZW1lbnQgVGhlIFJlYWN0IGVsZW1lbnQgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7P251bWJlcn0gZGVidWdJRCBUaGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50LCBkZWJ1Z0lEKSB7XG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcikgOiB2b2lkIDA7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2tJbmZvID0gJyc7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlYnVnSUQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgY29tcG9uZW50U3RhY2tJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1JlYWN0VHlwZVNwZWM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvY2hlY2tSZWFjdFR5cGVTcGVjLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gKlxuICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICpcbiAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICogICAgIH0sXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAqICAgfSk7XG4gKlxuICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICpcbiAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gKlxuICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICpcbiAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gKiAgICAgICAgICApO1xuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSxcbiAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICogIH0pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxufTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG4vKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuLyoqXG4gKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyIHdlIGRvbid0IHVzZSByZWFsXG4gKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gJyc7XG59XG4vLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG5Qcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgfVxuICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICBpZiAoIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArICdhbmQgd2lsbCBub3Qgd29yayBpbiBwcm9kdWN0aW9uIHdpdGggdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gJyArICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgKyAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJywgcHJvcEZ1bGxOYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMobnVsbCkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICB9XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKCFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgIH1cbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAvLyBOYXRpdmUgU3ltYm9sLlxuICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG5mdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG4gIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgcmV0dXJuICdvYmplY3QnO1xuICB9XG4gIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgIHJldHVybiAnc3ltYm9sJztcbiAgfVxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbi8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuICdkYXRlJztcbiAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIHJldHVybiBBTk9OWU1PVVM7XG4gIH1cbiAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMTUuNC4yJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdFZlcnNpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDMnKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9ubHlDaGlsZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9vbmx5Q2hpbGQuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3RET00nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qIGdsb2JhbHMgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERlZmF1bHRJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEluamVjdGlvbicpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlID0gcmVxdWlyZSgnLi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZScpO1xudmFyIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVxdWlyZSgnLi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cblJlYWN0RGVmYXVsdEluamVjdGlvbi5pbmplY3QoKTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBmaW5kRE9NTm9kZTogZmluZERPTU5vZGUsXG4gIHJlbmRlcjogUmVhY3RNb3VudC5yZW5kZXIsXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzLFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbn07XG5cbi8vIEluamVjdCB0aGUgcnVudGltZSBpbnRvIGEgZGV2dG9vbHMgZ2xvYmFsIGhvb2sgcmVnYXJkbGVzcyBvZiBicm93c2VyLlxuLy8gQWxsb3dzIGZvciBkZWJ1Z2dpbmcgd2hlbiB0aGUgaG9vayBpcyBpbmplY3RlZCBvbiB0aGUgcGFnZS5cbmlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcbiAgICBDb21wb25lbnRUcmVlOiB7XG4gICAgICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICAgICAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgLy8gaW5zdCBpcyBhbiBpbnRlcm5hbCBpbnN0YW5jZSAoYnV0IGNvdWxkIGJlIGEgY29tcG9zaXRlKVxuICAgICAgICBpZiAoaW5zdC5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgICAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIFJlY29uY2lsZXI6IFJlYWN0UmVjb25jaWxlclxuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgZGV2dG9vbHMgaXMgbm90IGluc3RhbGxlZFxuICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3QgaGF2ZSB0aGUgaXNzdWUgd2l0aCBkZXZ0b29scyBsb2FkZWQgb3ZlciBmaWxlOi8vXG4gICAgICAgIHZhciBzaG93RmlsZVVybE1lc3NhZ2UgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpID09PSAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyAnICsgKHNob3dGaWxlVXJsTWVzc2FnZSA/ICdhbmQgdXNlIGFuIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGEgZmlsZTogVVJMKSAnIDogJycpICsgJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGVzdEZ1bmMgPSBmdW5jdGlvbiB0ZXN0Rm4oKSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZygodGVzdEZ1bmMubmFtZSB8fCB0ZXN0RnVuYy50b1N0cmluZygpKS5pbmRleE9mKCd0ZXN0Rm4nKSAhPT0gLTEsICdJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGEgbWluaWZpZWQgY29weSBvZiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgJyArICdvZiBSZWFjdC4gV2hlbiBkZXBsb3lpbmcgUmVhY3QgYXBwcyB0byBwcm9kdWN0aW9uLCBtYWtlIHN1cmUgdG8gdXNlICcgKyAndGhlIHByb2R1Y3Rpb24gYnVpbGQgd2hpY2ggc2tpcHMgZGV2ZWxvcG1lbnQgd2FybmluZ3MgYW5kIGlzIGZhc3Rlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1taW5pZmljYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKSA6IHZvaWQgMDtcblxuICAgIC8vIElmIHdlJ3JlIGluIElFOCwgY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgYW5kIHByb3ZpZGVcbiAgICAvLyBpbmZvcm1hdGlvbiBvbiBwcmV2ZW50aW5nIGNvbXBhdGliaWxpdHkgbW9kZVxuICAgIHZhciBpZUNvbXBhdGliaWxpdHlNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDg7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaWVDb21wYXRpYmlsaXR5TW9kZSwgJ0ludGVybmV0IEV4cGxvcmVyIGlzIHJ1bm5pbmcgaW4gY29tcGF0aWJpbGl0eSBtb2RlOyBwbGVhc2UgYWRkIHRoZSAnICsgJ2ZvbGxvd2luZyB0YWcgdG8geW91ciBIVE1MIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZzogJyArICc8bWV0YSBodHRwLWVxdWl2PVwiWC1VQS1Db21wYXRpYmxlXCIgY29udGVudD1cIklFPWVkZ2VcIiAvPicpIDogdm9pZCAwO1xuXG4gICAgdmFyIGV4cGVjdGVkRmVhdHVyZXMgPSBbXG4gICAgLy8gc2hpbXNcbiAgICBBcnJheS5pc0FycmF5LCBBcnJheS5wcm90b3R5cGUuZXZlcnksIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiwgQXJyYXkucHJvdG90eXBlLm1hcCwgRGF0ZS5ub3csIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBPYmplY3Qua2V5cywgU3RyaW5nLnByb3RvdHlwZS50cmltXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFleHBlY3RlZEZlYXR1cmVzW2ldKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnT25lIG9yIG1vcmUgRVM1IHNoaW1zIGV4cGVjdGVkIGJ5IFJlYWN0IGFyZSBub3QgYXZhaWxhYmxlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1wb2x5ZmlsbHMnKSA6IHZvaWQgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbiAgdmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rJyk7XG4gIHZhciBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaycpO1xuICB2YXIgUmVhY3RET01JbnZhbGlkQVJJQUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NSW52YWxpZEFSSUFIb29rJyk7XG5cbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLmFkZEhvb2soUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rKTtcbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLmFkZEhvb2soUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rKTtcbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLmFkZEhvb2soUmVhY3RET01JbnZhbGlkQVJJQUhvb2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcblxudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEludGVybmFsSW5zdGFuY2UkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gbm9kZSBzaG91bGQgYmUgY2FjaGVkLlxuICovXG5mdW5jdGlvbiBzaG91bGRQcmVjYWNoZU5vZGUobm9kZSwgbm9kZUlEKSB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgPT09IFN0cmluZyhub2RlSUQpIHx8IG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtdGV4dDogJyArIG5vZGVJRCArICcgJyB8fCBub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LWVtcHR5OiAnICsgbm9kZUlEICsgJyAnO1xufVxuXG4vKipcbiAqIERyaWxsIGRvd24gKHRocm91Z2ggY29tcG9zaXRlcyBhbmQgZW1wdHkgY29tcG9uZW50cykgdW50aWwgd2UgZ2V0IGEgaG9zdCBvclxuICogaG9zdCB0ZXh0IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIHByZXR0eSBwb2x5bW9ycGhpYyBidXQgdW5hdm9pZGFibGUgd2l0aCB0aGUgY3VycmVudCBzdHJ1Y3R1cmUgd2UgaGF2ZVxuICogZm9yIGBfcmVuZGVyZWRDaGlsZHJlbmAuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY29tcG9uZW50KSB7XG4gIHZhciByZW5kZXJlZDtcbiAgd2hpbGUgKHJlbmRlcmVkID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudCA9IHJlbmRlcmVkO1xuICB9XG4gIHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gdGhlIHJlbmRlcmVkIGhvc3QvdGV4dCBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW5cbiAqIERPTSBub2RlLiBUaGUgcGFzc2VkIGBpbnN0YCBjYW4gYmUgYSBjb21wb3NpdGUuXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlTm9kZShpbnN0LCBub2RlKSB7XG4gIHZhciBob3N0SW5zdCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoaW5zdCk7XG4gIGhvc3RJbnN0Ll9ob3N0Tm9kZSA9IG5vZGU7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuZnVuY3Rpb24gdW5jYWNoZU5vZGUoaW5zdCkge1xuICB2YXIgbm9kZSA9IGluc3QuX2hvc3ROb2RlO1xuICBpZiAobm9kZSkge1xuICAgIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICAgIGluc3QuX2hvc3ROb2RlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIGVhY2ggY2hpbGQgb2YgYGluc3RgLCBhc3N1bWluZyB0aGF0IHRoZSBjaGlsZHJlblxuICogbWF0Y2ggdXAgd2l0aCB0aGUgRE9NIChlbGVtZW50KSBjaGlsZHJlbiBvZiBgbm9kZWAuXG4gKlxuICogV2UgY2FjaGUgZW50aXJlIGxldmVscyBhdCBvbmNlIHRvIGF2b2lkIGFuIG5eMiBwcm9ibGVtIHdoZXJlIHdlIGFjY2VzcyB0aGVcbiAqIGNoaWxkcmVuIG9mIGEgbm9kZSBzZXF1ZW50aWFsbHkgYW5kIGhhdmUgdG8gd2FsayBmcm9tIHRoZSBzdGFydCB0byBvdXIgdGFyZ2V0XG4gKiBub2RlIGV2ZXJ5IHRpbWUuXG4gKlxuICogU2luY2Ugd2UgdXBkYXRlIGBfcmVuZGVyZWRDaGlsZHJlbmAgYW5kIHRoZSBhY3R1YWwgRE9NIGF0IChzbGlnaHRseSlcbiAqIGRpZmZlcmVudCB0aW1lcywgd2UgY291bGQgcmFjZSBoZXJlIGFuZCBzZWUgYSBuZXdlciBgX3JlbmRlcmVkQ2hpbGRyZW5gIHRoYW5cbiAqIHRoZSBET00gbm9kZXMgd2Ugc2VlLiBUbyBhdm9pZCB0aGlzLCBSZWFjdE11bHRpQ2hpbGQgY2FsbHNcbiAqIGBwcmVwYXJlVG9NYW5hZ2VDaGlsZHJlbmAgYmVmb3JlIHdlIGNoYW5nZSBgX3JlbmRlcmVkQ2hpbGRyZW5gLCBhdCB3aGljaFxuICogdGltZSB0aGUgY29udGFpbmVyJ3MgY2hpbGQgbm9kZXMgYXJlIGFsd2F5cyBjYWNoZWQgKHVudGlsIGl0IHVubW91bnRzKS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpIHtcbiAgaWYgKGluc3QuX2ZsYWdzICYgRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBpbnN0Ll9yZW5kZXJlZENoaWxkcmVuO1xuICB2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBvdXRlcjogZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0ID0gY2hpbGRyZW5bbmFtZV07XG4gICAgdmFyIGNoaWxkSUQgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNoaWxkSW5zdCkuX2RvbUlEO1xuICAgIGlmIChjaGlsZElEID09PSAwKSB7XG4gICAgICAvLyBXZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZyB0aGlzIGNoaWxkIGluIFJlYWN0TXVsdGlDaGlsZDsgc2tpcCBpdC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBXZSBhc3N1bWUgdGhlIGNoaWxkIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY2hpbGQgaW5zdGFuY2VzLlxuICAgIGZvciAoOyBjaGlsZE5vZGUgIT09IG51bGw7IGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZykge1xuICAgICAgaWYgKHNob3VsZFByZWNhY2hlTm9kZShjaGlsZE5vZGUsIGNoaWxkSUQpKSB7XG4gICAgICAgIHByZWNhY2hlTm9kZShjaGlsZEluc3QsIGNoaWxkTm9kZSk7XG4gICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIERPTSBjaGlsZHJlbiB3aXRob3V0IGZpbmRpbmcgYW4gSUQgbWF0Y2guXG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIGVsZW1lbnQgd2l0aCBJRCAlcy4nLCBjaGlsZElEKSA6IF9wcm9kSW52YXJpYW50KCczMicsIGNoaWxkSUQpIDogdm9pZCAwO1xuICB9XG4gIGluc3QuX2ZsYWdzIHw9IEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXM7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IFJlYWN0RE9NQ29tcG9uZW50IG9yXG4gKiBSZWFjdERPTVRleHRDb21wb25lbnQgaW5zdGFuY2UgYW5jZXN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBpbnN0YW5jZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xuICAgICAgLy8gdW5tb3VudGVkLCBwb3RlbnRpYWxseSkuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY2xvc2VzdDtcbiAgdmFyIGluc3Q7XG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgY2xvc2VzdCA9IGluc3Q7XG4gICAgaWYgKHBhcmVudHMubGVuZ3RoKSB7XG4gICAgICBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIHZhciBpbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIGlmIChpbnN0ICE9IG51bGwgJiYgaW5zdC5faG9zdE5vZGUgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIHtcbiAgLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuICAhKGluc3QuX2hvc3ROb2RlICE9PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcblxuICBpZiAoaW5zdC5faG9zdE5vZGUpIHtcbiAgICByZXR1cm4gaW5zdC5faG9zdE5vZGU7XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgRE9NIG5vZGUgd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghaW5zdC5faG9zdE5vZGUpIHtcbiAgICBwYXJlbnRzLnB1c2goaW5zdCk7XG4gICAgIWluc3QuX2hvc3RQYXJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgRE9NIHRyZWUgcm9vdCBzaG91bGQgYWx3YXlzIGhhdmUgYSBub2RlIHJlZmVyZW5jZS4nKSA6IF9wcm9kSW52YXJpYW50KCczNCcpIDogdm9pZCAwO1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG5cbiAgLy8gTm93IHBhcmVudHMgY29udGFpbnMgZWFjaCBhbmNlc3RvciB0aGF0IGRvZXMgKm5vdCogaGF2ZSBhIGNhY2hlZCBuYXRpdmVcbiAgLy8gbm9kZSwgYW5kIGBpbnN0YCBpcyB0aGUgZGVlcGVzdCBhbmNlc3RvciB0aGF0IGRvZXMuXG4gIGZvciAoOyBwYXJlbnRzLmxlbmd0aDsgaW5zdCA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgaW5zdC5faG9zdE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGluc3QuX2hvc3ROb2RlO1xufVxuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0ge1xuICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGdldEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UsXG4gIHByZWNhY2hlQ2hpbGROb2RlczogcHJlY2FjaGVDaGlsZE5vZGVzLFxuICBwcmVjYWNoZU5vZGU6IHByZWNhY2hlTm9kZSxcbiAgdW5jYWNoZU5vZGU6IHVuY2FjaGVOb2RlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnRUcmVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG5mdW5jdGlvbiByZWFjdFByb2RJbnZhcmlhbnQoY29kZSkge1xuICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblxuICB2YXIgbWVzc2FnZSA9ICdNaW5pZmllZCBSZWFjdCBlcnJvciAjJyArIGNvZGUgKyAnOyB2aXNpdCAnICsgJ2h0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PScgKyBjb2RlO1xuXG4gIGZvciAodmFyIGFyZ0lkeCA9IDA7IGFyZ0lkeCA8IGFyZ0NvdW50OyBhcmdJZHgrKykge1xuICAgIG1lc3NhZ2UgKz0gJyZhcmdzW109JyArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYXJnSWR4ICsgMV0pO1xuICB9XG5cbiAgbWVzc2FnZSArPSAnIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCcgKyAnIGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLic7XG5cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgcmVhY3RQcm9kSW52YXJpYW50J3Mgb3duIGZyYW1lXG5cbiAgdGhyb3cgZXJyb3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3RQcm9kSW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9yZWFjdFByb2RJbnZhcmlhbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSBcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSBpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSBpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc0OCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciBudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzJywgcHJvcE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzUwJywgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9IERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gJzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogRE9NUHJvcGVydHkgZXhwb3J0cyBsb29rdXAgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGxpa2UgZnVuY3Rpb25zOlxuICpcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXG4gKiAgIHRydWVcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxuICogICB1bmRlZmluZWRcbiAqXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxuICpcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LWV4aXN0c1xuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xuICovXG52YXIgRE9NUHJvcGVydHkgPSB7XG5cbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxuICBST09UX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdHJvb3QnLFxuXG4gIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIsXG4gIEFUVFJJQlVURV9OQU1FX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnLFxuXG4gIC8qKlxuICAgKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAgICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICAgKlxuICAgKiBhdHRyaWJ1dGVOYW1lOlxuICAgKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICAgKiBwcm9wZXJ0eU5hbWU6XG4gICAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gICAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXG4gICAqIG11dGF0aW9uTWV0aG9kOlxuICAgKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAgICogICBpbml0aWFsIHJlbmRlci5cbiAgICogbXVzdFVzZVByb3BlcnR5OlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBoYXNCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAgICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAgICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqL1xuICBwcm9wZXJ0aWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cbiAgICpcbiAgICogYXV0b2ZvY3VzIGlzIHByZWRlZmluZWQsIGJlY2F1c2UgYWRkaW5nIGl0IHRvIHRoZSBwcm9wZXJ0eSB3aGl0ZWxpc3RcbiAgICogY2F1c2VzIHVuaW50ZW5kZWQgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UG9zc2libGVTdGFuZGFyZE5hbWU6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7IGF1dG9mb2N1czogJ2F1dG9Gb2N1cycgfSA6IG51bGwsXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXG4gICAqL1xuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzQ3VzdG9tQXR0cmlidXRlRm4gPSBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnNbaV07XG4gICAgICBpZiAoaXNDdXN0b21BdHRyaWJ1dGVGbihhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGluamVjdGlvbjogRE9NUHJvcGVydHlJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSB7XG4gIGhhc0NhY2hlZENoaWxkTm9kZXM6IDEgPDwgMFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudEZsYWdzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEFSSUFET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vQVJJQURPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQmVmb3JlSW5wdXRFdmVudFBsdWdpbicpO1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9DaGFuZ2VFdmVudFBsdWdpbicpO1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gcmVxdWlyZSgnLi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlcicpO1xudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJyk7XG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9IVE1MRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NRW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NRW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdERPTVRyZWVUcmF2ZXJzYWwgPSByZXF1aXJlKCcuL1JlYWN0RE9NVHJlZVRyYXZlcnNhbCcpO1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneScpO1xudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudExpc3RlbmVyJyk7XG52YXIgUmVhY3RJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbicpO1xudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9TVkdET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TZWxlY3RFdmVudFBsdWdpbicpO1xudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TaW1wbGVFdmVudFBsdWdpbicpO1xuXG52YXIgYWxyZWFkeUluamVjdGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluamVjdCgpIHtcbiAgaWYgKGFscmVhZHlJbmplY3RlZCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgY3VycmVudGx5IHRydWUgYmVjYXVzZSB0aGVzZSBpbmplY3Rpb25zIGFyZSBzaGFyZWQgYmV0d2VlblxuICAgIC8vIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIgcGFja2FnZS4gVGhleSBzaG91bGQgYmUgYnVpbHQgaW5kZXBlbmRlbnRseVxuICAgIC8vIGFuZCBub3Qgc2hhcmUgYW55IGluamVjdGlvbiBzdGF0ZS4gVGhlbiB0aGlzIHByb2JsZW0gd2lsbCBiZSBzb2x2ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGFscmVhZHlJbmplY3RlZCA9IHRydWU7XG5cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRFbWl0dGVyLmluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcihSZWFjdEV2ZW50TGlzdGVuZXIpO1xuXG4gIC8qKlxuICAgKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpblV0aWxzLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5VdGlscy5pbmplY3RUcmVlVHJhdmVyc2FsKFJlYWN0RE9NVHJlZVRyYXZlcnNhbCk7XG5cbiAgLyoqXG4gICAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxuICAgKiB0aGVtKS5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gICAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICAgIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICAgIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gICAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5Ib3N0Q29tcG9uZW50LmluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzcyhSZWFjdERPTUNvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uSG9zdENvbXBvbmVudC5pbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MoUmVhY3RET01UZXh0Q29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhBUklBRE9NUHJvcGVydHlDb25maWcpO1xuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhTVkdET01Qcm9wZXJ0eUNvbmZpZyk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRW1wdHlDb21wb25lbnQuaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5KGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAgIHJldHVybiBuZXcgUmVhY3RET01FbXB0eUNvbXBvbmVudChpbnN0YW50aWF0ZSk7XG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICBSZWFjdEluamVjdGlvbi5Db21wb25lbnQuaW5qZWN0RW52aXJvbm1lbnQoUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBUklBRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICAvLyBHbG9iYWwgU3RhdGVzIGFuZCBQcm9wZXJ0aWVzXG4gICAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICAgJ2FyaWEtZGlzYWJsZWQnOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgICAnYXJpYS1sYWJlbCc6IDAsXG4gICAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAgICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgICAnYXJpYS1sZXZlbCc6IDAsXG4gICAgJ2FyaWEtbW9kYWwnOiAwLFxuICAgICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAgICdhcmlhLXByZXNzZWQnOiAwLFxuICAgICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAgICdhcmlhLXNvcnQnOiAwLFxuICAgICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAgICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gICAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAgICdhcmlhLWF0b21pYyc6IDAsXG4gICAgJ2FyaWEtYnVzeSc6IDAsXG4gICAgJ2FyaWEtbGl2ZSc6IDAsXG4gICAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAgIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAgICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAgICdhcmlhLWdyYWJiZWQnOiAwLFxuICAgIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAgICdhcmlhLWNvbGluZGV4JzogMCxcbiAgICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgICAnYXJpYS1jb250cm9scyc6IDAsXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAgICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgICAnYXJpYS1vd25zJzogMCxcbiAgICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAgICdhcmlhLXJvd2luZGV4JzogMCxcbiAgICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgICAnYXJpYS1zZXRzaXplJzogMFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge30sXG4gIERPTVByb3BlcnR5TmFtZXM6IHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFSSUFET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvQVJJQURPTVByb3BlcnR5Q29uZmlnLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50IEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUgPSByZXF1aXJlKCcuL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZScpO1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNJbnB1dEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNJbnB1dEV2ZW50Jyk7XG5cbnZhciBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl07IC8vIFRhYiwgUmV0dXJuLCBFc2MsIFNwYWNlXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcblxudmFyIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ0NvbXBvc2l0aW9uRXZlbnQnIGluIHdpbmRvdztcblxudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB7XG4gIGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbn1cblxuLy8gV2Via2l0IG9mZmVycyBhIHZlcnkgdXNlZnVsIGB0ZXh0SW5wdXRgIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgdG9cbi8vIGRpcmVjdGx5IHJlcHJlc2VudCBgYmVmb3JlSW5wdXRgLiBUaGUgSUUgYHRleHRpbnB1dGAgZXZlbnQgaXMgbm90IGFzXG4vLyB1c2VmdWwsIHNvIHdlIGRvbid0IHVzZSBpdC5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSAmJiAhaXNQcmVzdG8oKTtcblxuLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cbnZhciB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHwgZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50TW9kZSA+IDggJiYgZG9jdW1lbnRNb2RlIDw9IDExKTtcblxuLyoqXG4gKiBPcGVyYSA8PSAxMiBpbmNsdWRlcyBUZXh0RXZlbnQgaW4gd2luZG93LCBidXQgZG9lcyBub3QgZmlyZVxuICogdGV4dCBpbnB1dCBldmVudHMuIFJlbHkgb24ga2V5cHJlc3MgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gaXNQcmVzdG8oKSB7XG4gIHZhciBvcGVyYSA9IHdpbmRvdy5vcGVyYTtcbiAgcmV0dXJuIHR5cGVvZiBvcGVyYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wZXJhLnZlcnNpb24gPT09ICdmdW5jdGlvbicgJiYgcGFyc2VJbnQob3BlcmEudmVyc2lvbigpLCAxMCkgPD0gMTI7XG59XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25CZWZvcmVJbnB1dCcsXG4gICAgICBjYXB0dXJlZDogJ29uQmVmb3JlSW5wdXRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleVByZXNzJywgJ3RvcFRleHRJbnB1dCcsICd0b3BQYXN0ZSddXG4gIH0sXG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uRW5kJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvbkVuZENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25TdGFydCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25TdGFydENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblN0YXJ0JywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25VcGRhdGUnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfVxufTtcblxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblN0YXJ0JzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25VcGRhdGUnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleURvd24nICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBmYWxsYmFjayBvYmplY3QsIGlmIGFueS5cbnZhciBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuXG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZTtcbiAgdmFyIGZhbGxiYWNrRGF0YTtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbiAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmdldFBvb2xlZChuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndG9wVGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICAvLyBJZiBjb21wb3NpdGlvbiBldmVudCBpcyBhdmFpbGFibGUsIHdlIGV4dHJhY3QgYSBzdHJpbmcgb25seSBhdFxuICAvLyBjb21wb3NpdGlvbmV2ZW50LCBvdGhlcndpc2UgZXh0cmFjdCBpdCBhdCBmYWxsYmFjayBldmVudHMuXG4gIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ29tcG9zaXRpb25FbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5yZWxlYXNlKGN1cnJlbnRDb21wb3NpdGlvbik7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKG5hdGl2ZUV2ZW50LndoaWNoICYmICFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGdldExpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXI7XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoaW5zdCwgcGhhc2UsIGV2ZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpIDogdm9pZCAwO1xuICB9XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMudHJhdmVyc2VUd29QaGFzZShldmVudC5fdGFyZ2V0SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdmFyIHRhcmdldEluc3QgPSBldmVudC5fdGFyZ2V0SW5zdDtcbiAgICB2YXIgcGFyZW50SW5zdCA9IHRhcmdldEluc3QgPyBFdmVudFBsdWdpblV0aWxzLmdldFBhcmVudEluc3RhbmNlKHRhcmdldEluc3QpIDogbnVsbDtcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5fdGFyZ2V0SW5zdCwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0bykge1xuICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbnQgYVxuICogc2luZ2xlIG9uZS5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRQcm9wYWdhdG9yc1xuICovXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UHJvcGFnYXRvcnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBzdG9yZSBmb3IgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbnZhciBsaXN0ZW5lckJhbmsgPSB7fTtcblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLmV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIHRydWUpO1xufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgZmFsc2UpO1xufTtcblxudmFyIGdldERpY3Rpb25hcnlLZXkgPSBmdW5jdGlvbiAoaW5zdCkge1xuICAvLyBQcmV2ZW50cyBWOCBwZXJmb3JtYW5jZSBpc3N1ZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuICByZXR1cm4gJy4nICsgaW5zdC5fcm9vdE5vZGVJRDtcbn07XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKSB7XG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcbn1cblxuZnVuY3Rpb24gc2hvdWxkUHJldmVudE1vdXNlRXZlbnQobmFtZSwgdHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnb25DbGljayc6XG4gICAgY2FzZSAnb25DbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2snOlxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bic6XG4gICAgY2FzZSAnb25Nb3VzZURvd25DYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmVDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlVXAnOlxuICAgIGNhc2UgJ29uTW91c2VVcENhcHR1cmUnOlxuICAgICAgcmV0dXJuICEhKHByb3BzLmRpc2FibGVkICYmIGlzSW50ZXJhY3RpdmUodHlwZSkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XG5cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG5cbiAgfSxcblxuICAvKipcbiAgICogU3RvcmVzIGBsaXN0ZW5lcmAgYXQgYGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtrZXldYC4gSXMgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gc3RvcmUuXG4gICAqL1xuICBwdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgISh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkICVzIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IHR5cGUgJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogX3Byb2RJbnZhcmlhbnQoJzk0JywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IHZvaWQgMDtcblxuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSB8fCAobGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdID0ge30pO1xuICAgIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV0gPSBsaXN0ZW5lcjtcblxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gICAqL1xuICBnZXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAgIC8vIGxpdmUgaGVyZTsgbmVlZHMgdG8gYmUgbW92ZWQgdG8gYSBiZXR0ZXIgcGxhY2Ugc29vblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC5fY3VycmVudEVsZW1lbnQudHlwZSwgaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHMpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgcmV0dXJuIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lICYmIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBsaXN0ZW5lciBmcm9tIHRoZSByZWdpc3RyYXRpb24gYmFuay5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKi9cbiAgZGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBuZXZlciBiZSBudWxsIC0tIHdoZW4gaXMgaXQ/XG4gICAgaWYgKGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICAgIGRlbGV0ZSBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqL1xuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiBsaXN0ZW5lckJhbmspIHtcbiAgICAgIGlmICghbGlzdGVuZXJCYW5rLmhhc093blByb3BlcnR5KHJlZ2lzdHJhdGlvbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtrZXldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgICBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gICAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICB2YXIgcGx1Z2lucyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgICAgdmFyIGV4dHJhY3RlZEV2ZW50cyA9IHBvc3NpYmxlUGx1Z2luLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc3ludGhldGljIGV2ZW50IHRoYXQgc2hvdWxkIGJlIGRpc3BhdGNoZWQgd2hlblxuICAgKiBgcHJvY2Vzc0V2ZW50UXVldWVgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZXZlbnRzIEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVFdmVudHM6IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYWxsIHN5bnRoZXRpYyBldmVudHMgb24gdGhlIGV2ZW50IHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NFdmVudFF1ZXVlOiBmdW5jdGlvbiAoc2ltdWxhdGVkKSB7XG4gICAgLy8gU2V0IGBldmVudFF1ZXVlYCB0byBudWxsIGJlZm9yZSBwcm9jZXNzaW5nIGl0IHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgbW9yZVxuICAgIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cbiAgICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICAgIGV2ZW50UXVldWUgPSBudWxsO1xuICAgIGlmIChzaW11bGF0ZWQpIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCk7XG4gICAgfVxuICAgICEhZXZlbnRRdWV1ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5NScpIDogdm9pZCAwO1xuICAgIC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuICAgIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhlc2UgYXJlIG5lZWRlZCBmb3IgdGVzdHMgb25seS4gRG8gbm90IHVzZSFcbiAgICovXG4gIF9fcHVyZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICBsaXN0ZW5lckJhbmsgPSB7fTtcbiAgfSxcblxuICBfX2dldExpc3RlbmVyQmFuazogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsaXN0ZW5lckJhbms7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpbkh1YjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5IdWIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBldmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFldmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgZXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgcGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gZXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTYnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCBtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk3JywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTgnLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgZXZlbnQgbmFtZSwgYCVzYC4nLCBldmVudE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk5JywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMgYW5kXG4gKiBjYW4gYmUgdXNlZCB3aXRoIGBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcmAgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDAnLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xuXG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gICAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAgICogb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHt9IDogbnVsbCxcbiAgLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIF9fREVWX19cblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbiAoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgISFldmVudFBsdWdpbk9yZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBfcHJvZEludmFyaWFudCgnMTAxJykgOiB2b2lkIDA7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIGV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDInLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHB1bGxpbmcgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgb3V0IG9mIGRpc3BhdGNoQ29uZmlnIGhlbHBzIEZsb3cgc2VlXG4gICAgICAvLyB0aGF0IGl0IGlzIG5vdCB1bmRlZmluZWQuXG4gICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcblxuICAgICAgZm9yICh2YXIgcGhhc2UgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgICAgaWYgKCFwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1twaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZV1dO1xuICAgICAgICBpZiAocGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHBsdWdpbk1vZHVsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0RXZlbnRQbHVnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKG5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuICAgICAgZm9yICh2YXIgbG93ZXJDYXNlZE5hbWUgaW4gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgICBpZiAocG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgICAgICBkZWxldGUgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEluamVjdGVkIGRlcGVuZGVuY2llczpcbiAqL1xuXG4vKipcbiAqIC0gYENvbXBvbmVudFRyZWVgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IGNhbiBjb252ZXJ0IGJldHdlZW4gUmVhY3QgaW5zdGFuY2VzXG4gKiAgIGFuZCBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICovXG52YXIgQ29tcG9uZW50VHJlZTtcbnZhciBUcmVlVHJhdmVyc2FsO1xudmFyIGluamVjdGlvbiA9IHtcbiAgaW5qZWN0Q29tcG9uZW50VHJlZTogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgQ29tcG9uZW50VHJlZSA9IEluamVjdGVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhJbmplY3RlZCAmJiBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlICYmIEluamVjdGVkLmdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfSxcbiAgaW5qZWN0VHJlZVRyYXZlcnNhbDogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgVHJlZVRyYXZlcnNhbCA9IEluamVjdGVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhJbmplY3RlZCAmJiBJbmplY3RlZC5pc0FuY2VzdG9yICYmIEluamVjdGVkLmdldExvd2VzdENvbW1vbkFuY2VzdG9yLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0VHJlZVRyYXZlcnNhbCguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGlzQW5jZXN0b3Igb3IgZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IuJykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc0VuZGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlVXAnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoRW5kJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaENhbmNlbCc7XG59XG5cbmZ1bmN0aW9uIGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlTW92ZScgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hNb3ZlJztcbn1cbmZ1bmN0aW9uIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZURvd24nIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoU3RhcnQnO1xufVxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgdmFyIGluc3RhbmNlc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaEluc3RhbmNlcyk7XG4gICAgdmFyIGluc3RhbmNlc0xlbiA9IGluc3RhbmNlc0lzQXJyID8gZGlzcGF0Y2hJbnN0YW5jZXMubGVuZ3RoIDogZGlzcGF0Y2hJbnN0YW5jZXMgPyAxIDogMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gRXZlbnRQbHVnaW5VdGlscy5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCh0eXBlLCBsaXN0ZW5lciwgZXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sodHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfVxuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSW5zdGFuY2VzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zXG4gKiB0cnVlLCBvciBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaEluc3RhbmNlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGlmIChkaXNwYXRjaExpc3RlbmVycyhldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXMpKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hJbnN0YW5jZXM7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lciA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2UgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gICEhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdleGVjdXRlRGlyZWN0RGlzcGF0Y2goLi4uKTogSW52YWxpZCBgZXZlbnRgLicpIDogX3Byb2RJbnZhcmlhbnQoJzEwMycpIDogdm9pZCAwO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZGlzcGF0Y2hMaXN0ZW5lciA/IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShkaXNwYXRjaEluc3RhbmNlKSA6IG51bGw7XG4gIHZhciByZXMgPSBkaXNwYXRjaExpc3RlbmVyID8gZGlzcGF0Y2hMaXN0ZW5lcihldmVudCkgOiBudWxsO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cbmZ1bmN0aW9uIGhhc0Rpc3BhdGNoZXMoZXZlbnQpIHtcbiAgcmV0dXJuICEhZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xufVxuXG4vKipcbiAqIEdlbmVyYWwgdXRpbGl0aWVzIHRoYXQgYXJlIHVzZWZ1bCBpbiBjcmVhdGluZyBjdXN0b20gRXZlbnQgUGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSB7XG4gIGlzRW5kaXNoOiBpc0VuZGlzaCxcbiAgaXNNb3ZlaXNoOiBpc01vdmVpc2gsXG4gIGlzU3RhcnRpc2g6IGlzU3RhcnRpc2gsXG5cbiAgZXhlY3V0ZURpcmVjdERpc3BhdGNoOiBleGVjdXRlRGlyZWN0RGlzcGF0Y2gsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcjogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlLFxuICBoYXNEaXNwYXRjaGVzOiBoYXNEaXNwYXRjaGVzLFxuXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgfSxcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKG5vZGUpO1xuICB9LFxuICBpc0FuY2VzdG9yOiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLmlzQW5jZXN0b3IoYSwgYik7XG4gIH0sXG4gIGdldExvd2VzdENvbW1vbkFuY2VzdG9yOiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLmdldExvd2VzdENvbW1vbkFuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRQYXJlbnRJbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRQYXJlbnRJbnN0YW5jZShpbnN0KTtcbiAgfSxcbiAgdHJhdmVyc2VUd29QaGFzZTogZnVuY3Rpb24gKHRhcmdldCwgZm4sIGFyZykge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLnRyYXZlcnNlVHdvUGhhc2UodGFyZ2V0LCBmbiwgYXJnKTtcbiAgfSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiBmdW5jdGlvbiAoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKTtcbiAgfSxcblxuICBpbmplY3Rpb246IGluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblV0aWxzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblV0aWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gYSBGaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIHsqfSBiIFNlY29uZCBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgZnVuYywgYSkge1xuICB0cnkge1xuICAgIGZ1bmMoYSk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIGNhdWdodEVycm9yID0geDtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYnkgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUgc28gdGhhdCBhbnkgZXJyb3JzIHRocm93biBieSB0aGUgZXZlbnRcbiAgICogaGFuZGxlciBhcmUgc3VyZSB0byBiZSByZXRocm93biBieSByZXRocm93Q2F1Z2h0RXJyb3IuXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2g6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8qKlxuICAgKiBUbyBoZWxwIGRldmVsb3BtZW50IHdlIGNhbiBnZXQgYmV0dGVyIGRldnRvb2xzIGludGVncmF0aW9uIGJ5IHNpbXVsYXRpbmcgYVxuICAgKiByZWFsIGJyb3dzZXIgZXZlbnQuXG4gICAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGEpIHtcbiAgICAgIHZhciBib3VuZEZ1bmMgPSBmdW5jLmJpbmQobnVsbCwgYSk7XG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgbmFtZTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAvLyAkRmxvd0ZpeE1lIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yMzM2XG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVycm9yVXRpbHM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FjY3VtdWxhdGVJbnRvKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzMwJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhY2N1bXVsYXRlSW50bztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvYWNjdW11bGF0ZUludG8uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKi9cblxuZnVuY3Rpb24gZm9yRWFjaEFjY3VtdWxhdGVkKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoQWNjdW11bGF0ZWQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2ZvckVhY2hBY2N1bXVsYXRlZC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGNsYXNzIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHJvb3RcbiAqL1xuZnVuY3Rpb24gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKHJvb3QpIHtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX3N0YXJ0VGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5fYXNzaWduKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxuICAgKiB0ZXh0IGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBTdGF0aWMgcG9vbGVycy4gU2V2ZXJhbCBjdXN0b20gdmVyc2lvbnMgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZlxuICogYXJndW1lbnRzLiBBIGNvbXBsZXRlbHkgZ2VuZXJpYyBwb29sZXIgaXMgZWFzeSB0byBpbXBsZW1lbnQsIGJ1dCB3b3VsZFxuICogcmVxdWlyZSBhY2Nlc3NpbmcgdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gSW4gZWFjaCBvZiB0aGVzZSwgYHRoaXNgIHJlZmVycyB0b1xuICogdGhlIENsYXNzIGl0c2VsZiwgbm90IGFuIGluc3RhbmNlLiBJZiBhbnkgb3RoZXJzIGFyZSBuZWVkZWQsIHNpbXBseSBhZGQgdGhlbVxuICogaGVyZSwgb3IgaW4gdGhlaXIgb3duIGZpbGVzLlxuICovXG52YXIgb25lQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoY29weUZpZWxkc0Zyb20pIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgY29weUZpZWxkc0Zyb20pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGNvcHlGaWVsZHNGcm9tKTtcbiAgfVxufTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMyk7XG4gIH1cbn07XG5cbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0KTtcbiAgfVxufTtcblxudmFyIHN0YW5kYXJkUmVsZWFzZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogX3Byb2RJbnZhcmlhbnQoJzI1JykgOiB2b2lkIDA7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIC8vIENhc3RpbmcgYXMgYW55IHNvIHRoYXQgZmxvdyBpZ25vcmVzIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gYW5kIHRydXN0c1xuICAvLyBpdCB0byBtYXRjaCB0aGUgdHlwZSB3ZSBkZWNsYXJlZFxuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1Bvb2xlZENsYXNzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcbnZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nO1xuXG52YXIgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMgPSBbJ2Rpc3BhdGNoQ29uZmlnJywgJ190YXJnZXRJbnN0JywgJ25hdGl2ZUV2ZW50JywgJ2lzRGVmYXVsdFByZXZlbnRlZCcsICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCcsICdfZGlzcGF0Y2hMaXN0ZW5lcnMnLCAnX2Rpc3BhdGNoSW5zdGFuY2VzJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBudWxsLFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0SW5zdCBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IG5hdGl2ZUV2ZW50VGFyZ2V0IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW3Byb3BOYW1lXTsgLy8gdGhpcyBoYXMgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5fYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xuXG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSB2YWxpZC10eXBlb2ZcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgICAvLyBUaGUgQ2hhbmdlRXZlbnRQbHVnaW4gcmVnaXN0ZXJzIGEgXCJwcm9wZXJ0eWNoYW5nZVwiIGV2ZW50IGZvclxuICAgICAgLy8gSUUuIFRoaXMgZXZlbnQgZG9lcyBub3Qgc3VwcG9ydCBidWJibGluZyBvciBjYW5jZWxsaW5nLCBhbmRcbiAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcbiAgICAgIC8vIHR5cGVvZiBjaGVjayBvZiBcInVua25vd25cIiBjaXJjdW12ZW50cyB0aGlzIGlzc3VlIChhbmQgaXMgYWxzb1xuICAgICAgLy8gSUUgc3BlY2lmaWMpLlxuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICovXG4gIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hdGl2ZUV2ZW50JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignbmF0aXZlRXZlbnQnLCBudWxsKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ByZXZlbnREZWZhdWx0JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbigncHJldmVudERlZmF1bHQnLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0b3BQcm9wYWdhdGlvbicsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3N0b3BQcm9wYWdhdGlvbicsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICB9XG4gIH1cblxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBpZiAoaXNQcm94eVN1cHBvcnRlZCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgICBTeW50aGV0aWNFdmVudCA9IG5ldyBQcm94eShTeW50aGV0aWNFdmVudCwge1xuICAgICAgY29uc3RydWN0OiBmdW5jdGlvbiAodGFyZ2V0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5KHRhcmdldCwgT2JqZWN0LmNyZWF0ZSh0YXJnZXQucHJvdG90eXBlKSwgYXJncyk7XG4gICAgICB9LFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIChjb25zdHJ1Y3RvciwgdGhhdCwgYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KGNvbnN0cnVjdG9yLmFwcGx5KHRoYXQsIGFyZ3MpLCB7XG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3AgIT09ICdpc1BlcnNpc3RlbnQnICYmICF0YXJnZXQuY29uc3RydWN0b3IuSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3ApICYmIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSwgJ1RoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XFwncmUgJyArICdzZWVpbmcgdGhpcywgeW91XFwncmUgYWRkaW5nIGEgbmV3IHByb3BlcnR5IGluIHRoZSBzeW50aGV0aWMgZXZlbnQgb2JqZWN0LiAnICsgJ1RoZSBwcm9wZXJ0eSBpcyBuZXZlciByZWxlYXNlZC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyplc2xpbnQtZW5hYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gIH1cbn1cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuXG4gIFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDbGFzcywgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcbn07XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNFdmVudDtcblxuLyoqXG4gICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gICpcbiAgKiBAcGFyYW0ge29iamVjdH0gU3ludGhldGljRXZlbnRcbiAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAgKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXQsXG4gICAgZ2V0OiBnZXRcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuaW5nQ29uZGl0aW9uLCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSBzZWVpbmcgdGhpcywgJyArICd5b3VcXCdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuICcgKyAnSWYgeW91IG11c3Qga2VlcCB0aGUgb3JpZ2luYWwgc3ludGhldGljIGV2ZW50IGFyb3VuZCwgdXNlIGV2ZW50LnBlcnNpc3QoKS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGFjdGlvbiwgcHJvcE5hbWUsIHJlc3VsdCkgOiB2b2lkIDA7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljSW5wdXRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNJbnB1dEV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ2hhbmdlJywgJ3RvcENsaWNrJywgJ3RvcEZvY3VzJywgJ3RvcElucHV0JywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG52YXIgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIFNlZSBgaGFuZGxlQ2hhbmdlYCBjb21tZW50IGJlbG93XG4gIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2NoYW5nZScpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDgpO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50KTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbn1cblxuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4KHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BGb2N1cycpIHtcbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG4gIC8vIElFMTArIGZpcmUgaW5wdXQgZXZlbnRzIHRvIG9mdGVuLCBzdWNoIHdoZW4gYSBwbGFjZWhvbGRlclxuICAvLyBjaGFuZ2VzIG9yIHdoZW4gYW4gaW5wdXQgd2l0aCBhIHBsYWNlaG9sZGVyIGlzIGZvY3VzZWQuXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gMTEpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgUmVwbGFjZW1lbnQgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGB2YWx1ZWAgcHJvcGVydHkgdGhhdCBnZXRzXG4gKiBzZXQgb24gdGhlIGFjdGl2ZSBlbGVtZW50LlxuICovXG52YXIgbmV3VmFsdWVQcm9wID0ge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5nZXQuY2FsbCh0aGlzKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gQ2FzdCB0byBhIHN0cmluZyBzbyB3ZSBjYW4gZG8gZXF1YWxpdHkgY2hlY2tzLlxuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9ICcnICsgdmFsO1xuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3Auc2V0LmNhbGwodGhpcywgdmFsKTtcbiAgfVxufTtcblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICd2YWx1ZScpO1xuXG4gIC8vIE5vdCBndWFyZGVkIGluIGEgY2FuRGVmaW5lUHJvcGVydHkgY2hlY2s6IElFOCBzdXBwb3J0cyBkZWZpbmVQcm9wZXJ0eSBvbmx5XG4gIC8vIG9uIERPTSBlbGVtZW50c1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWN0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbmV3VmFsdWVQcm9wKTtcbiAgaWYgKGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICB9IGVsc2Uge1xuICAgIGFjdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBkZWxldGUgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGRlZmluaXRpb25cbiAgZGVsZXRlIGFjdGl2ZUVsZW1lbnQudmFsdWU7XG5cbiAgaWYgKGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcbiAgICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICB9IGVsc2Uge1xuICAgIGFjdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSwgZmFsc2UpO1xuICB9XG5cbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdmFsdWUgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50LnZhbHVlO1xuICBpZiAodmFsdWUgPT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB2YWx1ZTtcblxuICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbn1cblxuLyoqXG4gKiBJZiBhIGBjaGFuZ2VgIGV2ZW50IHNob3VsZCBiZSBmaXJlZCwgcmV0dXJucyB0aGUgdGFyZ2V0J3MgSUQuXG4gKi9cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wSW5wdXQnKSB7XG4gICAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzIChpLmUuLCBub3QgSUU4IG9yIElFOSksIHRoZSBpbnB1dCBldmVudCBpcyBleGFjdGx5XG4gICAgLy8gd2hhdCB3ZSB3YW50IHNvIGZhbGwgdGhyb3VnaCBoZXJlIGFuZCB0cmlnZ2VyIGFuIGFic3RyYWN0IGV2ZW50XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BGb2N1cycpIHtcbiAgICAvLyBJbiBJRTgsIHdlIGNhbiBjYXB0dXJlIGFsbW9zdCBhbGwgLnZhbHVlIGNoYW5nZXMgYnkgYWRkaW5nIGFcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBoYW5kbGVyIGFuZCBsb29raW5nIGZvciBldmVudHMgd2l0aCBwcm9wZXJ0eU5hbWVcbiAgICAvLyBlcXVhbCB0byAndmFsdWUnXG4gICAgLy8gSW4gSUU5LTExLCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wU2VsZWN0aW9uQ2hhbmdlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnZhbHVlICE9PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IGFjdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgICByZXR1cm4gYWN0aXZlRWxlbWVudEluc3Q7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENsaWNrJykge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoZG9lc0NoYW5nZUV2ZW50QnViYmxlKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRTtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudDtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VGFyZ2V0SW5zdEZ1bmMpIHtcbiAgICAgIHZhciBpbnN0ID0gZ2V0VGFyZ2V0SW5zdEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KTtcbiAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICAgICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SW5zdCk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhbmdlRXZlbnRQbHVnaW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdEZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGRpcnR5Q29tcG9uZW50cyA9IFtdO1xudmFyIHVwZGF0ZUJhdGNoTnVtYmVyID0gMDtcbnZhciBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG52YXIgYXNhcEVucXVldWVkID0gZmFsc2U7XG5cbnZhciBiYXRjaGluZ1N0cmF0ZWd5ID0gbnVsbDtcblxuZnVuY3Rpb24gZW5zdXJlSW5qZWN0ZWQoKSB7XG4gICEoUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gJiYgYmF0Y2hpbmdTdHJhdGVneSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IGluamVjdCBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcyBhbmQgYmF0Y2hpbmcgc3RyYXRlZ3knKSA6IF9wcm9kSW52YXJpYW50KCcxMjMnKSA6IHZvaWQgMDtcbn1cblxudmFyIE5FU1RFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCAhPT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gQWRkaXRpb25hbCB1cGRhdGVzIHdlcmUgZW5xdWV1ZWQgYnkgY29tcG9uZW50RGlkVXBkYXRlIGhhbmRsZXJzIG9yXG4gICAgICAvLyBzaW1pbGFyOyBiZWZvcmUgb3VyIG93biBVUERBVEVfUVVFVUVJTkcgd3JhcHBlciBjbG9zZXMsIHdlIHdhbnQgdG8gcnVuXG4gICAgICAvLyB0aGVzZSBuZXcgdXBkYXRlcyBzbyB0aGF0IGlmIEEncyBjb21wb25lbnREaWRVcGRhdGUgY2FsbHMgc2V0U3RhdGUgb25cbiAgICAgIC8vIEIsIEIgd2lsbCB1cGRhdGUgYmVmb3JlIHRoZSBjYWxsYmFjayBBJ3MgdXBkYXRlciBwcm92aWRlZCB3aGVuIGNhbGxpbmdcbiAgICAgIC8vIHNldFN0YXRlLlxuICAgICAgZGlydHlDb21wb25lbnRzLnNwbGljZSgwLCB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCk7XG4gICAgICBmbHVzaEJhdGNoZWRVcGRhdGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcnR5Q29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFVQREFURV9RVUVVRUlORyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZS5yZXNldCgpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW05FU1RFRF9VUERBVEVTLCBVUERBVEVfUVVFVUVJTkddO1xuXG5mdW5jdGlvbiBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZChcbiAgLyogdXNlQ3JlYXRlRWxlbWVudCAqL3RydWUpO1xufVxuXG5fYXNzaWduKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMuY2FsbGJhY2tRdWV1ZSk7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlID0gbnVsbDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBudWxsO1xuICB9LFxuXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhKSB7XG4gICAgLy8gRXNzZW50aWFsbHkgY2FsbHMgYHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybShtZXRob2QsIHNjb3BlLCBhKWBcbiAgICAvLyB3aXRoIHRoaXMgdHJhbnNhY3Rpb24ncyB3cmFwcGVycyBhcm91bmQgaXQuXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uLnBlcmZvcm0uY2FsbCh0aGlzLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0sIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24sIG1ldGhvZCwgc2NvcGUsIGEpO1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24pO1xuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuICByZXR1cm4gYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSk7XG59XG5cbi8qKlxuICogQXJyYXkgY29tcGFyYXRvciBmb3IgUmVhY3RDb21wb25lbnRzIGJ5IG1vdW50IG9yZGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMxIGZpcnN0IGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMiBzZWNvbmQgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJuIHZhbHVlIHVzYWJsZSBieSBBcnJheS5wcm90b3R5cGUuc29ydCgpLlxuICovXG5mdW5jdGlvbiBtb3VudE9yZGVyQ29tcGFyYXRvcihjMSwgYzIpIHtcbiAgcmV0dXJuIGMxLl9tb3VudE9yZGVyIC0gYzIuX21vdW50T3JkZXI7XG59XG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZWRVcGRhdGVzKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBsZW4gPSB0cmFuc2FjdGlvbi5kaXJ0eUNvbXBvbmVudHNMZW5ndGg7XG4gICEobGVuID09PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBmbHVzaCB0cmFuc2FjdGlvblxcJ3Mgc3RvcmVkIGRpcnR5LWNvbXBvbmVudHMgbGVuZ3RoICglcykgdG8gbWF0Y2ggZGlydHktY29tcG9uZW50cyBhcnJheSBsZW5ndGggKCVzKS4nLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogX3Byb2RJbnZhcmlhbnQoJzEyNCcsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiB2b2lkIDA7XG5cbiAgLy8gU2luY2UgcmVjb25jaWxpbmcgYSBjb21wb25lbnQgaGlnaGVyIGluIHRoZSBvd25lciBoaWVyYXJjaHkgdXN1YWxseSAobm90XG4gIC8vIGFsd2F5cyAtLSBzZWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkpIHdpbGwgcmVjb25jaWxlIGNoaWxkcmVuLCByZWNvbmNpbGVcbiAgLy8gdGhlbSBiZWZvcmUgdGhlaXIgY2hpbGRyZW4gYnkgc29ydGluZyB0aGUgYXJyYXkuXG4gIGRpcnR5Q29tcG9uZW50cy5zb3J0KG1vdW50T3JkZXJDb21wYXJhdG9yKTtcblxuICAvLyBBbnkgdXBkYXRlcyBlbnF1ZXVlZCB3aGlsZSByZWNvbmNpbGluZyBtdXN0IGJlIHBlcmZvcm1lZCBhZnRlciB0aGlzIGVudGlyZVxuICAvLyBiYXRjaC4gT3RoZXJ3aXNlLCBpZiBkaXJ0eUNvbXBvbmVudHMgaXMgW0EsIEJdIHdoZXJlIEEgaGFzIGNoaWxkcmVuIEIgYW5kXG4gIC8vIEMsIEIgY291bGQgdXBkYXRlIHR3aWNlIGluIGEgc2luZ2xlIGJhdGNoIGlmIEMncyByZW5kZXIgZW5xdWV1ZXMgYW4gdXBkYXRlXG4gIC8vIHRvIEIgKHNpbmNlIEIgd291bGQgaGF2ZSBhbHJlYWR5IHVwZGF0ZWQsIHdlIHNob3VsZCBza2lwIGl0LCBhbmQgdGhlIG9ubHlcbiAgLy8gd2F5IHdlIGNhbiBrbm93IHRvIGRvIHNvIGlzIGJ5IGNoZWNraW5nIHRoZSBiYXRjaCBjb3VudGVyKS5cbiAgdXBkYXRlQmF0Y2hOdW1iZXIrKztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBwZW5kaW5nIGNoYW5nZXMgYXBwbHksIGl0IHdpbGwgc3RpbGxcbiAgICAvLyBiZSBoZXJlLCBidXQgd2UgYXNzdW1lIHRoYXQgaXQgaGFzIGNsZWFyZWQgaXRzIF9wZW5kaW5nQ2FsbGJhY2tzIGFuZFxuICAgIC8vIHRoYXQgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGlzIGEgbm9vcC5cbiAgICB2YXIgY29tcG9uZW50ID0gZGlydHlDb21wb25lbnRzW2ldO1xuXG4gICAgLy8gSWYgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGhhcHBlbnMgdG8gZW5xdWV1ZSBhbnkgbmV3IHVwZGF0ZXMsIHdlXG4gICAgLy8gc2hvdWxkbid0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgaGFwcGVucywgc29cbiAgICAvLyBzdGFzaCB0aGUgY2FsbGJhY2tzIGZpcnN0XG4gICAgdmFyIGNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcztcbiAgICBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgdmFyIG1hcmtlck5hbWU7XG4gICAgaWYgKFJlYWN0RmVhdHVyZUZsYWdzLmxvZ1RvcExldmVsUmVuZGVycykge1xuICAgICAgdmFyIG5hbWVkQ29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgLy8gRHVjayB0eXBlIFRvcExldmVsV3JhcHBlci4gVGhpcyBpcyBwcm9iYWJseSBhbHdheXMgdHJ1ZS5cbiAgICAgIGlmIChjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnR5cGUuaXNSZWFjdFRvcExldmVsV3JhcHBlcikge1xuICAgICAgICBuYW1lZENvbXBvbmVudCA9IGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgICB9XG4gICAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IHVwZGF0ZTogJyArIG5hbWVkQ29tcG9uZW50LmdldE5hbWUoKTtcbiAgICAgIGNvbnNvbGUudGltZShtYXJrZXJOYW1lKTtcbiAgICB9XG5cbiAgICBSZWFjdFJlY29uY2lsZXIucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KGNvbXBvbmVudCwgdHJhbnNhY3Rpb24ucmVjb25jaWxlVHJhbnNhY3Rpb24sIHVwZGF0ZUJhdGNoTnVtYmVyKTtcblxuICAgIGlmIChtYXJrZXJOYW1lKSB7XG4gICAgICBjb25zb2xlLnRpbWVFbmQobWFya2VyTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uY2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrc1tqXSwgY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZmx1c2hCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbidzIHdyYXBwZXJzIHdpbGwgY2xlYXIgdGhlIGRpcnR5Q29tcG9uZW50c1xuICAvLyBhcnJheSBhbmQgcGVyZm9ybSBhbnkgdXBkYXRlcyBlbnF1ZXVlZCBieSBtb3VudC1yZWFkeSBoYW5kbGVycyAoaS5lLixcbiAgLy8gY29tcG9uZW50RGlkVXBkYXRlKSBidXQgd2UgbmVlZCB0byBjaGVjayBoZXJlIHRvbyBpbiBvcmRlciB0byBjYXRjaFxuICAvLyB1cGRhdGVzIGVucXVldWVkIGJ5IHNldFN0YXRlIGNhbGxiYWNrcyBhbmQgYXNhcCBjYWxscy5cbiAgd2hpbGUgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGggfHwgYXNhcEVucXVldWVkKSB7XG4gICAgaWYgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKHJ1bkJhdGNoZWRVcGRhdGVzLCBudWxsLCB0cmFuc2FjdGlvbik7XG4gICAgICBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIH1cblxuICAgIGlmIChhc2FwRW5xdWV1ZWQpIHtcbiAgICAgIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgdmFyIHF1ZXVlID0gYXNhcENhbGxiYWNrUXVldWU7XG4gICAgICBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gICAgICBxdWV1ZS5ub3RpZnlBbGwoKTtcbiAgICAgIENhbGxiYWNrUXVldWUucmVsZWFzZShxdWV1ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1hcmsgYSBjb21wb25lbnQgYXMgbmVlZGluZyBhIHJlcmVuZGVyLCBhZGRpbmcgYW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYVxuICogbGlzdCBvZiBmdW5jdGlvbnMgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbmNlIHRoZSByZXJlbmRlciBvY2N1cnMuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoY29tcG9uZW50KSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG5cbiAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChUaGlzIGlzIGNhbGxlZCBieSBlYWNoIHRvcC1sZXZlbCB1cGRhdGVcbiAgLy8gZnVuY3Rpb24sIGxpa2Ugc2V0U3RhdGUsIGZvcmNlVXBkYXRlLCBldGMuOyBjcmVhdGlvbiBhbmRcbiAgLy8gZGVzdHJ1Y3Rpb24gb2YgdG9wLWxldmVsIGNvbXBvbmVudHMgaXMgZ3VhcmRlZCBpbiBSZWFjdE1vdW50LilcblxuICBpZiAoIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGVucXVldWVVcGRhdGUsIGNvbXBvbmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlydHlDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgaWYgKGNvbXBvbmVudC5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCkge1xuICAgIGNvbXBvbmVudC5fdXBkYXRlQmF0Y2hOdW1iZXIgPSB1cGRhdGVCYXRjaE51bWJlciArIDE7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdG8gYmUgcnVuIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYmF0Y2hpbmcgY3ljbGUuIFRocm93c1xuICogaWYgbm8gdXBkYXRlcyBhcmUgY3VycmVudGx5IGJlaW5nIHBlcmZvcm1lZC5cbiAqL1xuZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgY29udGV4dCkge1xuICAhYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXMuYXNhcDogQ2FuXFwndCBlbnF1ZXVlIGFuIGFzYXAgY2FsbGJhY2sgaW4gYSBjb250ZXh0IHdoZXJldXBkYXRlcyBhcmUgbm90IGJlaW5nIGJhdGNoZWQuJykgOiBfcHJvZEludmFyaWFudCgnMTI1JykgOiB2b2lkIDA7XG4gIGFzYXBDYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpO1xuICBhc2FwRW5xdWV1ZWQgPSB0cnVlO1xufVxuXG52YXIgUmVhY3RVcGRhdGVzSW5qZWN0aW9uID0ge1xuICBpbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKFJlY29uY2lsZVRyYW5zYWN0aW9uKSB7XG4gICAgIVJlY29uY2lsZVRyYW5zYWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzJykgOiBfcHJvZEludmFyaWFudCgnMTI2JykgOiB2b2lkIDA7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiAgfSxcblxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbiAoX2JhdGNoaW5nU3RyYXRlZ3kpIHtcbiAgICAhX2JhdGNoaW5nU3RyYXRlZ3kgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneScpIDogX3Byb2RJbnZhcmlhbnQoJzEyNycpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoZWRVcGRhdGVzKCkgZnVuY3Rpb24nKSA6IF9wcm9kSW52YXJpYW50KCcxMjgnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9PT0gJ2Jvb2xlYW4nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhbiBpc0JhdGNoaW5nVXBkYXRlcyBib29sZWFuIGF0dHJpYnV0ZScpIDogX3Byb2RJbnZhcmlhbnQoJzEyOScpIDogdm9pZCAwO1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcbiAgfVxufTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHtcbiAgLyoqXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcbiAgICogdG8gYWxsb3cgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcblxuICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXG4gIGluamVjdGlvbjogUmVhY3RVcGRhdGVzSW5qZWN0aW9uLFxuICBhc2FwOiBhc2FwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHBzZXVkby1ldmVudCBtb2R1bGUgdG8gaGVscCBrZWVwIHRyYWNrIG9mIGNvbXBvbmVudHMgd2FpdGluZyB0b1xuICogYmUgbm90aWZpZWQgd2hlbiB0aGVpciBET00gcmVwcmVzZW50YXRpb25zIGFyZSBhdmFpbGFibGUgZm9yIHVzZS5cbiAqXG4gKiBUaGlzIGltcGxlbWVudHMgYFBvb2xlZENsYXNzYCwgc28geW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBJbnN0ZWFkLCB1c2UgYENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKClgLlxuICpcbiAqIEBjbGFzcyBSZWFjdE1vdW50UmVhZHlcbiAqIEBpbXBsZW1lbnRzIFBvb2xlZENsYXNzXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2FsbGJhY2tRdWV1ZShhcmcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FsbGJhY2tRdWV1ZSk7XG5cbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgICB0aGlzLl9hcmcgPSBhcmc7XG4gIH1cblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCBDb250ZXh0IHRvIGNhbGwgYGNhbGxiYWNrYCB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCBbXTtcbiAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgdGhpcy5fY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cyB8fCBbXTtcbiAgICB0aGlzLl9jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnZva2VzIGFsbCBlbnF1ZXVlZCBjYWxsYmFja3MgYW5kIGNsZWFycyB0aGUgcXVldWUuIFRoaXMgaXMgaW52b2tlZCBhZnRlclxuICAgKiB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIGEgY29tcG9uZW50IGhhcyBiZWVuIGNyZWF0ZWQgb3IgdXBkYXRlZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUubm90aWZ5QWxsID0gZnVuY3Rpb24gbm90aWZ5QWxsKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gICAgdmFyIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHM7XG4gICAgdmFyIGFyZyA9IHRoaXMuX2FyZztcbiAgICBpZiAoY2FsbGJhY2tzICYmIGNvbnRleHRzKSB7XG4gICAgICAhKGNhbGxiYWNrcy5sZW5ndGggPT09IGNvbnRleHRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzbWF0Y2hlZCBsaXN0IG9mIGNvbnRleHRzIGluIGNhbGxiYWNrIHF1ZXVlJykgOiBfcHJvZEludmFyaWFudCgnMjQnKSA6IHZvaWQgMDtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChjb250ZXh0c1tpXSwgYXJnKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgY29udGV4dHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH07XG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUuY2hlY2twb2ludCA9IGZ1bmN0aW9uIGNoZWNrcG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrcyA/IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggOiAwO1xuICB9O1xuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLnJvbGxiYWNrID0gZnVuY3Rpb24gcm9sbGJhY2sobGVuKSB7XG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jb250ZXh0cykge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA9IGxlbjtcbiAgICAgIHRoaXMuX2NvbnRleHRzLmxlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMuXG4gICAqL1xuXG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9O1xuXG4gIHJldHVybiBDYWxsYmFja1F1ZXVlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDYWxsYmFja1F1ZXVlKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvQ2FsbGJhY2tRdWV1ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RmVhdHVyZUZsYWdzID0ge1xuICAvLyBXaGVuIHRydWUsIGNhbGwgY29uc29sZS50aW1lKCkgYmVmb3JlIGFuZCAudGltZUVuZCgpIGFmdGVyIGVhY2ggdG9wLWxldmVsXG4gIC8vIHJlbmRlciAoYm90aCBpbml0aWFsIHJlbmRlcnMgYW5kIHVwZGF0ZXMpLiBVc2VmdWwgd2hlbiBsb29raW5nIGF0IHByb2QtbW9kZVxuICAvLyB0aW1lbGluZSBwcm9maWxlcyBpbiBDaHJvbWUsIGZvciBleGFtcGxlLlxuICBsb2dUb3BMZXZlbFJlbmRlcnM6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RmVhdHVyZUZsYWdzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEZlYXR1cmVGbGFncy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlZiA9IHJlcXVpcmUoJy4vUmVhY3RSZWYnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSGVscGVyIHRvIGNhbGwgUmVhY3RSZWYuYXR0YWNoUmVmcyB3aXRoIHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCwgc3BsaXQgb3V0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW9ucyBpbiB0aGUgdHJhbnNhY3Rpb24gbW91bnQtcmVhZHkgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaFJlZnMoKSB7XG4gIFJlYWN0UmVmLmF0dGFjaFJlZnModGhpcywgdGhpcy5fY3VycmVudEVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdGhlIGNvbnRhaW5pbmcgaG9zdCBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBob3N0IGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgcGFyZW50RGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQsIHBhcmVudERlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWFya3VwID0gaW50ZXJuYWxJbnN0YW5jZS5tb3VudENvbXBvbmVudCh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHBhcmVudERlYnVnSUQpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkIHRvXG4gICAqIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwLlxuICAgKi9cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGludGVybmFsSW5zdGFuY2UuZ2V0SG9zdE5vZGUoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHNhZmVseSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVbm1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnVubW91bnRDb21wb25lbnQoc2FmZWx5KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIGNvbXBvbmVudCB1c2luZyBhIG5ldyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgaWYgKG5leHRFbGVtZW50ID09PSBwcmV2RWxlbWVudCAmJiBjb250ZXh0ID09PSBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSB7XG4gICAgICAvLyBTaW5jZSBlbGVtZW50cyBhcmUgaW1tdXRhYmxlIGFmdGVyIHRoZSBvd25lciBpcyByZW5kZXJlZCxcbiAgICAgIC8vIHdlIGNhbiBkbyBhIGNoZWFwIGlkZW50aXR5IGNvbXBhcmUgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhXG4gICAgICAvLyBzdXBlcmZsdW91cyByZWNvbmNpbGUuIEl0J3MgcG9zc2libGUgZm9yIHN0YXRlIHRvIGJlIG11dGFibGUgYnV0IHN1Y2hcbiAgICAgIC8vIGNoYW5nZSBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIG93bmVyIHdoaWNoIHdvdWxkIHJlY3JlYXRlXG4gICAgICAvLyB0aGUgZWxlbWVudC4gV2UgZXhwbGljaXRseSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBvd25lciBzaW5jZVxuICAgICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgYW4gZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG5cbiAgICAgIC8vIFRPRE86IEJhaWxpbmcgb3V0IGVhcmx5IGlzIGp1c3QgYSBwZXJmIG9wdGltaXphdGlvbiByaWdodD9cbiAgICAgIC8vIFRPRE86IFJlbW92aW5nIHRoZSByZXR1cm4gc3RhdGVtZW50IHNob3VsZCBhZmZlY3QgY29ycmVjdG5lc3M/XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBuZXh0RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZnNDaGFuZ2VkID0gUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyhwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkKSB7XG4gICAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIHByZXZFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmx1c2ggYW55IGRpcnR5IGNoYW5nZXMgaW4gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCB1cGRhdGVCYXRjaE51bWJlcikge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciAhPT0gdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICAgIC8vIFRoZSBjb21wb25lbnQncyBlbnF1ZXVlZCBiYXRjaCBudW1iZXIgc2hvdWxkIGFsd2F5cyBiZSB0aGUgY3VycmVudFxuICAgICAgLy8gYmF0Y2ggb3IgdGhlIGZvbGxvd2luZyBvbmUuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsIHx8IGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyID09PSB1cGRhdGVCYXRjaE51bWJlciArIDEsICdwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IFVuZXhwZWN0ZWQgYmF0Y2ggbnVtYmVyIChjdXJyZW50ICVzLCAnICsgJ3BlbmRpbmcgJXMpJywgdXBkYXRlQmF0Y2hOdW1iZXIsIGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGludGVybmFsSW5zdGFuY2UucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KHRyYW5zYWN0aW9uKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RPd25lcicpO1xuXG52YXIgUmVhY3RSZWYgPSB7fTtcblxuZnVuY3Rpb24gYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyhjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuUmVhY3RSZWYuYXR0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBhdHRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5SZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzID0gZnVuY3Rpb24gKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICAvLyBJZiBlaXRoZXIgdGhlIG93bmVyIG9yIGEgYHJlZmAgaGFzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0aGUgbmV3ZXN0IG93bmVyXG4gIC8vIGhhcyBzdG9yZWQgYSByZWZlcmVuY2UgdG8gYHRoaXNgLCBhbmQgdGhlIHByZXZpb3VzIG93bmVyIChpZiBkaWZmZXJlbnQpXG4gIC8vIGhhcyBmb3Jnb3R0ZW4gdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AuIFdlIHVzZSB0aGUgZWxlbWVudCBpbnN0ZWFkXG4gIC8vIG9mIHRoZSBwdWJsaWMgdGhpcy5wcm9wcyBiZWNhdXNlIHRoZSBwb3N0IHByb2Nlc3NpbmcgY2Fubm90IGRldGVybWluZVxuICAvLyBhIHJlZi4gVGhlIHJlZiBjb25jZXB0dWFsbHkgbGl2ZXMgb24gdGhlIGVsZW1lbnQuXG5cbiAgLy8gVE9ETzogU2hvdWxkIHRoaXMgZXZlbiBiZSBwb3NzaWJsZT8gVGhlIG93bmVyIGNhbm5vdCBjaGFuZ2UgYmVjYXVzZVxuICAvLyBpdCdzIGZvcmJpZGRlbiBieSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC4gVGhlIHJlZiBjYW4gY2hhbmdlXG4gIC8vIGlmIHlvdSBzd2FwIHRoZSBrZXlzIG9mIGJ1dCBub3QgdGhlIHJlZnMuIFJlY29uc2lkZXIgd2hlcmUgdGhpcyBjaGVja1xuICAvLyBpcyBtYWRlLiBJdCBwcm9iYWJseSBiZWxvbmdzIHdoZXJlIHRoZSBrZXkgY2hlY2tpbmcgYW5kXG4gIC8vIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgaXMgZG9uZS5cblxuICB2YXIgcHJldlJlZiA9IG51bGw7XG4gIHZhciBwcmV2T3duZXIgPSBudWxsO1xuICBpZiAocHJldkVsZW1lbnQgIT09IG51bGwgJiYgdHlwZW9mIHByZXZFbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgIHByZXZSZWYgPSBwcmV2RWxlbWVudC5yZWY7XG4gICAgcHJldk93bmVyID0gcHJldkVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIG5leHRSZWYgPSBudWxsO1xuICB2YXIgbmV4dE93bmVyID0gbnVsbDtcbiAgaWYgKG5leHRFbGVtZW50ICE9PSBudWxsICYmIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICBuZXh0UmVmID0gbmV4dEVsZW1lbnQucmVmO1xuICAgIG5leHRPd25lciA9IG5leHRFbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBwcmV2UmVmICE9PSBuZXh0UmVmIHx8XG4gIC8vIElmIG93bmVyIGNoYW5nZXMgYnV0IHdlIGhhdmUgYW4gdW5jaGFuZ2VkIGZ1bmN0aW9uIHJlZiwgZG9uJ3QgdXBkYXRlIHJlZnNcbiAgdHlwZW9mIG5leHRSZWYgPT09ICdzdHJpbmcnICYmIG5leHRPd25lciAhPT0gcHJldk93bmVyO1xufTtcblxuUmVhY3RSZWYuZGV0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdFJlZi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgb3duZXIuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZE93bmVyKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuYXR0YWNoUmVmID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmplY3QuZGV0YWNoUmVmID09PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBSZWFjdE93bmVycyBhcmUgY2FwYWJsZSBvZiBzdG9yaW5nIHJlZmVyZW5jZXMgdG8gb3duZWQgY29tcG9uZW50cy5cbiAqXG4gKiBBbGwgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL2JlaW5nLy8gcmVmZXJlbmNlZCBieSBvd25lciBjb21wb25lbnRzLCBidXRcbiAqIG9ubHkgUmVhY3RPd25lciBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vcmVmZXJlbmNpbmcvLyBvd25lZCBjb21wb25lbnRzLlxuICogVGhlIG5hbWVkIHJlZmVyZW5jZSBpcyBrbm93biBhcyBhIFwicmVmXCIuXG4gKlxuICogUmVmcyBhcmUgYXZhaWxhYmxlIHdoZW4gbW91bnRlZCBhbmQgdXBkYXRlZCBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+XG4gKiAgICAgICAgICAgPEN1c3RvbUNvbXBvbmVudCByZWY9XCJjdXN0b21cIiAvPlxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgICk7XG4gKiAgICAgfSxcbiAqICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmhhbmRsZUNsaWNrKCk7XG4gKiAgICAgfSxcbiAqICAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmluaXRpYWxpemUoKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFJlZnMgc2hvdWxkIHJhcmVseSBiZSB1c2VkLiBXaGVuIHJlZnMgYXJlIHVzZWQsIHRoZXkgc2hvdWxkIG9ubHkgYmUgZG9uZSB0b1xuICogY29udHJvbCBkYXRhIHRoYXQgaXMgbm90IGhhbmRsZWQgYnkgUmVhY3QncyBkYXRhIGZsb3cuXG4gKlxuICogQGNsYXNzIFJlYWN0T3duZXJcbiAqL1xudmFyIFJlYWN0T3duZXIgPSB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZENvbXBvbmVudEFzUmVmVG86IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhZGRDb21wb25lbnRBc1JlZlRvKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicpIDogX3Byb2RJbnZhcmlhbnQoJzExOScpIDogdm9pZCAwO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFpc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlbW92ZUNvbXBvbmVudEFzUmVmRnJvbSguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBZb3UgbWlnaHQgYmUgcmVtb3ZpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicpIDogX3Byb2RJbnZhcmlhbnQoJzEyMCcpIDogdm9pZCAwO1xuICAgIHZhciBvd25lclB1YmxpY0luc3RhbmNlID0gb3duZXIuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAvLyBDaGVjayB0aGF0IGBjb21wb25lbnRgJ3Mgb3duZXIgaXMgc3RpbGwgYWxpdmUgYW5kIHRoYXQgYGNvbXBvbmVudGAgaXMgc3RpbGwgdGhlIGN1cnJlbnQgcmVmXG4gICAgLy8gYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0byBkZXRhY2ggdGhlIHJlZiBpZiBhbm90aGVyIGNvbXBvbmVudCBzdG9sZSBpdC5cbiAgICBpZiAob3duZXJQdWJsaWNJbnN0YW5jZSAmJiBvd25lclB1YmxpY0luc3RhbmNlLnJlZnNbcmVmXSA9PT0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpIHtcbiAgICAgIG93bmVyLmRldGFjaFJlZihyZWYpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0T3duZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0T3duZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgUmVhY3RJbnN0cnVtZW50YXRpb24gd2l0aCBhIF9fREVWX18gY2hlY2tcblxudmFyIGRlYnVnVG9vbCA9IG51bGw7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdERlYnVnVG9vbCA9IHJlcXVpcmUoJy4vUmVhY3REZWJ1Z1Rvb2wnKTtcbiAgZGVidWdUb29sID0gUmVhY3REZWJ1Z1Rvb2w7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWJ1Z1Rvb2w6IGRlYnVnVG9vbCB9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEluc3RydW1lbnRhdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2sgPSByZXF1aXJlKCcuL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2snKTtcbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2snKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhvb2tzID0gW107XG52YXIgZGlkSG9va1Rocm93Rm9yRXZlbnQgPSB7fTtcblxuZnVuY3Rpb24gY2FsbEhvb2soZXZlbnQsIGZuLCBjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIHRyeSB7XG4gICAgZm4uY2FsbChjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZEhvb2tUaHJvd0ZvckV2ZW50W2V2ZW50XSwgJ0V4Y2VwdGlvbiB0aHJvd24gYnkgaG9vayB3aGlsZSBoYW5kbGluZyAlczogJXMnLCBldmVudCwgZSArICdcXG4nICsgZS5zdGFjaykgOiB2b2lkIDA7XG4gICAgZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXZlbnQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBob29rID0gaG9va3NbaV07XG4gICAgdmFyIGZuID0gaG9va1tldmVudF07XG4gICAgaWYgKGZuKSB7XG4gICAgICBjYWxsSG9vayhldmVudCwgZm4sIGhvb2ssIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNQcm9maWxpbmcgPSBmYWxzZTtcbnZhciBmbHVzaEhpc3RvcnkgPSBbXTtcbnZhciBsaWZlQ3ljbGVUaW1lclN0YWNrID0gW107XG52YXIgY3VycmVudEZsdXNoTmVzdGluZyA9IDA7XG52YXIgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gW107XG52YXIgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gMDtcbnZhciBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xudmFyIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xudmFyIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xuXG52YXIgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2xlYXJIaXN0b3J5KCkge1xuICBSZWFjdENvbXBvbmVudFRyZWVIb29rLnB1cmdlVW5tb3VudGVkQ29tcG9uZW50cygpO1xuICBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5jbGVhckhpc3RvcnkoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpIHtcbiAgcmV0dXJuIHJlZ2lzdGVyZWRJRHMucmVkdWNlKGZ1bmN0aW9uICh0cmVlLCBpZCkge1xuICAgIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgICB2YXIgcGFyZW50SUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB0cmVlW2lkXSA9IHtcbiAgICAgIGRpc3BsYXlOYW1lOiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKSxcbiAgICAgIHRleHQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VGV4dChpZCksXG4gICAgICB1cGRhdGVDb3VudDogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRVcGRhdGVDb3VudChpZCksXG4gICAgICBjaGlsZElEczogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDaGlsZElEcyhpZCksXG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUgb3duZXJzIGJ1dCB0aGlzIGlzIGNsb3NlIGVub3VnaC5cbiAgICAgIG93bmVySUQ6IG93bmVySUQgfHwgcGFyZW50SUQgJiYgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKHBhcmVudElEKSB8fCAwLFxuICAgICAgcGFyZW50SUQ6IHBhcmVudElEXG4gICAgfTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiByZXNldE1lYXN1cmVtZW50cygpIHtcbiAgdmFyIHByZXZpb3VzU3RhcnRUaW1lID0gY3VycmVudEZsdXNoU3RhcnRUaW1lO1xuICB2YXIgcHJldmlvdXNNZWFzdXJlbWVudHMgPSBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHM7XG4gIHZhciBwcmV2aW91c09wZXJhdGlvbnMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5nZXRIaXN0b3J5KCk7XG5cbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSAwO1xuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xuICAgIGNsZWFySGlzdG9yeSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcmV2aW91c01lYXN1cmVtZW50cy5sZW5ndGggfHwgcHJldmlvdXNPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgIHZhciByZWdpc3RlcmVkSURzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRSZWdpc3RlcmVkSURzKCk7XG4gICAgZmx1c2hIaXN0b3J5LnB1c2goe1xuICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBwcmV2aW91c1N0YXJ0VGltZSxcbiAgICAgIG1lYXN1cmVtZW50czogcHJldmlvdXNNZWFzdXJlbWVudHMgfHwgW10sXG4gICAgICBvcGVyYXRpb25zOiBwcmV2aW91c09wZXJhdGlvbnMgfHwgW10sXG4gICAgICB0cmVlU25hcHNob3Q6IGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKVxuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJIaXN0b3J5KCk7XG4gIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xufVxuXG5mdW5jdGlvbiBjaGVja0RlYnVnSUQoZGVidWdJRCkge1xuICB2YXIgYWxsb3dSb290ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICBpZiAoYWxsb3dSb290ICYmIGRlYnVnSUQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFkZWJ1Z0lEKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERlYnVnVG9vbDogZGVidWdJRCBtYXkgbm90IGJlIGVtcHR5LicpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjdXJyZW50VGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnRGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RhcnQgd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XG4gIH1cbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBkZWJ1Z0lEO1xuICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xufVxuXG5mdW5jdGlvbiBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgIT09IHRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLiAnICsgJ1dlIGRpZCBub3QgZXhwZWN0ICVzIHRpbWVyIHRvIHN0b3Agd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuIFBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1ZyBpbiBSZWFjdC4nLCB0aW1lclR5cGUsIGN1cnJlbnRUaW1lclR5cGUgfHwgJ25vJywgZGVidWdJRCA9PT0gY3VycmVudFRpbWVyRGVidWdJRCA/ICd0aGUgc2FtZScgOiAnYW5vdGhlcicpIDogdm9pZCAwO1xuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMucHVzaCh7XG4gICAgICB0aW1lclR5cGU6IHRpbWVyVHlwZSxcbiAgICAgIGluc3RhbmNlSUQ6IGRlYnVnSUQsXG4gICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIGN1cnJlbnRUaW1lclN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb25cbiAgICB9KTtcbiAgfVxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcbiAgdmFyIGN1cnJlbnRUaW1lciA9IHtcbiAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lclN0YXJ0VGltZSxcbiAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZTogcGVyZm9ybWFuY2VOb3coKSxcbiAgICBkZWJ1Z0lEOiBjdXJyZW50VGltZXJEZWJ1Z0lELFxuICAgIHRpbWVyVHlwZTogY3VycmVudFRpbWVyVHlwZVxuICB9O1xuICBsaWZlQ3ljbGVUaW1lclN0YWNrLnB1c2goY3VycmVudFRpbWVyKTtcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gMDtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCkge1xuICB2YXIgX2xpZmVDeWNsZVRpbWVyU3RhY2skID0gbGlmZUN5Y2xlVGltZXJTdGFjay5wb3AoKSxcbiAgICAgIHN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5zdGFydFRpbWUsXG4gICAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5uZXN0ZWRGbHVzaFN0YXJ0VGltZSxcbiAgICAgIGRlYnVnSUQgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuZGVidWdJRCxcbiAgICAgIHRpbWVyVHlwZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC50aW1lclR5cGU7XG5cbiAgdmFyIG5lc3RlZEZsdXNoRHVyYXRpb24gPSBwZXJmb3JtYW5jZU5vdygpIC0gbmVzdGVkRmx1c2hTdGFydFRpbWU7XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiArPSBuZXN0ZWRGbHVzaER1cmF0aW9uO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcbn1cblxudmFyIGxhc3RNYXJrVGltZVN0YW1wID0gMDtcbnZhciBjYW5Vc2VQZXJmb3JtYW5jZU1lYXN1cmUgPVxuLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjM0NVxudHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gc2hvdWxkTWFyayhkZWJ1Z0lEKSB7XG4gIGlmICghaXNQcm9maWxpbmcgfHwgIWNhblVzZVBlcmZvcm1hbmNlTWVhc3VyZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChkZWJ1Z0lEKTtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGlzSG9zdEVsZW1lbnQgPSB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJztcbiAgaWYgKGlzSG9zdEVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1hcmtCZWdpbihkZWJ1Z0lELCBtYXJrVHlwZSkge1xuICBpZiAoIXNob3VsZE1hcmsoZGVidWdJRCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWFya05hbWUgPSBkZWJ1Z0lEICsgJzo6JyArIG1hcmtUeXBlO1xuICBsYXN0TWFya1RpbWVTdGFtcCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIHBlcmZvcm1hbmNlLm1hcmsobWFya05hbWUpO1xufVxuXG5mdW5jdGlvbiBtYXJrRW5kKGRlYnVnSUQsIG1hcmtUeXBlKSB7XG4gIGlmICghc2hvdWxkTWFyayhkZWJ1Z0lEKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXJrTmFtZSA9IGRlYnVnSUQgKyAnOjonICsgbWFya1R5cGU7XG4gIHZhciBkaXNwbGF5TmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoZGVidWdJRCkgfHwgJ1Vua25vd24nO1xuXG4gIC8vIENocm9tZSBoYXMgYW4gaXNzdWUgb2YgZHJvcHBpbmcgbWFya2VycyByZWNvcmRlZCB0b28gZmFzdDpcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjQwNjUyXG4gIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHdlIHdpbGwgbm90IHJlcG9ydCB2ZXJ5IHNtYWxsIG1lYXN1cmVtZW50cy5cbiAgLy8gSSBkZXRlcm1pbmVkIHRoZSBtYWdpYyBudW1iZXIgYnkgdHdlYWtpbmcgaXQgYmFjayBhbmQgZm9ydGguXG4gIC8vIDAuMDVtcyB3YXMgZW5vdWdoIHRvIHByZXZlbnQgdGhlIGlzc3VlLCBidXQgSSBzZXQgaXQgdG8gMC4xbXMgdG8gYmUgc2FmZS5cbiAgLy8gV2hlbiB0aGUgYnVnIGlzIGZpeGVkLCB3ZSBjYW4gYG1lYXN1cmUoKWAgdW5jb25kaXRpb25hbGx5IGlmIHdlIHdhbnQgdG8uXG4gIHZhciB0aW1lU3RhbXAgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBpZiAodGltZVN0YW1wIC0gbGFzdE1hcmtUaW1lU3RhbXAgPiAwLjEpIHtcbiAgICB2YXIgbWVhc3VyZW1lbnROYW1lID0gZGlzcGxheU5hbWUgKyAnIFsnICsgbWFya1R5cGUgKyAnXSc7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShtZWFzdXJlbWVudE5hbWUsIG1hcmtOYW1lKTtcbiAgfVxuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MobWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmVtZW50TmFtZSk7XG59XG5cbnZhciBSZWFjdERlYnVnVG9vbCA9IHtcbiAgYWRkSG9vazogZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rcy5wdXNoKGhvb2spO1xuICB9LFxuICByZW1vdmVIb29rOiBmdW5jdGlvbiAoaG9vaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChob29rc1tpXSA9PT0gaG9vaykge1xuICAgICAgICBob29rcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGlzUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzUHJvZmlsaW5nO1xuICB9LFxuICBiZWdpblByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzUHJvZmlsaW5nID0gdHJ1ZTtcbiAgICBmbHVzaEhpc3RvcnkubGVuZ3RoID0gMDtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIFJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xuICB9LFxuICBlbmRQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzUHJvZmlsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNQcm9maWxpbmcgPSBmYWxzZTtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIFJlYWN0RGVidWdUb29sLnJlbW92ZUhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xuICB9LFxuICBnZXRGbHVzaEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmx1c2hIaXN0b3J5O1xuICB9LFxuICBvbkJlZ2luRmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50Rmx1c2hOZXN0aW5nKys7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpO1xuICAgIGVtaXRFdmVudCgnb25CZWdpbkZsdXNoJyk7XG4gIH0sXG4gIG9uRW5kRmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIGN1cnJlbnRGbHVzaE5lc3RpbmctLTtcbiAgICByZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIoKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kRmx1c2gnKTtcbiAgfSxcbiAgb25CZWdpbkxpZmVDeWNsZVRpbWVyOiBmdW5jdGlvbiAoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWdpbkxpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBtYXJrQmVnaW4oZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBiZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIH0sXG4gIG9uRW5kTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBtYXJrRW5kKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgZW1pdEV2ZW50KCdvbkVuZExpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfSxcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgIGNoZWNrRGVidWdJRChvcGVyYXRpb24uaW5zdGFuY2VJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkhvc3RPcGVyYXRpb24nLCBvcGVyYXRpb24pO1xuICB9LFxuICBvblNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvblNldFN0YXRlJyk7XG4gIH0sXG4gIG9uU2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChkZWJ1Z0lELCBjaGlsZERlYnVnSURzKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGNoaWxkRGVidWdJRHMuZm9yRWFjaChjaGVja0RlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25TZXRDaGlsZHJlbicsIGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpO1xuICB9LFxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCwgcGFyZW50RGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBjaGVja0RlYnVnSUQocGFyZW50RGVidWdJRCwgdHJ1ZSk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZU1vdW50Q29tcG9uZW50JywgZGVidWdJRCwgZWxlbWVudCwgcGFyZW50RGVidWdJRCk7XG4gICAgbWFya0JlZ2luKGRlYnVnSUQsICdtb3VudCcpO1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBtYXJrRW5kKGRlYnVnSUQsICdtb3VudCcpO1xuICAgIGVtaXRFdmVudCgnb25Nb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudCcsIGRlYnVnSUQsIGVsZW1lbnQpO1xuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAndXBkYXRlJyk7XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBtYXJrRW5kKGRlYnVnSUQsICd1cGRhdGUnKTtcbiAgICBlbWl0RXZlbnQoJ29uVXBkYXRlQ29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZVVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgICBtYXJrQmVnaW4oZGVidWdJRCwgJ3VubW91bnQnKTtcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBtYXJrRW5kKGRlYnVnSUQsICd1bm1vdW50Jyk7XG4gICAgZW1pdEV2ZW50KCdvblVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25UZXN0RXZlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uVGVzdEV2ZW50Jyk7XG4gIH1cbn07XG5cbi8vIFRPRE8gcmVtb3ZlIHRoZXNlIHdoZW4gUk4vd3d3IGdldHMgdXBkYXRlZFxuUmVhY3REZWJ1Z1Rvb2wuYWRkRGV2dG9vbCA9IFJlYWN0RGVidWdUb29sLmFkZEhvb2s7XG5SZWFjdERlYnVnVG9vbC5yZW1vdmVEZXZ0b29sID0gUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlSG9vaztcblxuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rKTtcblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RDb21wb25lbnRUcmVlSG9vayk7XG52YXIgdXJsID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnO1xuaWYgKC9bPyZdcmVhY3RfcGVyZlxcYi8udGVzdCh1cmwpKSB7XG4gIFJlYWN0RGVidWdUb29sLmJlZ2luUHJvZmlsaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWJ1Z1Rvb2w7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RGVidWdUb29sLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSBmYWxzZTtcblxuICB2YXIgd2FybkludmFsaWRTZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCwgJ3NldFN0YXRlKC4uLik6IENhbm5vdCBjYWxsIHNldFN0YXRlKCkgaW5zaWRlIGdldENoaWxkQ29udGV4dCgpJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0ge1xuICBvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSB0cnVlO1xuICB9LFxuICBvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIH0sXG4gIG9uU2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB3YXJuSW52YWxpZFNldFN0YXRlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vay5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhpc3RvcnkgPSBbXTtcblxudmFyIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rID0ge1xuICBvbkhvc3RPcGVyYXRpb246IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICBoaXN0b3J5LnB1c2gob3BlcmF0aW9uKTtcbiAgfSxcbiAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLl9wcmV2ZW50Q2xlYXJpbmcpIHtcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhpc3RvcnkgPSBbXTtcbiAgfSxcbiAgZ2V0SGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoaXN0b3J5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIHBlcmZvcm1hbmNlID0gcmVxdWlyZSgnLi9wZXJmb3JtYW5jZScpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3c7XG5cbi8qKlxuICogRGV0ZWN0IGlmIHdlIGNhbiB1c2UgYHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKWAgYW5kIGdyYWNlZnVsbHkgZmFsbGJhY2sgdG9cbiAqIGBEYXRlLm5vdygpYCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBuZWVkIHRvIHN1cHBvcnQgRmlyZWZveCA8IDE1IGZvciBub3dcbiAqIGJlY2F1c2Ugb2YgRmFjZWJvb2sncyB0ZXN0aW5nIGluZnJhc3RydWN0dXJlLlxuICovXG5pZiAocGVyZm9ybWFuY2Uubm93KSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgcGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiBwZXJmb3JtYW5jZU5vdygpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZU5vdztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCB3aW5kb3cubXNQZXJmb3JtYW5jZSB8fCB3aW5kb3cud2Via2l0UGVyZm9ybWFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2UgfHwge307XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgT0JTRVJWRURfRVJST1IgPSB7fTtcblxuLyoqXG4gKiBgVHJhbnNhY3Rpb25gIGNyZWF0ZXMgYSBibGFjayBib3ggdGhhdCBpcyBhYmxlIHRvIHdyYXAgYW55IG1ldGhvZCBzdWNoIHRoYXRcbiAqIGNlcnRhaW4gaW52YXJpYW50cyBhcmUgbWFpbnRhaW5lZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSBtZXRob2QgaXMgaW52b2tlZFxuICogKEV2ZW4gaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBpbnZva2luZyB0aGUgd3JhcHBlZCBtZXRob2QpLiBXaG9ldmVyXG4gKiBpbnN0YW50aWF0ZXMgYSB0cmFuc2FjdGlvbiBjYW4gcHJvdmlkZSBlbmZvcmNlcnMgb2YgdGhlIGludmFyaWFudHMgYXRcbiAqIGNyZWF0aW9uIHRpbWUuIFRoZSBgVHJhbnNhY3Rpb25gIGNsYXNzIGl0c2VsZiB3aWxsIHN1cHBseSBvbmUgYWRkaXRpb25hbFxuICogYXV0b21hdGljIGludmFyaWFudCBmb3IgeW91IC0gdGhlIGludmFyaWFudCB0aGF0IGFueSB0cmFuc2FjdGlvbiBpbnN0YW5jZVxuICogc2hvdWxkIG5vdCBiZSBydW4gd2hpbGUgaXQgaXMgYWxyZWFkeSBiZWluZyBydW4uIFlvdSB3b3VsZCB0eXBpY2FsbHkgY3JlYXRlIGFcbiAqIHNpbmdsZSBpbnN0YW5jZSBvZiBhIGBUcmFuc2FjdGlvbmAgZm9yIHJldXNlIG11bHRpcGxlIHRpbWVzLCB0aGF0IHBvdGVudGlhbGx5XG4gKiBpcyB1c2VkIHRvIHdyYXAgc2V2ZXJhbCBkaWZmZXJlbnQgbWV0aG9kcy4gV3JhcHBlcnMgYXJlIGV4dHJlbWVseSBzaW1wbGUgLVxuICogdGhleSBvbmx5IHJlcXVpcmUgaW1wbGVtZW50aW5nIHR3byBtZXRob2RzLlxuICpcbiAqIDxwcmU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcnMgKGluamVjdGVkIGF0IGNyZWF0aW9uIHRpbWUpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAgICAgICAgK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgdiAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICAgICArLS0tLS0tLS0tLS0tLS0tKyAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgKy0tfCAgICB3cmFwcGVyMSAgIHwtLS18LS0tLSsgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICstLS0tLS0tLS0tLS0tLS0rICAgdiAgICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgKy0tLS18ICAgd3JhcHBlcjIgIHwtLS0tLS0tLSsgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgdiAgICAgdiAgICAgICAgICAgICAgICAgICAgIHYgICAgIHYgICB8IHdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8IGludmFyaWFudHNcbiAqIHBlcmZvcm0oYW55TWV0aG9kKSB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8IG1haW50YWluZWRcbiAqICstLS0tLS0tLS0tLS0tLS0tLT58LXwtLS18LXwtLS18LS0+fGFueU1ldGhvZHwtLS18LS0tfC18LS0tfC18LS0tLS0tLS0+XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfFxuICogICAgICAgICAgICAgICAgICAgIHwgIGluaXRpYWxpemUgICAgICAgICAgICAgICAgICAgIGNsb3NlICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKiA8L3ByZT5cbiAqXG4gKiBVc2UgY2FzZXM6XG4gKiAtIFByZXNlcnZpbmcgdGhlIGlucHV0IHNlbGVjdGlvbiByYW5nZXMgYmVmb3JlL2FmdGVyIHJlY29uY2lsaWF0aW9uLlxuICogICBSZXN0b3Jpbmcgc2VsZWN0aW9uIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGFuIHVuZXhwZWN0ZWQgZXJyb3IuXG4gKiAtIERlYWN0aXZhdGluZyBldmVudHMgd2hpbGUgcmVhcnJhbmdpbmcgdGhlIERPTSwgcHJldmVudGluZyBibHVycy9mb2N1c2VzLFxuICogICB3aGlsZSBndWFyYW50ZWVpbmcgdGhhdCBhZnRlcndhcmRzLCB0aGUgZXZlbnQgc3lzdGVtIGlzIHJlYWN0aXZhdGVkLlxuICogLSBGbHVzaGluZyBhIHF1ZXVlIG9mIGNvbGxlY3RlZCBET00gbXV0YXRpb25zIHRvIHRoZSBtYWluIFVJIHRocmVhZCBhZnRlciBhXG4gKiAgIHJlY29uY2lsaWF0aW9uIHRha2VzIHBsYWNlIGluIGEgd29ya2VyIHRocmVhZC5cbiAqIC0gSW52b2tpbmcgYW55IGNvbGxlY3RlZCBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgYWZ0ZXIgcmVuZGVyaW5nIG5ld1xuICogICBjb250ZW50LlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogV3JhcHBpbmcgcGFydGljdWxhciBmbHVzaGVzIG9mIHRoZSBgUmVhY3RXb3JrZXJgIHF1ZXVlXG4gKiAgIHRvIHByZXNlcnZlIHRoZSBgc2Nyb2xsVG9wYCAoYW4gYXV0b21hdGljIHNjcm9sbCBhd2FyZSBET00pLlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogTGF5b3V0IGNhbGN1bGF0aW9ucyBiZWZvcmUgYW5kIGFmdGVyIERPTSB1cGRhdGVzLlxuICpcbiAqIFRyYW5zYWN0aW9uYWwgcGx1Z2luIEFQSTpcbiAqIC0gQSBtb2R1bGUgdGhhdCBoYXMgYW4gYGluaXRpYWxpemVgIG1ldGhvZCB0aGF0IHJldHVybnMgYW55IHByZWNvbXB1dGF0aW9uLlxuICogLSBhbmQgYSBgY2xvc2VgIG1ldGhvZCB0aGF0IGFjY2VwdHMgdGhlIHByZWNvbXB1dGF0aW9uLiBgY2xvc2VgIGlzIGludm9rZWRcbiAqICAgd2hlbiB0aGUgd3JhcHBlZCBwcm9jZXNzIGlzIGNvbXBsZXRlZCwgb3IgaGFzIGZhaWxlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFRyYW5zYWN0aW9uYWxXcmFwcGVyPn0gdHJhbnNhY3Rpb25XcmFwcGVyIFdyYXBwZXIgbW9kdWxlc1xuICogdGhhdCBpbXBsZW1lbnQgYGluaXRpYWxpemVgIGFuZCBgY2xvc2VgLlxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IFNpbmdsZSB0cmFuc2FjdGlvbiBmb3IgcmV1c2UgaW4gdGhyZWFkLlxuICpcbiAqIEBjbGFzcyBUcmFuc2FjdGlvblxuICovXG52YXIgVHJhbnNhY3Rpb25JbXBsID0ge1xuICAvKipcbiAgICogU2V0cyB1cCB0aGlzIGluc3RhbmNlIHNvIHRoYXQgaXQgaXMgcHJlcGFyZWQgZm9yIGNvbGxlY3RpbmcgbWV0cmljcy4gRG9lc1xuICAgKiBzbyBzdWNoIHRoYXQgdGhpcyBzZXR1cCBtZXRob2QgbWF5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5XG4gICAqIGluaXRpYWxpemVkLCBpbiBhIHdheSB0aGF0IGRvZXMgbm90IGNvbnN1bWUgYWRkaXRpb25hbCBtZW1vcnkgdXBvbiByZXVzZS5cbiAgICogVGhhdCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBkZWNpZGUgdG8gbWFrZSB5b3VyIHN1YmNsYXNzIG9mIHRoaXMgbWl4aW4gYVxuICAgKiBcIlBvb2xlZENsYXNzXCIuXG4gICAqL1xuICByZWluaXRpYWxpemVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25XcmFwcGVycygpO1xuICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YSkge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gIH0sXG5cbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiB3cmFwcGVycy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXG5cbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNJblRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gd2l0aGluIGEgc2FmZXR5IHdpbmRvdy4gVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWxcbiAgICogbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiBsYXJnZSBhbW91bnRzIG9mIGNvbXB1dGF0aW9uL211dGF0aW9ucyB0aGF0IHdvdWxkXG4gICAqIG5lZWQgdG8gYmUgc2FmZXR5IGNoZWNrZWQuIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgaGVscHMgcHJldmVudCB0aGUgbmVlZFxuICAgKiB0byBiaW5kIGluIG1hbnkgY2FzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZW1iZXIgb2Ygc2NvcGUgdG8gY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFNjb3BlIHRvIGludm9rZSBmcm9tLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBhIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGMgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBkIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGYgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBSZXR1cm4gdmFsdWUgZnJvbSBgbWV0aG9kYC5cbiAgICovXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgISF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLnBlcmZvcm0oLi4uKTogQ2Fubm90IGluaXRpYWxpemUgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZXJlIGlzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24uJykgOiBfcHJvZEludmFyaWFudCgnMjcnKSA6IHZvaWQgMDtcbiAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAvLyBvbmUgb2YgdGhlc2UgY2FsbHMgdGhyZXcuXG4gICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVBbGwoMCk7XG4gICAgICByZXQgPSBtZXRob2QuY2FsbChzY29wZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBJZiBgbWV0aG9kYCB0aHJvd3MsIHByZWZlciB0byBzaG93IHRoYXQgc3RhY2sgdHJhY2Ugb3ZlciBhbnkgdGhyb3duXG4gICAgICAgICAgLy8gYnkgaW52b2tpbmcgYGNsb3NlQWxsYC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYG1ldGhvZGAgZGlkbid0IHRocm93LCB3ZSBkb24ndCB3YW50IHRvIHNpbGVuY2UgdGhlIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIGhlcmUuXG4gICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGggdGhlXG4gICAgICAgIC8vIE9CU0VSVkVEX0VSUk9SIHN0YXRlIGJlZm9yZSBvdmVyd3JpdGluZyBpdCB3aXRoIHRoZSByZWFsIHJldHVybiB2YWx1ZVxuICAgICAgICAvLyBvZiBpbml0aWFsaXplIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIE9CU0VSVkVEX0VSUk9SIGluIHRoZSBmaW5hbGx5XG4gICAgICAgIC8vIGJsb2NrLCBpdCBtZWFucyB3cmFwcGVyLmluaXRpYWxpemUgdGhyZXcuXG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gT0JTRVJWRURfRVJST1I7XG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gd3JhcHBlci5pbml0aWFsaXplID8gd3JhcHBlci5pbml0aWFsaXplLmNhbGwodGhpcykgOiBudWxsO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhW2ldID09PSBPQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIC8vIFRoZSBpbml0aWFsaXplciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBpbml0aWFsaXplIHRoZVxuICAgICAgICAgIC8vIHJlbWFpbmluZyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGVhY2ggb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5jbG9zZVtpXWAgZnVuY3Rpb25zLCBwYXNzaW5nIGludG9cbiAgICogdGhlbSB0aGUgcmVzcGVjdGl2ZSByZXR1cm4gdmFsdWVzIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuaW5pdFtpXWBcbiAgICogKGBjbG9zZWBycyB0aGF0IGNvcnJlc3BvbmQgdG8gaW5pdGlhbGl6ZXJzIHRoYXQgZmFpbGVkIHdpbGwgbm90IGJlXG4gICAqIGludm9rZWQpLlxuICAgKi9cbiAgY2xvc2VBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24uY2xvc2VBbGwoKTogQ2Fubm90IGNsb3NlIHRyYW5zYWN0aW9uIHdoZW4gbm9uZSBhcmUgb3Blbi4nKSA6IF9wcm9kSW52YXJpYW50KCcyOCcpIDogdm9pZCAwO1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy53cmFwcGVySW5pdERhdGFbaV07XG4gICAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgICAgLy8gd3JhcHBlci5jbG9zZSB0aHJldy5cbiAgICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBpZiAoaW5pdERhdGEgIT09IE9CU0VSVkVEX0VSUk9SICYmIHdyYXBwZXIuY2xvc2UpIHtcbiAgICAgICAgICB3cmFwcGVyLmNsb3NlLmNhbGwodGhpcywgaW5pdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBUaGUgY2xvc2VyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGNsb3NlIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAvLyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgICAgLy8gZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvbkltcGw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1RyYW5zYWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IDMgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudFRhcmdldDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRUYXJnZXQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCAmJiB1c2VIYXNGZWF0dXJlICYmIGV2ZW50TmFtZVN1ZmZpeCA9PT0gJ3doZWVsJykge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHRlc3Qgc3VwcG9ydCBmb3IgdGhlIGB3aGVlbGAgZXZlbnQgaW4gSUU5Ky5cbiAgICBpc1N1cHBvcnRlZCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50cy53aGVlbCcsICczLjAnKTtcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0V2ZW50U3VwcG9ydGVkO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG5cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICAnY29sb3InOiB0cnVlLFxuICAnZGF0ZSc6IHRydWUsXG4gICdkYXRldGltZSc6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gICdlbWFpbCc6IHRydWUsXG4gICdtb250aCc6IHRydWUsXG4gICdudW1iZXInOiB0cnVlLFxuICAncGFzc3dvcmQnOiB0cnVlLFxuICAncmFuZ2UnOiB0cnVlLFxuICAnc2VhcmNoJzogdHJ1ZSxcbiAgJ3RlbCc6IHRydWUsXG4gICd0ZXh0JzogdHJ1ZSxcbiAgJ3RpbWUnOiB0cnVlLFxuICAndXJsJzogdHJ1ZSxcbiAgJ3dlZWsnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dElucHV0RWxlbWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvaXNUZXh0SW5wdXRFbGVtZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xuXG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSBbJ1Jlc3BvbmRlckV2ZW50UGx1Z2luJywgJ1NpbXBsZUV2ZW50UGx1Z2luJywgJ1RhcEV2ZW50UGx1Z2luJywgJ0VudGVyTGVhdmVFdmVudFBsdWdpbicsICdDaGFuZ2VFdmVudFBsdWdpbicsICdTZWxlY3RFdmVudFBsdWdpbicsICdCZWZvcmVJbnB1dEV2ZW50UGx1Z2luJ107XG5cbm1vZHVsZS5leHBvcnRzID0gRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIG1vdXNlRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUVudGVyJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlTGVhdmUnLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9XG59O1xuXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gICAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAgICogd2UgZG8gbm90IGV4dHJhY3QgZHVwbGljYXRlIGV2ZW50cy4gSG93ZXZlciwgbW92aW5nIHRoZSBtb3VzZSBpbnRvIHRoZVxuICAgKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAgICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU92ZXInICYmIChuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU91dCcgJiYgdG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdmVyJykge1xuICAgICAgLy8gTXVzdCBub3QgYmUgYSBtb3VzZSBpbiBvciBtb3VzZSBvdXQgLSBpZ25vcmluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aW47XG4gICAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAgIC8vIGBuYXRpdmVFdmVudFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgICAgd2luID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbTtcbiAgICB2YXIgdG87XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3V0Jykge1xuICAgICAgZnJvbSA9IHRhcmdldEluc3Q7XG4gICAgICB2YXIgcmVsYXRlZCA9IG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50O1xuICAgICAgdG8gPSByZWxhdGVkID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoZnJvbSk7XG4gICAgdmFyIHRvTm9kZSA9IHRvID09IG51bGwgPyB3aW4gOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0byk7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlTGVhdmUsIGZyb20sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgbGVhdmUudHlwZSA9ICdtb3VzZWxlYXZlJztcbiAgICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG9Ob2RlO1xuXG4gICAgdmFyIGVudGVyID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUVudGVyLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKTtcblxuICAgIHJldHVybiBbbGVhdmUsIGVudGVyXTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVudGVyTGVhdmVFdmVudFBsdWdpbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIFdlYmtpdCwgRmlyZWZveCwgSUU5K1xuICAgIC8vIHdoaWNoOiAgMSAyIDNcbiAgICAvLyBidXR0b246IDAgMSAyIChzdGFuZGFyZClcbiAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIGlmICgnd2hpY2gnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvLyBJRTw5XG4gICAgLy8gd2hpY2g6ICB1bmRlZmluZWRcbiAgICAvLyBidXR0b246IDAgMCAwXG4gICAgLy8gYnV0dG9uOiAxIDQgMiAob25tb3VzZXVwKVxuICAgIHJldHVybiBidXR0b24gPT09IDIgPyAyIDogYnV0dG9uID09PSA0ID8gMSA6IDA7XG4gIH0sXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfSxcbiAgLy8gXCJQcm9wcmlldGFyeVwiIEludGVyZmFjZS5cbiAgcGFnZVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVgnIGluIGV2ZW50ID8gZXZlbnQucGFnZVggOiBldmVudC5jbGllbnRYICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0O1xuICB9LFxuICBwYWdlWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWScgaW4gZXZlbnQgPyBldmVudC5wYWdlWSA6IGV2ZW50LmNsaWVudFkgKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljTW91c2VFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljTW91c2VFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyB0YXJnZXQgaXMgYSB3aW5kb3cgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgaWYgKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgfSxcbiAgZGV0YWlsOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1VJRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmlld3BvcnRNZXRyaWNzID0ge1xuXG4gIGN1cnJlbnRTY3JvbGxMZWZ0OiAwLFxuXG4gIGN1cnJlbnRTY3JvbGxUb3A6IDAsXG5cbiAgcmVmcmVzaFNjcm9sbFZhbHVlczogZnVuY3Rpb24gKHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0ID0gc2Nyb2xsUG9zaXRpb24ueDtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcCA9IHNjcm9sbFBvc2l0aW9uLnk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydE1ldHJpY3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICAnQWx0JzogJ2FsdEtleScsXG4gICdDb250cm9sJzogJ2N0cmxLZXknLFxuICAnTWV0YSc6ICdtZXRhS2V5JyxcbiAgJ1NoaWZ0JzogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcblxudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgaXNDdXN0b21BdHRyaWJ1dGU6IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKG5ldyBSZWdFeHAoJ14oZGF0YXxhcmlhKS1bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJykpLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogMCxcbiAgICBhY2NlcHRDaGFyc2V0OiAwLFxuICAgIGFjY2Vzc0tleTogMCxcbiAgICBhY3Rpb246IDAsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogMCxcbiAgICBhbHQ6IDAsXG4gICAgLy8gc3BlY2lmaWVzIHRhcmdldCBjb250ZXh0IGZvciBsaW5rcyB3aXRoIGBwcmVsb2FkYCB0eXBlXG4gICAgYXM6IDAsXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9Db21wbGV0ZTogMCxcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c1V0aWxzXG4gICAgLy8gYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2FwdHVyZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2VsbFBhZGRpbmc6IDAsXG4gICAgY2VsbFNwYWNpbmc6IDAsXG4gICAgY2hhclNldDogMCxcbiAgICBjaGFsbGVuZ2U6IDAsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjaXRlOiAwLFxuICAgIGNsYXNzSUQ6IDAsXG4gICAgY2xhc3NOYW1lOiAwLFxuICAgIGNvbHM6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IDAsXG4gICAgY29udGVudDogMCxcbiAgICBjb250ZW50RWRpdGFibGU6IDAsXG4gICAgY29udGV4dE1lbnU6IDAsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNvb3JkczogMCxcbiAgICBjcm9zc09yaWdpbjogMCxcbiAgICBkYXRhOiAwLCAvLyBGb3IgYDxvYmplY3QgLz5gIGFjdHMgYXMgYHNyY2AuXG4gICAgZGF0ZVRpbWU6IDAsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiAwLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IDAsXG4gICAgZW5jVHlwZTogMCxcbiAgICBmb3JtOiAwLFxuICAgIGZvcm1BY3Rpb246IDAsXG4gICAgZm9ybUVuY1R5cGU6IDAsXG4gICAgZm9ybU1ldGhvZDogMCxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybVRhcmdldDogMCxcbiAgICBmcmFtZUJvcmRlcjogMCxcbiAgICBoZWFkZXJzOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBoaWRkZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZ2g6IDAsXG4gICAgaHJlZjogMCxcbiAgICBocmVmTGFuZzogMCxcbiAgICBodG1sRm9yOiAwLFxuICAgIGh0dHBFcXVpdjogMCxcbiAgICBpY29uOiAwLFxuICAgIGlkOiAwLFxuICAgIGlucHV0TW9kZTogMCxcbiAgICBpbnRlZ3JpdHk6IDAsXG4gICAgaXM6IDAsXG4gICAga2V5UGFyYW1zOiAwLFxuICAgIGtleVR5cGU6IDAsXG4gICAga2luZDogMCxcbiAgICBsYWJlbDogMCxcbiAgICBsYW5nOiAwLFxuICAgIGxpc3Q6IDAsXG4gICAgbG9vcDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG93OiAwLFxuICAgIG1hbmlmZXN0OiAwLFxuICAgIG1hcmdpbkhlaWdodDogMCxcbiAgICBtYXJnaW5XaWR0aDogMCxcbiAgICBtYXg6IDAsXG4gICAgbWF4TGVuZ3RoOiAwLFxuICAgIG1lZGlhOiAwLFxuICAgIG1lZGlhR3JvdXA6IDAsXG4gICAgbWV0aG9kOiAwLFxuICAgIG1pbjogMCxcbiAgICBtaW5MZW5ndGg6IDAsXG4gICAgLy8gQ2F1dGlvbjsgYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbiAgICAvLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLlxuICAgIG11bHRpcGxlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG11dGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG5hbWU6IDAsXG4gICAgbm9uY2U6IDAsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3B0aW11bTogMCxcbiAgICBwYXR0ZXJuOiAwLFxuICAgIHBsYWNlaG9sZGVyOiAwLFxuICAgIHBsYXlzSW5saW5lOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBwb3N0ZXI6IDAsXG4gICAgcHJlbG9hZDogMCxcbiAgICBwcm9maWxlOiAwLFxuICAgIHJhZGlvR3JvdXA6IDAsXG4gICAgcmVhZE9ubHk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlZmVycmVyUG9saWN5OiAwLFxuICAgIHJlbDogMCxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvbGU6IDAsXG4gICAgcm93czogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgcm93U3BhbjogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc2FuZGJveDogMCxcbiAgICBzY29wZTogMCxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNjcm9sbGluZzogMCxcbiAgICBzZWFtbGVzczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2hhcGU6IDAsXG4gICAgc2l6ZTogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc2l6ZXM6IDAsXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogMCxcbiAgICBzcmM6IDAsXG4gICAgc3JjRG9jOiAwLFxuICAgIHNyY0xhbmc6IDAsXG4gICAgc3JjU2V0OiAwLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzdGVwOiAwLFxuICAgIHN0eWxlOiAwLFxuICAgIHN1bW1hcnk6IDAsXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgdGFyZ2V0OiAwLFxuICAgIHRpdGxlOiAwLFxuICAgIC8vIFNldHRpbmcgLnR5cGUgdGhyb3dzIG9uIG5vbi08aW5wdXQ+IHRhZ3NcbiAgICB0eXBlOiAwLFxuICAgIHVzZU1hcDogMCxcbiAgICB2YWx1ZTogMCxcbiAgICB3aWR0aDogMCxcbiAgICB3bW9kZTogMCxcbiAgICB3cmFwOiAwLFxuXG4gICAgLyoqXG4gICAgICogUkRGYSBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWJvdXQ6IDAsXG4gICAgZGF0YXR5cGU6IDAsXG4gICAgaW5saXN0OiAwLFxuICAgIHByZWZpeDogMCxcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIHN1cHBvcnRlZCBmb3IgT3BlbkdyYXBoIGluIG1ldGEgdGFncy5cbiAgICBwcm9wZXJ0eTogMCxcbiAgICByZXNvdXJjZTogMCxcbiAgICAndHlwZW9mJzogMCxcbiAgICB2b2NhYjogMCxcblxuICAgIC8qKlxuICAgICAqIE5vbi1zdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgLy8gYXV0b0NhcGl0YWxpemUgYW5kIGF1dG9Db3JyZWN0IGFyZSBzdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3JcbiAgICAvLyBrZXlib2FyZCBoaW50cy5cbiAgICBhdXRvQ2FwaXRhbGl6ZTogMCxcbiAgICBhdXRvQ29ycmVjdDogMCxcbiAgICAvLyBhdXRvU2F2ZSBhbGxvd3MgV2ViS2l0L0JsaW5rIHRvIHBlcnNpc3QgdmFsdWVzIG9mIGlucHV0IGZpZWxkcyBvbiBwYWdlIHJlbG9hZHNcbiAgICBhdXRvU2F2ZTogMCxcbiAgICAvLyBjb2xvciBpcyBmb3IgU2FmYXJpIG1hc2staWNvbiBsaW5rXG4gICAgY29sb3I6IDAsXG4gICAgLy8gaXRlbVByb3AsIGl0ZW1TY29wZSwgaXRlbVR5cGUgYXJlIGZvclxuICAgIC8vIE1pY3JvZGF0YSBzdXBwb3J0LiBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVByb3A6IDAsXG4gICAgaXRlbVNjb3BlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBpdGVtVHlwZTogMCxcbiAgICAvLyBpdGVtSUQgYW5kIGl0ZW1SZWYgYXJlIGZvciBNaWNyb2RhdGEgc3VwcG9ydCBhcyB3ZWxsIGJ1dFxuICAgIC8vIG9ubHkgc3BlY2lmaWVkIGluIHRoZSBXSEFUV0cgc3BlYyBkb2N1bWVudC4gU2VlXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbWljcm9kYXRhLmh0bWwjbWljcm9kYXRhLWRvbS1hcGlcbiAgICBpdGVtSUQ6IDAsXG4gICAgaXRlbVJlZjogMCxcbiAgICAvLyByZXN1bHRzIHNob3cgbG9va2luZyBnbGFzcyBpY29uIGFuZCByZWNlbnQgc2VhcmNoZXMgb24gaW5wdXRcbiAgICAvLyBzZWFyY2ggZmllbGRzIGluIFdlYktpdC9CbGlua1xuICAgIHJlc3VsdHM6IDAsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgc2VjdXJpdHkgcmVzdHJpY3Rpb25zIG9uIGFuIGlmcmFtZVxuICAgIC8vIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBzYW5kYm94IGF0dHJpYnV0ZSBvbiBJRTwxMFxuICAgIHNlY3VyaXR5OiAwLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgZm9jdXMgYmVoYXZpb3JcbiAgICB1bnNlbGVjdGFibGU6IDBcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRE9NUHJvcGVydHlDb25maWc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0hUTUxET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdERPTUlET3BlcmF0aW9ucycpO1xuXG4vKipcbiAqIEFic3RyYWN0cyBhd2F5IGFsbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSByZWNvbmNpbGVyIHRoYXQgcmVxdWlyZXMga25vd2xlZGdlIG9mXG4gKiB0aGUgYnJvd3NlciBjb250ZXh0LiBUT0RPOiBUaGVzZSBjYWxsZXJzIHNob3VsZCBiZSByZWZhY3RvcmVkIHRvIGF2b2lkIHRoZVxuICogbmVlZCBmb3IgdGhpcyBpbmplY3Rpb24uXG4gKi9cbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHtcblxuICBwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBSZWFjdERPTUlET3BlcmF0aW9ucy5kYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMsXG5cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBET01DaGlsZHJlbk9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRGFuZ2VyID0gcmVxdWlyZSgnLi9EYW5nZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG5cbmZ1bmN0aW9uIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCBub2RlKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgdGV4dCBjb21wb25lbnRzLCB3aGljaCByZXR1cm4gW29wZW4sIGNsb3NlXSBjb21tZW50c1xuICAvLyBmcm9tIGdldEhvc3ROb2RlLlxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIG5vZGUgPSBub2RlWzFdO1xuICB9XG4gIHJldHVybiBub2RlID8gbm9kZS5uZXh0U2libGluZyA6IHBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGBjaGlsZE5vZGVgIGFzIGEgY2hpbGQgb2YgYHBhcmVudE5vZGVgIGF0IHRoZSBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcGFyZW50Tm9kZSBQYXJlbnQgbm9kZSBpbiB3aGljaCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNoaWxkTm9kZSBDaGlsZCBub2RlIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICogQGludGVybmFsXG4gKi9cbnZhciBpbnNlcnRDaGlsZEF0ID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIC8vIFdlIHJlbHkgZXhjbHVzaXZlbHkgb24gYGluc2VydEJlZm9yZShub2RlLCBudWxsKWAgaW5zdGVhZCBvZiBhbHNvIHVzaW5nXG4gIC8vIGBhcHBlbmRDaGlsZChub2RlKWAuIChVc2luZyBgdW5kZWZpbmVkYCBpcyBub3QgYWxsb3dlZCBieSBhbGwgYnJvd3NlcnMgc29cbiAgLy8gd2UgYXJlIGNhcmVmdWwgdG8gdXNlIGBudWxsYC4pXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59KTtcblxuZnVuY3Rpb24gaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSkge1xuICBET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlKHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIG1vdmVDaGlsZChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGROb2RlKSkge1xuICAgIG1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZVswXSwgY2hpbGROb2RlWzFdLCByZWZlcmVuY2VOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBjaGlsZE5vZGVbMV07XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlWzBdO1xuICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBjbG9zaW5nQ29tbWVudCk7XG4gICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9zaW5nQ29tbWVudCk7XG4gIH1cbiAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZE5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQsIHJlZmVyZW5jZU5vZGUpIHtcbiAgdmFyIG5vZGUgPSBvcGVuaW5nQ29tbWVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgbm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgaWYgKG5vZGUgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbm9kZSA9IG5leHROb2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgc3RhcnROb2RlLCBjbG9zaW5nQ29tbWVudCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlLm5leHRTaWJsaW5nO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgLy8gVGhlIGNsb3NpbmcgY29tbWVudCBpcyByZW1vdmVkIGJ5IFJlYWN0TXVsdGlDaGlsZC5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlRGVsaW1pdGVkVGV4dChvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQsIHN0cmluZ1RleHQpIHtcbiAgdmFyIHBhcmVudE5vZGUgPSBvcGVuaW5nQ29tbWVudC5wYXJlbnROb2RlO1xuICB2YXIgbm9kZUFmdGVyQ29tbWVudCA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xuICBpZiAobm9kZUFmdGVyQ29tbWVudCA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAvLyBUaGVyZSBhcmUgbm8gdGV4dCBub2RlcyBiZXR3ZWVuIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIGNvbW1lbnRzOyBpbnNlcnRcbiAgICAvLyBhIG5ldyBvbmUgaWYgc3RyaW5nVGV4dCBpc24ndCBlbXB0eS5cbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHJpbmdUZXh0KSwgbm9kZUFmdGVyQ29tbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzdHJpbmdUZXh0KSB7XG4gICAgICAvLyBTZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgZmlyc3Qgbm9kZSBhZnRlciB0aGUgb3BlbmluZyBjb21tZW50LCBhbmRcbiAgICAgIC8vIHJlbW92ZSBhbGwgZm9sbG93aW5nIG5vZGVzIHVwIHVudGlsIHRoZSBjbG9zaW5nIGNvbW1lbnQuXG4gICAgICBzZXRUZXh0Q29udGVudChub2RlQWZ0ZXJDb21tZW50LCBzdHJpbmdUZXh0KTtcbiAgICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgbm9kZUFmdGVyQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG9wZW5pbmdDb21tZW50KS5fZGVidWdJRCxcbiAgICAgIHR5cGU6ICdyZXBsYWNlIHRleHQnLFxuICAgICAgcGF5bG9hZDogc3RyaW5nVGV4dFxuICAgIH0pO1xuICB9XG59XG5cbnZhciBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRDaGlsZCwgbWFya3VwKTtcbiAgICBpZiAocHJldkluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgaW5zdGFuY2VJRDogcHJldkluc3RhbmNlLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAncmVwbGFjZSB3aXRoJyxcbiAgICAgICAgcGF5bG9hZDogbWFya3VwLnRvU3RyaW5nKClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobWFya3VwLm5vZGUpO1xuICAgICAgaWYgKG5leHRJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICBpbnN0YW5jZUlEOiBuZXh0SW5zdGFuY2UuX2RlYnVnSUQsXG4gICAgICAgICAgdHlwZTogJ21vdW50JyxcbiAgICAgICAgICBwYXlsb2FkOiBtYXJrdXAudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgdXBkYXRpbmcgd2l0aCBET00gY2hpbGRyZW4uXG4gKi9cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSB7XG5cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwLFxuXG4gIHJlcGxhY2VEZWxpbWl0ZWRUZXh0OiByZXBsYWNlRGVsaW1pdGVkVGV4dCxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy4gVGhlXG4gICAqIHVwZGF0ZSBjb25maWd1cmF0aW9ucyBhcmUgZWFjaCBleHBlY3RlZCB0byBoYXZlIGEgYHBhcmVudE5vZGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc1VwZGF0ZXM6IGZ1bmN0aW9uIChwYXJlbnROb2RlLCB1cGRhdGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnROb2RlRGVidWdJRCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHBhcmVudE5vZGUpLl9kZWJ1Z0lEO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdXBkYXRlcy5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIHVwZGF0ZSA9IHVwZGF0ZXNba107XG4gICAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0lOU0VSVF9NQVJLVVAnOlxuICAgICAgICAgIGluc2VydExhenlUcmVlQ2hpbGRBdChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCwgZ2V0Tm9kZUFmdGVyKHBhcmVudE5vZGUsIHVwZGF0ZS5hZnRlck5vZGUpKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAnaW5zZXJ0IGNoaWxkJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogeyB0b0luZGV4OiB1cGRhdGUudG9JbmRleCwgY29udGVudDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01PVkVfRVhJU1RJTkcnOlxuICAgICAgICAgIG1vdmVDaGlsZChwYXJlbnROb2RlLCB1cGRhdGUuZnJvbU5vZGUsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ21vdmUgY2hpbGQnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiB7IGZyb21JbmRleDogdXBkYXRlLmZyb21JbmRleCwgdG9JbmRleDogdXBkYXRlLnRvSW5kZXggfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTRVRfTUFSS1VQJzpcbiAgICAgICAgICBzZXRJbm5lckhUTUwocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXG4gICAgICAgICAgICAgIHR5cGU6ICdyZXBsYWNlIGNoaWxkcmVuJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdURVhUX0NPTlRFTlQnOlxuICAgICAgICAgIHNldFRleHRDb250ZW50KHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAncmVwbGFjZSB0ZXh0JyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSRU1PVkVfTk9ERSc6XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAncmVtb3ZlIGNoaWxkJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXggfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUNoaWxkcmVuT3BlcmF0aW9ucztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG4vKipcbiAqIEluIElFICg4LTExKSBhbmQgRWRnZSwgYXBwZW5kaW5nIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gaXMgZHJhbWF0aWNhbGx5XG4gKiBmYXN0ZXIgdGhhbiBhcHBlbmRpbmcgYSBmdWxsIHN1YnRyZWUsIHNvIHdlIGVzc2VudGlhbGx5IHF1ZXVlIHVwIHRoZVxuICogLmFwcGVuZENoaWxkIGNhbGxzIGhlcmUgYW5kIGFwcGx5IHRoZW0gc28gZWFjaCBub2RlIGlzIGFkZGVkIHRvIGl0cyBwYXJlbnRcbiAqIGJlZm9yZSBhbnkgY2hpbGRyZW4gYXJlIGFkZGVkLlxuICpcbiAqIEluIG90aGVyIGJyb3dzZXJzLCBkb2luZyBzbyBpcyBzbG93ZXIgb3IgbmV1dHJhbCBjb21wYXJlZCB0byB0aGUgb3RoZXIgb3JkZXJcbiAqIChpbiBGaXJlZm94LCB0d2ljZSBhcyBzbG93KSBzbyB3ZSBvbmx5IGRvIHRoaXMgaW52ZXJzaW9uIGluIElFLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3BpY3lqL2lubmVyaHRtbC12cy1jcmVhdGVlbGVtZW50LXZzLWNsb25lbm9kZS5cbiAqL1xudmFyIGVuYWJsZUxhenkgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJyAmJiAvXFxiRWRnZVxcL1xcZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuZnVuY3Rpb24gaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpIHtcbiAgaWYgKCFlbmFibGVMYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBub2RlID0gdHJlZS5ub2RlO1xuICB2YXIgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaW5zZXJ0VHJlZUJlZm9yZShub2RlLCBjaGlsZHJlbltpXSwgbnVsbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRyZWUuaHRtbCAhPSBudWxsKSB7XG4gICAgc2V0SW5uZXJIVE1MKG5vZGUsIHRyZWUuaHRtbCk7XG4gIH0gZWxzZSBpZiAodHJlZS50ZXh0ICE9IG51bGwpIHtcbiAgICBzZXRUZXh0Q29udGVudChub2RlLCB0cmVlLnRleHQpO1xuICB9XG59XG5cbnZhciBpbnNlcnRUcmVlQmVmb3JlID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgdHJlZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmVuJ3QgYWN0dWFsbHkgcGFydCBvZiB0aGUgRE9NIGFmdGVyIGluc2VydGlvbiBzb1xuICAvLyBhcHBlbmRpbmcgY2hpbGRyZW4gd29uJ3QgdXBkYXRlIHRoZSBET00uIFdlIG5lZWQgdG8gZW5zdXJlIHRoZSBmcmFnbWVudFxuICAvLyBpcyBwcm9wZXJseSBwb3B1bGF0ZWQgZmlyc3QsIGJyZWFraW5nIG91dCBvZiBvdXIgbGF6eSBhcHByb2FjaCBmb3IganVzdFxuICAvLyB0aGlzIGxldmVsLiBBbHNvLCBzb21lIDxvYmplY3Q+IHBsdWdpbnMgKGxpa2UgRmxhc2ggUGxheWVyKSB3aWxsIHJlYWRcbiAgLy8gPHBhcmFtPiBub2RlcyBpbW1lZGlhdGVseSB1cG9uIGluc2VydGlvbiBpbnRvIHRoZSBET00sIHNvIDxvYmplY3Q+XG4gIC8vIG11c3QgYWxzbyBiZSBwb3B1bGF0ZWQgcHJpb3IgdG8gaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAgaWYgKHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFIHx8IHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgJiYgdHJlZS5ub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnICYmICh0cmVlLm5vZGUubmFtZXNwYWNlVVJJID09IG51bGwgfHwgdHJlZS5ub2RlLm5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSkge1xuICAgIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKTtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRyZWUubm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gcmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkTm9kZSwgbmV3VHJlZSkge1xuICBvbGROb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld1RyZWUubm9kZSwgb2xkTm9kZSk7XG4gIGluc2VydFRyZWVDaGlsZHJlbihuZXdUcmVlKTtcbn1cblxuZnVuY3Rpb24gcXVldWVDaGlsZChwYXJlbnRUcmVlLCBjaGlsZFRyZWUpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICBwYXJlbnRUcmVlLmNoaWxkcmVuLnB1c2goY2hpbGRUcmVlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRUcmVlLm5vZGUuYXBwZW5kQ2hpbGQoY2hpbGRUcmVlLm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSFRNTCh0cmVlLCBodG1sKSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgdHJlZS5odG1sID0gaHRtbDtcbiAgfSBlbHNlIHtcbiAgICBzZXRJbm5lckhUTUwodHJlZS5ub2RlLCBodG1sKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBxdWV1ZVRleHQodHJlZSwgdGV4dCkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHRyZWUudGV4dCA9IHRleHQ7XG4gIH0gZWxzZSB7XG4gICAgc2V0VGV4dENvbnRlbnQodHJlZS5ub2RlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHRoaXMubm9kZS5ub2RlTmFtZTtcbn1cblxuZnVuY3Rpb24gRE9NTGF6eVRyZWUobm9kZSkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IG5vZGUsXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGh0bWw6IG51bGwsXG4gICAgdGV4dDogbnVsbCxcbiAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgfTtcbn1cblxuRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZSA9IGluc2VydFRyZWVCZWZvcmU7XG5ET01MYXp5VHJlZS5yZXBsYWNlQ2hpbGRXaXRoVHJlZSA9IHJlcGxhY2VDaGlsZFdpdGhUcmVlO1xuRE9NTGF6eVRyZWUucXVldWVDaGlsZCA9IHF1ZXVlQ2hpbGQ7XG5ET01MYXp5VHJlZS5xdWV1ZUhUTUwgPSBxdWV1ZUhUTUw7XG5ET01MYXp5VHJlZS5xdWV1ZVRleHQgPSBxdWV1ZVRleHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NTGF6eVRyZWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0RPTUxhenlUcmVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgbWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01OYW1lc3BhY2VzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9ET01OYW1lc3BhY2VzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG5cbnZhciBXSElURVNQQUNFX1RFU1QgPSAvXlsgXFxyXFxuXFx0XFxmXS87XG52YXIgTk9OVklTSUJMRV9URVNUID0gLzwoIS0tfGxpbmt8bm9zY3JpcHR8bWV0YXxzY3JpcHR8c3R5bGUpWyBcXHJcXG5cXHRcXGZcXC8+XS87XG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uJyk7XG5cbi8vIFNWRyB0ZW1wIGNvbnRhaW5lciBmb3IgSUUgbGFja2luZyBpbm5lckhUTUxcbnZhciByZXVzYWJsZVNWR0NvbnRhaW5lcjtcblxuLyoqXG4gKiBTZXQgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0SW5uZXJIVE1MID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAvLyB0aGUgdGFyZ2V0IG5vZGVcbiAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLnN2ZyAmJiAhKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2Zz4nICsgaHRtbCArICc8L3N2Zz4nO1xuICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU4OiBXaGVuIHVwZGF0aW5nIGEganVzdCBjcmVhdGVkIG5vZGUgd2l0aCBpbm5lckhUTUwgb25seSBsZWFkaW5nXG4gIC8vIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZC4gV2hlbiB1cGRhdGluZyBhbiBleGlzdGluZyBub2RlIHdpdGggaW5uZXJIVE1MXG4gIC8vIHdoaXRlc3BhY2UgaW4gcm9vdCBUZXh0Tm9kZXMgaXMgYWxzbyBjb2xsYXBzZWQuXG4gIC8vIEBzZWUgcXVpcmtzbW9kZS5vcmcvYnVncmVwb3J0cy9hcmNoaXZlcy8yMDA0LzExL2lubmVyaHRtbF9hbmRfdC5odG1sXG5cbiAgLy8gRmVhdHVyZSBkZXRlY3Rpb247IG9ubHkgSUU4IGlzIGtub3duIHRvIGJlaGF2ZSBpbXByb3Blcmx5IGxpa2UgdGhpcy5cbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRlc3RFbGVtZW50LmlubmVySFRNTCA9ICcgJztcbiAgaWYgKHRlc3RFbGVtZW50LmlubmVySFRNTCA9PT0gJycpIHtcbiAgICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgICAgLy8gTWFnaWMgdGhlb3J5OiBJRTggc3VwcG9zZWRseSBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFkZGVkIGFuZCB1cGRhdGVkXG4gICAgICAvLyBub2RlcyB3aGVuIHByb2Nlc3NpbmcgaW5uZXJIVE1MLCBpbm5lckhUTUwgb24gdXBkYXRlZCBub2RlcyBzdWZmZXJzXG4gICAgICAvLyBmcm9tIHdvcnNlIHdoaXRlc3BhY2UgYmVoYXZpb3IuIFJlLWFkZGluZyBhIG5vZGUgbGlrZSB0aGlzIHRyaWdnZXJzXG4gICAgICAvLyB0aGUgaW5pdGlhbCBhbmQgbW9yZSBmYXZvcmFibGUgd2hpdGVzcGFjZSBiZWhhdmlvci5cbiAgICAgIC8vIFRPRE86IFdoYXQgdG8gZG8gb24gYSBkZXRhY2hlZCBub2RlP1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBhbHNvIGltcGxlbWVudCBhIHdvcmthcm91bmQgZm9yIG5vbi12aXNpYmxlIHRhZ3MgZGlzYXBwZWFyaW5nIGludG9cbiAgICAgIC8vIHRoaW4gYWlyIG9uIElFOCwgdGhpcyBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSB0ZXh0XG4gICAgICAvLyBpbi1mcm9udCBvZiB0aGUgbm9uLXZpc2libGUgdGFncy4gUGlnZ3liYWNrIG9uIHRoZSB3aGl0ZXNwYWNlIGZpeFxuICAgICAgLy8gYW5kIHNpbXBseSBjaGVjayBpZiBhbnkgbm9uLXZpc2libGUgdGFncyBhcHBlYXIgaW4gdGhlIHNvdXJjZS5cbiAgICAgIGlmIChXSElURVNQQUNFX1RFU1QudGVzdChodG1sKSB8fCBodG1sWzBdID09PSAnPCcgJiYgTk9OVklTSUJMRV9URVNULnRlc3QoaHRtbCkpIHtcbiAgICAgICAgLy8gUmVjb3ZlciBsZWFkaW5nIHdoaXRlc3BhY2UgYnkgdGVtcG9yYXJpbHkgcHJlcGVuZGluZyBhbnkgY2hhcmFjdGVyLlxuICAgICAgICAvLyBcXHVGRUZGIGhhcyB0aGUgcG90ZW50aWFsIGFkdmFudGFnZSBvZiBiZWluZyB6ZXJvLXdpZHRoL2ludmlzaWJsZS5cbiAgICAgICAgLy8gVWdsaWZ5SlMgZHJvcHMgVStGRUZGIGNoYXJzIHdoZW4gcGFyc2luZywgc28gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgLy8gaW4gaG9wZXMgdGhhdCB0aGlzIGlzIHByZXNlcnZlZCBldmVuIGlmIFwiXFx1RkVGRlwiIGlzIHRyYW5zZm9ybWVkIHRvXG4gICAgICAgIC8vIHRoZSBhY3R1YWwgVW5pY29kZSBjaGFyYWN0ZXIgKGJ5IEJhYmVsLCBmb3IgZXhhbXBsZSkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2Jsb2IvdjIuNC4yMC9saWIvcGFyc2UuanMjTDIxNlxuICAgICAgICBub2RlLmlubmVySFRNTCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRUZGKSArIGh0bWw7XG5cbiAgICAgICAgLy8gZGVsZXRlRGF0YSBsZWF2ZXMgYW4gZW1wdHkgYFRleHROb2RlYCB3aGljaCBvZmZzZXRzIHRoZSBpbmRleCBvZiBhbGxcbiAgICAgICAgLy8gY2hpbGRyZW4uIERlZmluaXRlbHkgd2FudCB0byBhdm9pZCB0aGlzLlxuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZS5kYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL3NldElubmVySFRNTC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn07XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VGV4dENvbnRlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL3NldFRleHRDb250ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQmFzZWQgb24gdGhlIGVzY2FwZS1odG1sIGxpYnJhcnksIHdoaWNoIGlzIHVzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIGJlbG93OlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDEzIFRKIEhvbG93YXljaHVrXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQW5kcmVhcyBMdWJiZVxuICogQ29weXJpZ2h0IChjKSAyMDE1IFRpYW5jaGVuZyBcIlRpbW90aHlcIiBHdVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiAnU29mdHdhcmUnKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbiAqIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG4gKiBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuICogU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XG5cbi8qKlxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGh0bWwuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUgZm9yIGluc2VydGluZyBpbnRvIEhUTUxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB2YXIgc3RyID0gJycgKyBzdHJpbmc7XG4gIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHN0cik7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgZXNjYXBlO1xuICB2YXIgaHRtbCA9ICcnO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICAvLyAmXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgLy8gJ1xuICAgICAgICBlc2NhcGUgPSAnJiN4Mjc7JzsgLy8gbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbDsgdXNlZCB0byBiZSAnJiMzOSdcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYwOlxuICAgICAgICAvLyA8XG4gICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICAvLyA+XG4gICAgICAgIGVzY2FwZSA9ICcmZ3Q7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZTtcbiAgfVxuXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cblxuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgVGV4dCB2YWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGV4dCkge1xuICBpZiAodHlwZW9mIHRleHQgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgdGV4dCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyB0aGlzIHNob3J0Y2lyY3VpdCBoZWxwcyBwZXJmIGZvciB0eXBlcyB0aGF0IHdlIGtub3cgd2lsbCBuZXZlciBoYXZlXG4gICAgLy8gc3BlY2lhbCBjaGFyYWN0ZXJzLCBlc3BlY2lhbGx5IGdpdmVuIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIG9mdGVuXG4gICAgLy8gZm9yIG51bWVyaWMgZG9tIGlkcy5cbiAgICByZXR1cm4gJycgKyB0ZXh0O1xuICB9XG4gIHJldHVybiBlc2NhcGVIdG1sKHRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cCA9IHJlcXVpcmUoJ2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCcpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBEYW5nZXIgPSB7XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgbm9kZSB3aXRoIGEgc3RyaW5nIG9mIG1hcmt1cCBhdCBpdHMgY3VycmVudCBwb3NpdGlvbiB3aXRoaW4gaXRzXG4gICAqIHBhcmVudC4gVGhlIG1hcmt1cCBtdXN0IHJlbmRlciBpbnRvIGEgc2luZ2xlIHJvb3Qgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBvbGRDaGlsZCBDaGlsZCBub2RlIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHJlbmRlciBpbiBwbGFjZSBvZiB0aGUgY2hpbGQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXApIHtcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgd29ya2VyIHRocmVhZC4gTWFrZSBzdXJlIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgIGFyZSBhdmFpbGFibGUgZ2xvYmFsbHkgYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IF9wcm9kSW52YXJpYW50KCc1NicpIDogdm9pZCAwO1xuICAgICFtYXJrdXAgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJykgOiBfcHJvZEludmFyaWFudCgnNTcnKSA6IHZvaWQgMDtcbiAgICAhKG9sZENoaWxkLm5vZGVOYW1lICE9PSAnSFRNTCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZXBsYWNlIG1hcmt1cCBvZiB0aGUgPGh0bWw+IG5vZGUuIFRoaXMgaXMgYmVjYXVzZSBicm93c2VyIHF1aXJrcyBtYWtlIHRoaXMgdW5yZWxpYWJsZSBhbmQvb3Igc2xvdy4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIHRvIHRoZSByb290IHlvdSBtdXN0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKS4nKSA6IF9wcm9kSW52YXJpYW50KCc1OCcpIDogdm9pZCAwO1xuXG4gICAgaWYgKHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBlbXB0eUZ1bmN0aW9uKVswXTtcbiAgICAgIG9sZENoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIERPTUxhenlUcmVlLnJlcGxhY2VDaGlsZFdpdGhUcmVlKG9sZENoaWxkLCBtYXJrdXApO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhbmdlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvRGFuZ2VyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIGZiLXd3dy91bnNhZmUtaHRtbCovXG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnLi9jcmVhdGVBcnJheUZyb21NaXhlZCcpO1xudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKCcuL2dldE1hcmt1cFdyYXAnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIHJlbmRlciBhbGwgbWFya3VwLlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFBhdHRlcm4gdXNlZCBieSBgZ2V0Tm9kZU5hbWVgLlxuICovXG52YXIgbm9kZU5hbWVQYXR0ZXJuID0gL15cXHMqPChcXHcrKS87XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGBub2RlTmFtZWAgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBzdHJpbmcgb2YgbWFya3VwLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IE5vZGUgbmFtZSBvZiB0aGUgc3VwcGxpZWQgbWFya3VwLlxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgdmFyIG5vZGVOYW1lTWF0Y2ggPSBtYXJrdXAubWF0Y2gobm9kZU5hbWVQYXR0ZXJuKTtcbiAgcmV0dXJuIG5vZGVOYW1lTWF0Y2ggJiYgbm9kZU5hbWVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbm9kZXMgcmVuZGVyZWQgZnJvbSB0aGUgc3VwcGxpZWQgbWFya3VwLiBUaGVcbiAqIG9wdGlvbmFsbHkgc3VwcGxpZWQgYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIG9uY2UgZm9yIGVhY2hcbiAqIDxzY3JpcHQ+IGVsZW1lbnQgdGhhdCBpcyByZW5kZXJlZC4gSWYgbm8gYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gaXMgc3VwcGxpZWQsXG4gKiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIGFueSA8c2NyaXB0PiBlbGVtZW50cyBhcmUgcmVuZGVyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBBIHN0cmluZyBvZiB2YWxpZCBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBoYW5kbGVTY3JpcHQgSW52b2tlZCBvbmNlIGZvciBlYWNoIHJlbmRlcmVkIDxzY3JpcHQ+LlxuICogQHJldHVybiB7YXJyYXk8RE9NRWxlbWVudHxET01UZXh0Tm9kZT59IEFuIGFycmF5IG9mIHJlbmRlcmVkIG5vZGVzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBoYW5kbGVTY3JpcHQpIHtcbiAgdmFyIG5vZGUgPSBkdW1teU5vZGU7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgZHVtbXkgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgbm9kZU5hbWUgPSBnZXROb2RlTmFtZShtYXJrdXApO1xuXG4gIHZhciB3cmFwID0gbm9kZU5hbWUgJiYgZ2V0TWFya3VwV3JhcChub2RlTmFtZSk7XG4gIGlmICh3cmFwKSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSB3cmFwWzFdICsgbWFya3VwICsgd3JhcFsyXTtcblxuICAgIHZhciB3cmFwRGVwdGggPSB3cmFwWzBdO1xuICAgIHdoaWxlICh3cmFwRGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgfVxuXG4gIHZhciBzY3JpcHRzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gIGlmIChzY3JpcHRzLmxlbmd0aCkge1xuICAgICFoYW5kbGVTY3JpcHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwKC4uLik6IFVuZXhwZWN0ZWQgPHNjcmlwdD4gZWxlbWVudCByZW5kZXJlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY3JlYXRlQXJyYXlGcm9tTWl4ZWQoc2NyaXB0cykuZm9yRWFjaChoYW5kbGVTY3JpcHQpO1xuICB9XG5cbiAgdmFyIG5vZGVzID0gQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpO1xuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byBhcnJheXMuXG4gKlxuICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgY2FsbGVyIGtub3dzIHRoZSBjb250ZW50cyBvZiB0aGUgZGF0YSB0eXBlLiBGb3IgbGVzc1xuICogd2VsbCBkZWZpbmVkIGlucHV0cyB1c2UgY3JlYXRlQXJyYXlGcm9tTWl4ZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258ZmlsZWxpc3R9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoO1xuXG4gIC8vIFNvbWUgYnJvd3NlcnMgYnVpbHRpbiBvYmplY3RzIGNhbiByZXBvcnQgdHlwZW9mICdmdW5jdGlvbicgKGUuZy4gTm9kZUxpc3RcbiAgLy8gaW4gb2xkIHZlcnNpb25zIG9mIFNhZmFyaSkuXG4gICEoIUFycmF5LmlzQXJyYXkob2JqKSAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IEFycmF5LWxpa2Ugb2JqZWN0IGV4cGVjdGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBuZWVkcyBhIGxlbmd0aCBwcm9wZXJ0eScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggLSAxIGluIG9iaikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IHNob3VsZCBoYXZlIGtleXMgZm9yIGluZGljZXMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgISh0eXBlb2Ygb2JqLmNhbGxlZSAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IGNhblxcJ3QgYmUgYGFyZ3VtZW50c2AuIFVzZSByZXN0IHBhcmFtcyAnICsgJyhmdW5jdGlvbiguLi5hcmdzKSB7fSkgb3IgQXJyYXkuZnJvbSgpIGluc3RlYWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIC8vIE9sZCBJRSBkb2Vzbid0IGdpdmUgY29sbGVjdGlvbnMgYWNjZXNzIHRvIGhhc093blByb3BlcnR5LiBBc3N1bWUgaW5wdXRzXG4gIC8vIHdpdGhvdXQgbWV0aG9kIHdpbGwgdGhyb3cgZHVyaW5nIHRoZSBzbGljZSBjYWxsIGFuZCBza2lwIHN0cmFpZ2h0IHRvIHRoZVxuICAvLyBmYWxsYmFjay5cbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRSA8IDkgZG9lcyBub3Qgc3VwcG9ydCBBcnJheSNzbGljZSBvbiBjb2xsZWN0aW9ucyBvYmplY3RzXG4gICAgfVxuICB9XG5cbiAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcga2V5IGJ5IGtleS4gVGhpcyBhc3N1bWVzIGFsbCBrZXlzIGhhdmUgYSB2YWx1ZSxcbiAgLy8gc28gd2lsbCBub3QgcHJlc2VydmUgc3BhcnNlbHkgcG9wdWxhdGVkIGlucHV0cy5cbiAgdmFyIHJldCA9IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcbiAgICByZXRbaWldID0gb2JqW2lpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFBlcmZvcm0gYSBoZXVyaXN0aWMgdGVzdCB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIFwiYXJyYXktbGlrZVwiLlxuICpcbiAqICAgQSBtb25rIGFza2VkIEpvc2h1LCBhIFplbiBtYXN0ZXIsIFwiSGFzIGEgZG9nIEJ1ZGRoYSBuYXR1cmU/XCJcbiAqICAgSm9zaHUgcmVwbGllZDogXCJNdS5cIlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBpdHMgYXJndW1lbnQgaGFzIFwiYXJyYXkgbmF0dXJlXCI6IGl0IHJldHVybnNcbiAqIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFjdHVhbCBhcnJheSwgYW4gYGFyZ3VtZW50cycgb2JqZWN0LCBvciBhblxuICogSFRNTENvbGxlY3Rpb24gKGUuZy4gbm9kZS5jaGlsZE5vZGVzIG9yIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSkuXG4gKlxuICogSXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIG90aGVyIGFycmF5LWxpa2Ugb2JqZWN0cyBsaWtlIEZpbGVsaXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNBcnJheU5hdHVyZShvYmopIHtcbiAgcmV0dXJuIChcbiAgICAvLyBub3QgbnVsbC9mYWxzZVxuICAgICEhb2JqICYmIChcbiAgICAvLyBhcnJheXMgYXJlIG9iamVjdHMsIE5vZGVMaXN0cyBhcmUgZnVuY3Rpb25zIGluIFNhZmFyaVxuICAgIHR5cGVvZiBvYmogPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nKSAmJlxuICAgIC8vIHF1YWNrcyBsaWtlIGFuIGFycmF5XG4gICAgJ2xlbmd0aCcgaW4gb2JqICYmXG4gICAgLy8gbm90IHdpbmRvd1xuICAgICEoJ3NldEludGVydmFsJyBpbiBvYmopICYmXG4gICAgLy8gbm8gRE9NIG5vZGUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYW4gYXJyYXktbGlrZVxuICAgIC8vIGEgJ3NlbGVjdCcgZWxlbWVudCBoYXMgJ2xlbmd0aCcgYW5kICdpdGVtJyBwcm9wZXJ0aWVzIG9uIElFOFxuICAgIHR5cGVvZiBvYmoubm9kZVR5cGUgIT0gJ251bWJlcicgJiYgKFxuICAgIC8vIGEgcmVhbCBhcnJheVxuICAgIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgIC8vIGFyZ3VtZW50c1xuICAgICdjYWxsZWUnIGluIG9iaiB8fFxuICAgIC8vIEhUTUxDb2xsZWN0aW9uL05vZGVMaXN0XG4gICAgJ2l0ZW0nIGluIG9iailcbiAgKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkgYnkgd3JhcHBpbmcgaXQgaW4gYW4gYXJyYXkgaWYgaXQgaXMgbm90LlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50IGlmIGl0IGlzIGFscmVhZHkgYW4gYXJyYXkuXG4gKlxuICogVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGlkaW9tYXRpY2FsbHk6XG4gKlxuICogICB2YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCdjcmVhdGVBcnJheUZyb21NaXhlZCcpO1xuICpcbiAqICAgZnVuY3Rpb24gdGFrZXNPbmVPck1vcmVUaGluZ3ModGhpbmdzKSB7XG4gKiAgICAgdGhpbmdzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQodGhpbmdzKTtcbiAqICAgICAuLi5cbiAqICAgfVxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmVhdCBgdGhpbmdzJyBhcyBhbiBhcnJheSwgYnV0IGFjY2VwdCBzY2FsYXJzIGluIHRoZSBBUEkuXG4gKlxuICogSWYgeW91IG5lZWQgdG8gY29udmVydCBhbiBhcnJheS1saWtlIG9iamVjdCwgbGlrZSBgYXJndW1lbnRzYCwgaW50byBhbiBhcnJheVxuICogdXNlIHRvQXJyYXkgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1peGVkKG9iaikge1xuICBpZiAoIWhhc0FycmF5TmF0dXJlKG9iaikpIHtcbiAgICByZXR1cm4gW29ial07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0FycmF5KG9iaik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBcnJheUZyb21NaXhlZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sICovXG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogU29tZSBicm93c2VycyBjYW5ub3QgdXNlIGBpbm5lckhUTUxgIHRvIHJlbmRlciBjZXJ0YWluIGVsZW1lbnRzIHN0YW5kYWxvbmUsXG4gKiBzbyB3ZSB3cmFwIHRoZW0sIHJlbmRlciB0aGUgd3JhcHBlZCBub2RlcywgdGhlbiBleHRyYWN0IHRoZSBkZXNpcmVkIG5vZGUuXG4gKlxuICogSW4gSUU4LCBjZXJ0YWluIGVsZW1lbnRzIGNhbm5vdCByZW5kZXIgYWxvbmUsIHNvIHdyYXAgYWxsIGVsZW1lbnRzICgnKicpLlxuICovXG5cbnZhciBzaG91bGRXcmFwID0ge307XG5cbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcbnZhciB0YWJsZVdyYXAgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcbnZhciB0cldyYXAgPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxudmFyIHN2Z1dyYXAgPSBbMSwgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPicsICc8L3N2Zz4nXTtcblxudmFyIG1hcmt1cFdyYXAgPSB7XG4gICcqJzogWzEsICc/PGRpdj4nLCAnPC9kaXY+J10sXG5cbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAnY29sJzogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gICdsZWdlbmQnOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcbiAgJ3RyJzogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG5cbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcbiAgJ29wdGlvbic6IHNlbGVjdFdyYXAsXG5cbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXG4gICdjb2xncm91cCc6IHRhYmxlV3JhcCxcbiAgJ3Rib2R5JzogdGFibGVXcmFwLFxuICAndGZvb3QnOiB0YWJsZVdyYXAsXG4gICd0aGVhZCc6IHRhYmxlV3JhcCxcblxuICAndGQnOiB0cldyYXAsXG4gICd0aCc6IHRyV3JhcFxufTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgU1ZHIGVsZW1lbnRzIHNpbmNlIHdlIGtub3cgdGhleSdsbCBhbHdheXMgbmVlZCB0byBiZSB3cmFwcGVkXG4vLyBjb25zaXN0ZW50bHkuIElmIHRoZXkgYXJlIGNyZWF0ZWQgaW5zaWRlIGEgPGRpdj4gdGhleSB3aWxsIGJlIGluaXRpYWxpemVkIGluXG4vLyB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXG52YXIgc3ZnRWxlbWVudHMgPSBbJ2NpcmNsZScsICdjbGlwUGF0aCcsICdkZWZzJywgJ2VsbGlwc2UnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3RleHQnLCAndHNwYW4nXTtcbnN2Z0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gIG1hcmt1cFdyYXBbbm9kZU5hbWVdID0gc3ZnV3JhcDtcbiAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSB0cnVlO1xufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGBub2RlTmFtZWAuXG4gKlxuICogTk9URTogVGhpcyBsYXppbHkgZGV0ZWN0cyB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5IGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBMb3dlcmNhc2UgYG5vZGVOYW1lYC5cbiAqIEByZXR1cm4gez9hcnJheX0gTWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkge1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWFya3VwIHdyYXBwaW5nIG5vZGUgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBpZiAoIW1hcmt1cFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgbm9kZU5hbWUgPSAnKic7XG4gIH1cbiAgaWYgKCFzaG91bGRXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzxsaW5rIC8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcbiAgICB9XG4gICAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSAhZHVtbXlOb2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFdyYXBbbm9kZU5hbWVdID8gbWFya3VwV3JhcFtub2RlTmFtZV0gOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcmt1cFdyYXA7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9nZXRNYXJrdXBXcmFwLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxuLyoqXG4gKiBPcGVyYXRpb25zIHVzZWQgdG8gcHJvY2VzcyB1cGRhdGVzIHRvIERPTSBub2Rlcy5cbiAqL1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBmdW5jdGlvbiAocGFyZW50SW5zdCwgdXBkYXRlcykge1xuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UocGFyZW50SW5zdCk7XG4gICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnByb2Nlc3NVcGRhdGVzKG5vZGUsIHVwZGF0ZXMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSURPcGVyYXRpb25zO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKiBnbG9iYWwgaGFzT3duUHJvcGVydHk6dHJ1ZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEF1dG9Gb2N1c1V0aWxzID0gcmVxdWlyZSgnLi9BdXRvRm9jdXNVdGlscycpO1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRGbGFncycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01JbnB1dCA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnB1dCcpO1xudmFyIFJlYWN0RE9NT3B0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTU9wdGlvbicpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dGFyZWEnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE11bHRpQ2hpbGQgPSByZXF1aXJlKCcuL1JlYWN0TXVsdGlDaGlsZCcpO1xudmFyIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24nKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgRmxhZ3MgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xudmFyIGRlbGV0ZUxpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZGVsZXRlTGlzdGVuZXI7XG52YXIgZ2V0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlO1xudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcblxuLy8gRm9yIHF1aWNrbHkgbWF0Y2hpbmcgY2hpbGRyZW4gdHlwZSwgdG8gdGVzdCBpZiBjYW4gYmUgdHJlYXRlZCBhcyBjb250ZW50LlxudmFyIENPTlRFTlRfVFlQRVMgPSB7ICdzdHJpbmcnOiB0cnVlLCAnbnVtYmVyJzogdHJ1ZSB9O1xuXG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBudWxsLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IG51bGxcbn07XG5cbi8vIE5vZGUgdHlwZSBmb3IgZG9jdW1lbnQgZnJhZ21lbnRzIChOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpLlxudmFyIERPQ19GUkFHTUVOVF9UWVBFID0gMTE7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgdmFyIG93bmVyID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyIHx8IG51bGw7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIFRoaXMgRE9NIG5vZGUgd2FzIHJlbmRlcmVkIGJ5IGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcbiAgfVxuICAvLyBEaWZmZXJzIGZyb20gSlNPTi5zdHJpbmdpZnkgaW4gdGhhdCB1bmRlZmluZWQgYmVjYXVzZSB1bmRlZmluZWQgYW5kIHRoYXRcbiAgLy8gaW5mIGFuZCBuYW4gZG9uJ3QgYmVjb21lIG51bGxcbiAgcmV0dXJuIFN0cmluZyhvYmopO1xufVxuXG52YXIgc3R5bGVNdXRhdGlvbldhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHN0eWxlMSwgc3R5bGUyLCBjb21wb25lbnQpIHtcbiAgaWYgKHN0eWxlMSA9PSBudWxsIHx8IHN0eWxlMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaGFsbG93RXF1YWwoc3R5bGUxLCBzdHlsZTIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuX3RhZztcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcikge1xuICAgIG93bmVyTmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgfVxuXG4gIHZhciBoYXNoID0gb3duZXJOYW1lICsgJ3wnICsgY29tcG9uZW50TmFtZTtcblxuICBpZiAoc3R5bGVNdXRhdGlvbldhcm5pbmcuaGFzT3duUHJvcGVydHkoaGFzaCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHlsZU11dGF0aW9uV2FybmluZ1toYXNoXSA9IHRydWU7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgJXNgIHdhcyBwYXNzZWQgYSBzdHlsZSBvYmplY3QgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIG11dGF0ZWQuICcgKyAnTXV0YXRpbmcgYHN0eWxlYCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciBjbG9uaW5nIGl0IGJlZm9yZWhhbmQuIENoZWNrICcgKyAndGhlIGByZW5kZXJgICVzLiBQcmV2aW91cyBzdHlsZTogJXMuIE11dGF0ZWQgc3R5bGU6ICVzLicsIGNvbXBvbmVudE5hbWUsIG93bmVyID8gJ29mIGAnICsgb3duZXJOYW1lICsgJ2AnIDogJ3VzaW5nIDwnICsgY29tcG9uZW50TmFtZSArICc+JywgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUxKSwgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUyKSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wc1xuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzEzNycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiBfcHJvZEludmFyaWFudCgnNjAnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzYxJykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLm9uRm9jdXNJbiA9PSBudWxsICYmIHByb3BzLm9uRm9jdXNPdXQgPT0gbnVsbCwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJykgOiB2b2lkIDA7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiB1c2luZyBKU1guJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiBfcHJvZEludmFyaWFudCgnNjInLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElFOCBoYXMgbm8gQVBJIGZvciBldmVudCBjYXB0dXJpbmcgYW5kIHRoZSBgb25TY3JvbGxgIGV2ZW50IGRvZXNuJ3RcbiAgICAvLyBidWJibGUuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocmVnaXN0cmF0aW9uTmFtZSAhPT0gJ29uU2Nyb2xsJyB8fCBpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSwgJ1RoaXMgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCB0aGUgYG9uU2Nyb2xsYCBldmVudCcpIDogdm9pZCAwO1xuICB9XG4gIHZhciBjb250YWluZXJJbmZvID0gaW5zdC5faG9zdENvbnRhaW5lckluZm87XG4gIHZhciBpc0RvY3VtZW50RnJhZ21lbnQgPSBjb250YWluZXJJbmZvLl9ub2RlICYmIGNvbnRhaW5lckluZm8uX25vZGUubm9kZVR5cGUgPT09IERPQ19GUkFHTUVOVF9UWVBFO1xuICB2YXIgZG9jID0gaXNEb2N1bWVudEZyYWdtZW50ID8gY29udGFpbmVySW5mby5fbm9kZSA6IGNvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocHV0TGlzdGVuZXIsIHtcbiAgICBpbnN0OiBpbnN0LFxuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwdXRMaXN0ZW5lcigpIHtcbiAgdmFyIGxpc3RlbmVyVG9QdXQgPSB0aGlzO1xuICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcihsaXN0ZW5lclRvUHV0Lmluc3QsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XG59XG5cbmZ1bmN0aW9uIGlucHV0UG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NSW5wdXQucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxuZnVuY3Rpb24gdGV4dGFyZWFQb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01UZXh0YXJlYS5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG5mdW5jdGlvbiBvcHRpb25Qb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01PcHRpb24ucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxudmFyIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2ID0gZW1wdHlGdW5jdGlvbjtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICB2YXIgaGFzRXhpc3RpbmdDb250ZW50ID0gdGhpcy5fY29udGVudERlYnVnSUQgIT0gbnVsbDtcbiAgICB2YXIgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgLy8gVGhpcyBJRCByZXByZXNlbnRzIHRoZSBpbmxpbmVkIGNoaWxkIHRoYXQgaGFzIG5vIGJhY2tpbmcgaW5zdGFuY2U6XG4gICAgdmFyIGNvbnRlbnREZWJ1Z0lEID0gLWRlYnVnSUQ7XG5cbiAgICBpZiAoY29udGVudCA9PSBudWxsKSB7XG4gICAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQodGhpcy5fY29udGVudERlYnVnSUQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCBTdHJpbmcoY29udGVudCksIHRoaXMsIHRoaXMuX2FuY2VzdG9ySW5mbyk7XG4gICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBjb250ZW50RGVidWdJRDtcbiAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGNvbnRlbnREZWJ1Z0lEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQsIGRlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgW2NvbnRlbnREZWJ1Z0lEXSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudHNMb2NhbCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICAvLyBJZiBhIGNvbXBvbmVudCByZW5kZXJzIHRvIG51bGwgb3IgaWYgYW5vdGhlciBjb21wb25lbnQgZmF0YWxzIGFuZCBjYXVzZXNcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSB0cmVlIHRvIGJlIGNvcnJ1cHRlZCwgYG5vZGVgIGhlcmUgY2FuIGJlIG51bGwuXG4gICFpbnN0Ll9yb290Tm9kZUlEID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgbW91bnRlZCB0byB0cmFwIGV2ZW50cycpIDogX3Byb2RJbnZhcmlhbnQoJzYzJykgOiB2b2lkIDA7XG4gIHZhciBub2RlID0gZ2V0Tm9kZShpbnN0KTtcbiAgIW5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhcEJ1YmJsZWRFdmVudCguLi4pOiBSZXF1aXJlcyBub2RlIHRvIGJlIHJlbmRlcmVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzY0JykgOiB2b2lkIDA7XG5cbiAgc3dpdGNoIChpbnN0Ll90YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzLnB1c2goUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoZXZlbnQsIG1lZGlhRXZlbnRzW2V2ZW50XSwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0VXBkYXRlU2VsZWN0V3JhcHBlcigpIHtcbiAgUmVhY3RET01TZWxlY3QucG9zdFVwZGF0ZVdyYXBwZXIodGhpcyk7XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgd2hpdGVsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICAnYXJlYSc6IHRydWUsXG4gICdiYXNlJzogdHJ1ZSxcbiAgJ2JyJzogdHJ1ZSxcbiAgJ2NvbCc6IHRydWUsXG4gICdlbWJlZCc6IHRydWUsXG4gICdocic6IHRydWUsXG4gICdpbWcnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5Z2VuJzogdHJ1ZSxcbiAgJ2xpbmsnOiB0cnVlLFxuICAnbWV0YSc6IHRydWUsXG4gICdwYXJhbSc6IHRydWUsXG4gICdzb3VyY2UnOiB0cnVlLFxuICAndHJhY2snOiB0cnVlLFxuICAnd2JyJzogdHJ1ZVxufTtcblxudmFyIG5ld2xpbmVFYXRpbmdUYWdzID0ge1xuICAnbGlzdGluZyc6IHRydWUsXG4gICdwcmUnOiB0cnVlLFxuICAndGV4dGFyZWEnOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgJ21lbnVpdGVtJzogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbi8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZFRhZ0NhY2hlLCB0YWcpKSB7XG4gICAgIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0YWc6ICVzJywgdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NScsIHRhZykgOiB2b2lkIDA7XG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHRhZ05hbWUuaW5kZXhPZignLScpID49IDAgfHwgcHJvcHMuaXMgIT0gbnVsbDtcbn1cblxudmFyIGdsb2JhbElkQ291bnRlciA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZWFjdCBjbGFzcyB0aGF0IGlzIGlkZW1wb3RlbnQgYW5kIGNhcGFibGUgb2YgY29udGFpbmluZyBvdGhlclxuICogUmVhY3QgY29tcG9uZW50cy4gSXQgYWNjZXB0cyBldmVudCBsaXN0ZW5lcnMgYW5kIERPTSBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiB2YWxpZCBhY2NvcmRpbmcgdG8gYERPTVByb3BlcnR5YC5cbiAqXG4gKiAgLSBFdmVudCBsaXN0ZW5lcnM6IGBvbkNsaWNrYCwgYG9uTW91c2VEb3duYCwgZXRjLlxuICogIC0gRE9NIHByb3BlcnRpZXM6IGBjbGFzc05hbWVgLCBgbmFtZWAsIGB0aXRsZWAsIGV0Yy5cbiAqXG4gKiBUaGUgYHN0eWxlYCBwcm9wZXJ0eSBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZnJvbSB0aGUgRE9NIEFQSS4gSXQgYWNjZXB0cyBhblxuICogb2JqZWN0IG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yIFJlYWN0RE9NQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuZnVuY3Rpb24gUmVhY3RET01Db21wb25lbnQoZWxlbWVudCkge1xuICB2YXIgdGFnID0gZWxlbWVudC50eXBlO1xuICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX3RhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gIHRoaXMuX2RvbUlEID0gMDtcbiAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuICB0aGlzLl9mbGFncyA9IDA7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdGhpcy5fYW5jZXN0b3JJbmZvID0gbnVsbDtcbiAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xuICB9XG59XG5cblJlYWN0RE9NQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ1JlYWN0RE9NQ29tcG9uZW50JztcblxuUmVhY3RET01Db21wb25lbnQuTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByb290IHRhZyBtYXJrdXAgdGhlbiByZWN1cnNlcy4gVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBhbmRcbiAgICogaXMgbm90IGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/UmVhY3RET01Db21wb25lbnR9IHRoZSBwYXJlbnQgY29tcG9uZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaW5mbyBhYm91dCB0aGUgaG9zdCBjb250YWluZXJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29tcHV0ZWQgbWFya3VwLlxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gZ2xvYmFsSWRDb3VudGVyKys7XG4gICAgdGhpcy5fZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICBjYXNlICdsaW5rJzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgICAgICAgbGlzdGVuZXJzOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIFJlYWN0RE9NT3B0aW9uLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBSZWFjdERPTVNlbGVjdC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIHByb3BzKTtcblxuICAgIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgICAvLyB0YWdzIGdldCBubyBuYW1lc3BhY2UuXG4gICAgdmFyIG5hbWVzcGFjZVVSSTtcbiAgICB2YXIgcGFyZW50VGFnO1xuICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGhvc3RQYXJlbnQuX25hbWVzcGFjZVVSSTtcbiAgICAgIHBhcmVudFRhZyA9IGhvc3RQYXJlbnQuX3RhZztcbiAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGhvc3RDb250YWluZXJJbmZvLl9uYW1lc3BhY2VVUkk7XG4gICAgICBwYXJlbnRUYWcgPSBob3N0Q29udGFpbmVySW5mby5fdGFnO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09IG51bGwgfHwgbmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLnN2ZyAmJiBwYXJlbnRUYWcgPT09ICdmb3JlaWdub2JqZWN0Jykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5odG1sO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgIGlmICh0aGlzLl90YWcgPT09ICdzdmcnKSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMuc3ZnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl90YWcgPT09ICdtYXRoJykge1xuICAgICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLm1hdGhtbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbmFtZXNwYWNlVVJJO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xuICAgICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mby5fdGFnKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudEluZm8pIHtcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKHRoaXMuX3RhZywgbnVsbCwgdGhpcywgcGFyZW50SW5mbyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hbmNlc3RvckluZm8gPSB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRJbmZvLCB0aGlzLl90YWcsIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBtb3VudEltYWdlO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIGVsO1xuICAgICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICAgIGlmICh0aGlzLl90YWcgPT09ICdzY3JpcHQnKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuICAgICAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSAnPCcgKyB0eXBlICsgJz48LycgKyB0eXBlICsgJz4nO1xuICAgICAgICAgIGVsID0gZGl2LnJlbW92ZUNoaWxkKGRpdi5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5pcykge1xuICAgICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUsIHByb3BzLmlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY3Vhc2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC82ODk2XG4gICAgICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICB9XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIGVsKTtcbiAgICAgIHRoaXMuX2ZsYWdzIHw9IEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXM7XG4gICAgICBpZiAoIXRoaXMuX2hvc3RQYXJlbnQpIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldEF0dHJpYnV0ZUZvclJvb3QoZWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhudWxsLCBwcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgICAgdmFyIGxhenlUcmVlID0gRE9NTGF6eVRyZWUoZWwpO1xuICAgICAgdGhpcy5fY3JlYXRlSW5pdGlhbENoaWxkcmVuKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgbGF6eVRyZWUpO1xuICAgICAgbW91bnRJbWFnZSA9IGxhenlUcmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFnT3BlbiA9IHRoaXMuX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnModHJhbnNhY3Rpb24sIHByb3BzKTtcbiAgICAgIHZhciB0YWdDb250ZW50ID0gdGhpcy5fY3JlYXRlQ29udGVudE1hcmt1cCh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgaWYgKCF0YWdDb250ZW50ICYmIG9taXR0ZWRDbG9zZVRhZ3NbdGhpcy5fdGFnXSkge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICcvPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICc+JyArIHRhZ0NvbnRlbnQgKyAnPC8nICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSArICc+JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGlucHV0UG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRleHRhcmVhUG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShvcHRpb25Qb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRJbWFnZTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBvcGVuIHRhZyBhbmQgYWxsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYmVjYXVzZSBldmVudHMgZ2V0IHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEl0ZXJhdGluZyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGlzIGZhc3RlciB0aGFuIGl0ZXJhdGluZyBvdmVyIGFycmF5cy5cbiAgICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9vYmotdnMtYXJyLWl0ZXJhdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIG9mIG9wZW5pbmcgdGFnLlxuICAgKi9cbiAgX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnM6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMpIHtcbiAgICB2YXIgcmV0ID0gJzwnICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBwcm9wVmFsdWUsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gU2VlIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIHN0eWxlIGJsb2NrXG4gICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wVmFsdWUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrdXAgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdGFnICE9IG51bGwgJiYgaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBwcm9wcykpIHtcbiAgICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlKHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgICByZXQgKz0gJyAnICsgbWFya3VwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIHN0YXRpYyBwYWdlcywgbm8gbmVlZCB0byBwdXQgUmVhY3QgSUQgYW5kIGNoZWNrc3VtLiBTYXZlcyBsb3RzIG9mXG4gICAgLy8gYnl0ZXMuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xuICAgICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JSb290KCk7XG4gICAgfVxuICAgIHJldCArPSAnICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQodGhpcy5fZG9tSUQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSB0YWdzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udGVudCBtYXJrdXAuXG4gICAqL1xuICBfY3JlYXRlQ29udGVudE1hcmt1cDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciByZXQgPSAnJztcblxuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgcmV0ID0gaW5uZXJIVE1MLl9faHRtbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgcmV0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYuY2FsbCh0aGlzLCBjb250ZW50VG9Vc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICByZXQgPSBtb3VudEltYWdlcy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld2xpbmVFYXRpbmdUYWdzW3RoaXMuX3RhZ10gJiYgcmV0LmNoYXJBdCgwKSA9PT0gJ1xcbicpIHtcbiAgICAgIC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAgICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXG4gICAgICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgICAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xuICAgICAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gICAgICByZXR1cm4gJ1xcbicgKyByZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LFxuXG4gIF9jcmVhdGVJbml0aWFsQ2hpbGRyZW46IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGxhenlUcmVlKSB7XG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUhUTUwobGF6eVRyZWUsIGlubmVySFRNTC5fX2h0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyB0ZXh0Q29udGVudCB3aGVuIHRoZSB0ZXh0IGlzIGVtcHR5LiBJbiBJRTExIHNldHRpbmdcbiAgICAgICAgLy8gdGV4dENvbnRlbnQgb24gYSB0ZXh0IGFyZWEgd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSB0ZXh0YXJlYSB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY3MzEjaXNzdWVjb21tZW50LTI1NDg3NDU1M1xuICAgICAgICBpZiAoY29udGVudFRvVXNlICE9PSAnJykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIGNvbnRlbnRUb1VzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIERPTUxhenlUcmVlLnF1ZXVlVGV4dChsYXp5VHJlZSwgY29udGVudFRvVXNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3VudEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIG1vdW50SW1hZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZWl2ZXMgYSBuZXh0IGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIGNvbXBvbmVudCBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGFsbG9jYXRlZCBhbmRcbiAgICogYXR0YWNoZWQgdG8gdGhlIERPTS4gUmVjb25jaWxlcyB0aGUgcm9vdCBET00gbm9kZSwgdGhlbiByZWN1cnNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldkVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdFByb3BzID0gcHJldkVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLl91cGRhdGVET01DaGlsZHJlbihsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbiAgICAgICAgLy8gaGFwcGVuIGFmdGVyIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuICAgICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgcHJvcGVydGllcyBieSBkZXRlY3RpbmcgZGlmZmVyZW5jZXMgaW4gcHJvcGVydHkgdmFsdWVzIGFuZFxuICAgKiB1cGRhdGluZyB0aGUgRE9NIGFzIG5lY2Vzc2FyeS4gVGhpcyBmdW5jdGlvbiBpcyBwcm9iYWJseSB0aGUgc2luZ2xlIG1vc3RcbiAgICogY3JpdGljYWwgcGF0aCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgKlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgd2hldGhlciBjaGVja2luZyBmb3IgY2hhbmdlZCB2YWx1ZXMgaW4gbWVtb3J5IGFjdHVhbGx5XG4gICAqICAgICAgIGltcHJvdmVzIHBlcmZvcm1hbmNlIChlc3BlY2lhbGx5IHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50cykuXG4gICAqIFRPRE86IEJlbmNobWFyayB0aGUgZWZmZWN0cyBvZiBwdXR0aW5nIHRoaXMgYXQgdGhlIHRvcCBzaW5jZSA5OSUgb2YgcHJvcHNcbiAgICogICAgICAgZG8gbm90IGNoYW5nZSBmb3IgYSBnaXZlbiByZWNvbmNpbGlhdGlvbi5cbiAgICogVE9ETzogQmVuY2htYXJrIGFyZWFzIHRoYXQgY2FuIGJlIGltcHJvdmVkIHdpdGggY2FjaGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIF91cGRhdGVET01Qcm9wZXJ0aWVzOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uKSB7XG4gICAgdmFyIHByb3BLZXk7XG4gICAgdmFyIHN0eWxlTmFtZTtcbiAgICB2YXIgc3R5bGVVcGRhdGVzO1xuICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICB2YXIgbGFzdFN0eWxlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHk7XG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobGFzdFByb3BzW3Byb3BLZXldKSB7XG4gICAgICAgICAgLy8gT25seSBjYWxsIGRlbGV0ZUxpc3RlbmVyIGlmIHRoZXJlIHdhcyBhIGxpc3RlbmVyIHByZXZpb3VzbHkgb3JcbiAgICAgICAgICAvLyBlbHNlIHdpbGxEZWxldGVMaXN0ZW5lciBnZXRzIGNhbGxlZCB3aGVuIHRoZXJlIHdhc24ndCBhY3R1YWxseSBhXG4gICAgICAgICAgLy8gbGlzdGVuZXIgKGUuZy4sIG9uQ2xpY2s9e251bGx9KVxuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgbGFzdFByb3BzKSkge1xuICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGdldE5vZGUodGhpcyksIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICAgIHZhciBsYXN0UHJvcCA9IHByb3BLZXkgPT09IFNUWUxFID8gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgOiBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCB8fCBuZXh0UHJvcCA9PSBudWxsICYmIGxhc3RQcm9wID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSh0aGlzLl9wcmV2aW91c1N0eWxlQ29weSwgdGhpcy5fcHJldmlvdXNTdHlsZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbmV4dFByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRQcm9wID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBfYXNzaWduKHt9LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcywgcHJvcEtleSwgbmV4dFByb3AsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgbmV4dFByb3BzKSkge1xuICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKGdldE5vZGUodGhpcyksIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIHZhciBub2RlID0gZ2V0Tm9kZSh0aGlzKTtcbiAgICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgICAgQ1NTUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yU3R5bGVzKGdldE5vZGUodGhpcyksIHN0eWxlVXBkYXRlcywgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlXG4gICAqIGNoaWxkcmVuIGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBfdXBkYXRlRE9NQ2hpbGRyZW46IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBsYXN0UHJvcHMuY2hpbGRyZW5dID8gbGFzdFByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICB2YXIgbmV4dENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBuZXh0UHJvcHMuY2hpbGRyZW5dID8gbmV4dFByb3BzLmNoaWxkcmVuIDogbnVsbDtcblxuICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuXG4gICAgLy8gTm90ZSB0aGUgdXNlIG9mIGAhPWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICB2YXIgbGFzdENoaWxkcmVuID0gbGFzdENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBsYXN0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDb250ZW50ICE9IG51bGwgPyBudWxsIDogbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gY2hpbGRyZW4gdG8gY29udGVudC9odG1sIG9yIHZpY2UgdmVyc2EsIHJlbW92ZVxuICAgIC8vIHRoZSBvbGQgY29udGVudFxuICAgIHZhciBsYXN0SGFzQ29udGVudE9ySHRtbCA9IGxhc3RDb250ZW50ICE9IG51bGwgfHwgbGFzdEh0bWwgIT0gbnVsbDtcbiAgICB2YXIgbmV4dEhhc0NvbnRlbnRPckh0bWwgPSBuZXh0Q29udGVudCAhPSBudWxsIHx8IG5leHRIdG1sICE9IG51bGw7XG4gICAgaWYgKGxhc3RDaGlsZHJlbiAhPSBudWxsICYmIG5leHRDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG51bGwsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGxhc3RIYXNDb250ZW50T3JIdG1sICYmICFuZXh0SGFzQ29udGVudE9ySHRtbCkge1xuICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbih0aGlzLl9kZWJ1Z0lELCBbXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5leHRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0Q29udGVudCAhPT0gbmV4dENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyArIG5leHRDb250ZW50KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG5leHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1hcmt1cCgnJyArIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICBjYXNlICdsaW5rJzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fd3JhcHBlclN0YXRlLmxpc3RlbmVycztcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgaW1wb3NzaWJsZSB0byB1bm1vdW50IHNvbWUgdG9wLWxldmVsIGNvbXBvbmVudHMgKGVnIDxodG1sPiwgPGhlYWQ+LCBhbmQgPGJvZHk+KSByZWxpYWJseSBhbmQgZWZmaWNpZW50bHkuIFRvIGZpeCB0aGlzLCBoYXZlIGEgc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgZWxlbWVudHMuJywgdGhpcy5fdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NicsIHRoaXMuX3RhZykgOiB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMudW5tb3VudENoaWxkcmVuKHNhZmVseSk7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICAgIEV2ZW50UGx1Z2luSHViLmRlbGV0ZUFsbExpc3RlbmVycyh0aGlzKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9kb21JRCA9IDA7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xuICAgIH1cbiAgfSxcblxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xuICB9XG5cbn07XG5cbl9hc3NpZ24oUmVhY3RET01Db21wb25lbnQucHJvdG90eXBlLCBSZWFjdERPTUNvbXBvbmVudC5NaXhpbiwgUmVhY3RNdWx0aUNoaWxkLk1peGluKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSB7XG4gIGZvY3VzRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZm9jdXNOb2RlKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvRm9jdXNVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvQXV0b0ZvY3VzVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZSgnLi9kYW5nZXJvdXNTdHlsZVZhbHVlJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKCdmYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICByZXR1cm4gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG59KTtcblxudmFyIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gZmFsc2U7XG52YXIgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ2Nzc0Zsb2F0JztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIHRlbXBTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICB0cnkge1xuICAgIC8vIElFOCB0aHJvd3MgXCJJbnZhbGlkIGFyZ3VtZW50LlwiIGlmIHJlc2V0dGluZyBzaG9ydGhhbmQgc3R5bGUgcHJvcGVydGllcy5cbiAgICB0ZW1wU3R5bGUuZm9udCA9ICcnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSB0cnVlO1xuICB9XG4gIC8vIElFOCBvbmx5IHN1cHBvcnRzIGFjY2Vzc2luZyBjc3NGbG9hdCAoc3RhbmRhcmQpIGFzIHN0eWxlRmxvYXRcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jc3NGbG9hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ3N0eWxlRmxvYXQnO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1N0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuXFwndCBjb250YWluIGEgc2VtaWNvbG9uLiVzICcgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgY2hlY2tSZW5kZXJNZXNzYWdlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG4gIHZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgY29tcG9uZW50KSB7XG4gICAgdmFyIG93bmVyO1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgfVxuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUsIG93bmVyKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlLCBvd25lcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBvd25lcik7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyBmb3IgdXNlIGFzIGlubGluZSBzdHlsZXM6XG4gICAqXG4gICAqICAgPiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoe3dpZHRoOiAnMjAwcHgnLCBoZWlnaHQ6IDB9KVxuICAgKiAgIFwid2lkdGg6MjAwcHg7aGVpZ2h0OjA7XCJcbiAgICpcbiAgICogVW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZCBzbyB0aGF0IGRlY2xhcmF0aXZlIHByb2dyYW1taW5nIGlzIGVhc2llci5cbiAgICogVGhlIHJlc3VsdCBzaG91bGQgYmUgSFRNTC1lc2NhcGVkIGJlZm9yZSBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yU3R5bGVzOiBmdW5jdGlvbiAoc3R5bGVzLCBjb21wb25lbnQpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXJpYWxpemVkICs9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgY29tcG9uZW50KSArICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICAgKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuICBzZXRWYWx1ZUZvclN0eWxlczogZnVuY3Rpb24gKG5vZGUsIHN0eWxlcywgY29tcG9uZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBjb21wb25lbnQuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICd1cGRhdGUgc3R5bGVzJyxcbiAgICAgICAgcGF5bG9hZDogc3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnIHx8IHN0eWxlTmFtZSA9PT0gJ2Nzc0Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcbiAqIElFOCBicmVha3Mgb24sIHdoaWNoIGFyZSBsaXN0ZWQgaGVyZSwgd2UgaW5zdGVhZCB1bnNldCBlYWNoIG9mIHRoZVxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXG4gKiBiZWhhdmUgd2l0aG91dCBhbnkgcHJvYmxlbXMuIEN1cmlvdXNseSwgbGlzdC1zdHlsZSB3b3JrcyB0b28gd2l0aG91dCBhbnlcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXG4gKi9cbnZhciBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMgPSB7XG4gIGJhY2tncm91bmQ6IHtcbiAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXG4gICAgYmFja2dyb3VuZEltYWdlOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiB0cnVlXG4gIH0sXG4gIGJhY2tncm91bmRQb3NpdGlvbjoge1xuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZVxuICB9LFxuICBib3JkZXI6IHtcbiAgICBib3JkZXJXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJCb3R0b206IHtcbiAgICBib3JkZXJCb3R0b21XaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21TdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21Db2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJMZWZ0OiB7XG4gICAgYm9yZGVyTGVmdFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckxlZnRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyUmlnaHQ6IHtcbiAgICBib3JkZXJSaWdodFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICBib3JkZXJUb3BXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJUb3BTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJUb3BDb2xvcjogdHJ1ZVxuICB9LFxuICBmb250OiB7XG4gICAgZm9udFN0eWxlOiB0cnVlLFxuICAgIGZvbnRWYXJpYW50OiB0cnVlLFxuICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgZm9udFNpemU6IHRydWUsXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcbiAgICBmb250RmFtaWx5OiB0cnVlXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICBvdXRsaW5lV2lkdGg6IHRydWUsXG4gICAgb3V0bGluZVN0eWxlOiB0cnVlLFxuICAgIG91dGxpbmVDb2xvcjogdHJ1ZVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHkgPSB7XG4gIGlzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9DU1NQcm9wZXJ0eS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvY2FtZWxpemUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xudmFyIHN0eWxlV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBjb21wb25lbnQpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBpc05vbk51bWVyaWMgPSBpc05hTih2YWx1ZSk7XG4gIGlmIChpc05vbk51bWVyaWMgfHwgdmFsdWUgPT09IDAgfHwgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7IC8vIGNhc3QgdG8gc3RyaW5nXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBBbGxvdyAnMCcgdG8gcGFzcyB0aHJvdWdoIHdpdGhvdXQgd2FybmluZy4gMCBpcyBhbHJlYWR5IHNwZWNpYWwgYW5kXG4gICAgICAvLyBkb2Vzbid0IHJlcXVpcmUgdW5pdHMsIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FybiBhYm91dCBpdC5cbiAgICAgIGlmIChjb21wb25lbnQgJiYgdmFsdWUgIT09ICcwJykge1xuICAgICAgICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gb3duZXIuZ2V0TmFtZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG93bmVyTmFtZSAmJiAhc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdKSB7XG4gICAgICAgICAgc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgdmFyIHdhcm5pbmdzID0gc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdO1xuICAgICAgICAgIHdhcm5lZCA9IHdhcm5pbmdzW25hbWVdO1xuICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdhIGAlc2AgdGFnIChvd25lcjogYCVzYCkgd2FzIHBhc3NlZCBhIG51bWVyaWMgc3RyaW5nIHZhbHVlICcgKyAnZm9yIENTUyBwcm9wZXJ0eSBgJXNgICh2YWx1ZTogYCVzYCkgd2hpY2ggd2lsbCBiZSB0cmVhdGVkICcgKyAnYXMgYSB1bml0bGVzcyBudW1iZXIgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdC4nLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnR5cGUsIG93bmVyTmFtZSB8fCAndW5rbm93bicsIG5hbWUsIHZhbHVlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZW1vaXplcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBzdHJpbmcgYXJndW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSkgOiB2b2lkIDA7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICYmICF2YWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICYmIGlzTmFOKHZhbHVlKSB8fCBwcm9wZXJ0eUluZm8uaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUgJiYgdmFsdWUgPCAxIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcihpZCk7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9ySUQ6IGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FLCBpZCk7XG4gIH0sXG5cbiAgY3JlYXRlTWFya3VwRm9yUm9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FICsgJz1cIlwiJztcbiAgfSxcblxuICBzZXRBdHRyaWJ1dGVGb3JSb290OiBmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUUsICcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz1cIlwiJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICAgIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0VmFsdWVGb3JBdHRyaWJ1dGU6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGF5bG9hZCA9IHt9O1xuICAgICAgcGF5bG9hZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICdyZW1vdmUgYXR0cmlidXRlJyxcbiAgICAgICAgcGF5bG9hZDogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3JlbW92ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xuXG4vKipcbiAqIEVzY2FwZXMgYXR0cmlidXRlIHZhbHVlIHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSkge1xuICByZXR1cm4gJ1wiJyArIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih2YWx1ZSkgKyAnXCInO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4nKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUgPSByZXF1aXJlKCcuL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lJyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGhhc0V2ZW50UGFnZVhZO1xudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxuLy8gbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGQgY2F1c2UgZHVwbGljYXRlXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BBbmltYXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKSB8fCAnYW5pbWF0aW9uZW5kJyxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJykgfHwgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gIHRvcEFuaW1hdGlvblN0YXJ0OiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKSB8fCAnYW5pbWF0aW9uc3RhcnQnLFxuICB0b3BCbHVyOiAnYmx1cicsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXG4gIHRvcENsaWNrOiAnY2xpY2snLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZScsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxuICB0b3BUb3VjaEVuZDogJ3RvdWNoZW5kJyxcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpIHx8ICd0cmFuc2l0aW9uZW5kJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSAnX3JlYWN0TGlzdGVuZXJzSUQnICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XG4gKlxuICogVGhpcyB3b3VsZCBhbGxvY2F0ZSBhIFwicmVnaXN0cmF0aW9uXCIgb2YgYCgnb25DbGljaycsIG15RnVuY3Rpb24pYCBvbiAnbXlJRCcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBfYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BXaGVlbCcpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5XSU5ET1dfSEFORExFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1cycsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1c2luJykpIHtcbiAgICAgICAgICAgIC8vIElFIGhhcyBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIHdoaWNoIGJ1YmJsZS5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1c2luJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEJsdXInLCAnZm9jdXNvdXQnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BCbHVyID0gdHJ1ZTtcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRXZlbnRNYXBwaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcEV2ZW50TWFwcGluZ1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICAvKipcbiAgICogUHJvdGVjdCBhZ2FpbnN0IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkgcmV0dXJuaW5nIG51bGxcbiAgICogU29tZSBwb3B1cCBibG9ja2VyIGV4dGVuc2lvbnMgYXBwZWFyIHRvIGRvIHRoaXM6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjg4N1xuICAgKi9cbiAgc3VwcG9ydHNFdmVudFBhZ2VYWTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICByZXR1cm4gZXYgIT0gbnVsbCAmJiAncGFnZVgnIGluIGV2O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogVmlld3BvcnRNZXRyaWNzIGlzIG9ubHkgdXNlZCBieSBTeW50aGV0aWNNb3VzZS9Ub3VjaEV2ZW50IGFuZCBvbmx5IHdoZW5cbiAgICogcGFnZVgvcGFnZVkgaXNuJ3Qgc3VwcG9ydGVkIChsZWdhY3kgYnJvd3NlcnMpLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzRXZlbnRQYWdlWFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzRXZlbnRQYWdlWFkgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc3VwcG9ydHNFdmVudFBhZ2VYWSgpO1xuICAgIH1cbiAgICBpZiAoIWhhc0V2ZW50UGFnZVhZICYmICFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIubW9uaXRvclNjcm9sbFZhbHVlKHJlZnJlc2gpO1xuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAgICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICovXG4gIGhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzID0gRXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50RW1pdHRlck1peGluO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZChwcm9wcyk7XG5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAgIC8vIGJlZm9yZSAudHlwZSBtZWFucyAudmFsdWUgaXMgbG9zdCBpbiBJRTExIGFuZCBiZWxvdylcbiAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgICAvLyBtZWFucyAudmFsdWUgaXMgcm91bmRlZCBvbiBtb3VudCwgYmFzZWQgdXBvbiBzdGVwIHByZWNpc2lvbilcbiAgICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgICAgLy8gaW4gY29ybmVyIGNhc2VzIHN1Y2ggYXMgbWluIG9yIG1heCBkZXJpdmluZyBmcm9tIHZhbHVlLCBlLmcuIElzc3VlICM3MTcwKVxuICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICBtYXg6IHVuZGVmaW5lZFxuICAgIH0sIHByb3BzLCB7XG4gICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG5cbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWRMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BjaGVja2VkTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICBpbml0aWFsVmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG4gICAgICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIGlmICghaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiAhY29udHJvbGxlZCAmJiAhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFNob3VsZG4ndCB0aGlzIGJlIGdldENoZWNrZWQocHJvcHMpP1xuICAgIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSwgJ2NoZWNrZWQnLCBjaGVja2VkIHx8IGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLnZhbHVlID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbiAgICAgICAgLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuICAgICAgICAvLyBDaHJvbWUgcmFpc2VzIFwiVGhlIHNwZWNpZmllZCB2YWx1ZSA8eD4gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuICAgICAgICAvLyB3aGVuIHRoZSB1c2VyIGlzIGlucHV0dGluZyB0ZXh0XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuICAgICAgICBpZiAobm9kZS5kZWZhdWx0VmFsdWUgIT09ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAgIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG5cbiAgICAvLyBEZXRhY2ggdmFsdWUgZnJvbSBkZWZhdWx0VmFsdWUuIFdlIHdvbid0IGRvIGFueXRoaW5nIGlmIHdlJ3JlIHdvcmtpbmcgb25cbiAgICAvLyBzdWJtaXQgb3IgcmVzZXQgaW5wdXRzIGFzIHRob3NlIHZhbHVlcyAmIGRlZmF1bHRWYWx1ZXMgYXJlIGxpbmtlZC4gVGhleVxuICAgIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxuICAgIC8vIHJlbW92ZXMgYnJvd3Nlci1kZWZhdWx0IHZhbHVlcyAoZWcgXCJTdWJtaXQgUXVlcnlcIikgd2hlbiBubyB2YWx1ZSBpc1xuICAgIC8vIHByb3ZpZGVkLlxuXG4gICAgc3dpdGNoIChwcm9wcy50eXBlKSB7XG4gICAgICBjYXNlICdzdWJtaXQnOlxuICAgICAgY2FzZSAncmVzZXQnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgY2FzZSAnZGF0ZXRpbWUtbG9jYWwnOlxuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgY2FzZSAndGltZSc6XG4gICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgLy8gVGhpcyBmaXhlcyB0aGUgbm8tc2hvdyBpc3N1ZSBvbiBpT1MgU2FmYXJpIGFuZCBBbmRyb2lkIENocm9tZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJztcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUuZGVmYXVsdFZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxseSwgd2UnZCBqdXN0IGRvIGBub2RlLmNoZWNrZWQgPSBub2RlLmNoZWNrZWRgIHVwb24gaW5pdGlhbCBtb3VudCwgbGVzcyB0aGlzIGJ1Z1xuICAgIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gICAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAgIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjA4NDE2XG4gICAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICAgIG5vZGUubmFtZSA9ICcnO1xuICAgIH1cbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIGlmIChuYW1lICE9PSAnJykge1xuICAgICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICAvLyBIZXJlIHdlIHVzZSBhc2FwIHRvIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaFxuICAvLyBpcyBpbXBvcnRhbnQgd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjk4XG4gIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCB0aGlzKTtcblxuICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG4gIGlmIChwcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgIHZhciByb290Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpO1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybSwgbGV0J3MganVzdCB1c2UgdGhlIGdsb2JhbFxuICAgIC8vIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZy5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG90aGVyTm9kZSA9PT0gcm9vdE5vZGUgfHwgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHJhZGlvIGJ1dHRvbnMgd2l0aCBub24tUmVhY3Qgb25lcy5cbiAgICAgIHZhciBvdGhlckluc3RhbmNlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlckluc3RhbmNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSBzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzkwJykgOiB2b2lkIDA7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4gICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCBvdGhlckluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnB1dDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JbnB1dC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICdidXR0b24nOiB0cnVlLFxuICAnY2hlY2tib3gnOiB0cnVlLFxuICAnaW1hZ2UnOiB0cnVlLFxuICAnaGlkZGVuJzogdHJ1ZSxcbiAgJ3JhZGlvJzogdHJ1ZSxcbiAgJ3Jlc2V0JzogdHJ1ZSxcbiAgJ3N1Ym1pdCc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpIHtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXRQcm9wcy52YWx1ZUxpbmsgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSB2YWx1ZUxpbmsuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLicpIDogX3Byb2RJbnZhcmlhbnQoJzg3JykgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy52YWx1ZSA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSB2YWx1ZUxpbmsgYW5kIGEgdmFsdWUgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50IHRvIHVzZSB2YWx1ZSBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rLicpIDogX3Byb2RJbnZhcmlhbnQoJzg4JykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSBjaGVja2VkIHByb3BlcnR5IG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgY2hlY2tlZExpbmsnKSA6IF9wcm9kSW52YXJpYW50KCc4OScpIDogdm9pZCAwO1xufVxuXG52YXIgcHJvcFR5cGVzID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgb25DaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBjaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBvd25lcikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIHRhZ05hbWUsICdwcm9wJywgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgZm9ybSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXG4gICAqL1xuICBnZXRDaGVja2VkOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgICovXG4gIGV4ZWN1dGVPbkNoYW5nZTogZnVuY3Rpb24gKGlucHV0UHJvcHMsIGV2ZW50KSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5vbkNoYW5nZSkge1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMub25DaGFuZ2UuY2FsbCh1bmRlZmluZWQsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvTGlua2VkVmFsdWVVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgY29udGVudCArPSBjaGlsZDtcbiAgICB9IGVsc2UgaWYgKCFkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuKSB7XG4gICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnT25seSBzdHJpbmdzIGFuZCBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgYXMgPG9wdGlvbj4gY2hpbGRyZW4uJykgOiB2b2lkIDA7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NT3B0aW9uID0ge1xuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgaG9zdFBhcmVudCkge1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5zZWxlY3RlZCA9PSBudWxsLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gTG9vayB1cCB3aGV0aGVyIHRoaXMgb3B0aW9uIGlzICdzZWxlY3RlZCdcbiAgICB2YXIgc2VsZWN0VmFsdWUgPSBudWxsO1xuICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgIHZhciBzZWxlY3RQYXJlbnQgPSBob3N0UGFyZW50O1xuXG4gICAgICBpZiAoc2VsZWN0UGFyZW50Ll90YWcgPT09ICdvcHRncm91cCcpIHtcbiAgICAgICAgc2VsZWN0UGFyZW50ID0gc2VsZWN0UGFyZW50Ll9ob3N0UGFyZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0UGFyZW50ICE9IG51bGwgJiYgc2VsZWN0UGFyZW50Ll90YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHNlbGVjdFZhbHVlID0gUmVhY3RET01TZWxlY3QuZ2V0U2VsZWN0VmFsdWVDb250ZXh0KHNlbGVjdFBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHZhbHVlIGlzIG51bGwgKGUuZy4sIG5vIHNwZWNpZmllZCB2YWx1ZSBvciBhZnRlciBpbml0aWFsIG1vdW50KVxuICAgIC8vIG9yIG1pc3NpbmcgKGUuZy4sIGZvciA8ZGF0YWxpc3Q+KSwgd2UgZG9uJ3QgY2hhbmdlIHByb3BzLnNlbGVjdGVkXG4gICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcbiAgICBpZiAoc2VsZWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSArICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAvLyBtdWx0aXBsZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkID0gJycgKyBzZWxlY3RWYWx1ZSA9PT0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0geyBzZWxlY3RlZDogc2VsZWN0ZWQgfTtcbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgcHJvcHMudmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHsgc2VsZWN0ZWQ6IHVuZGVmaW5lZCwgY2hpbGRyZW46IHVuZGVmaW5lZCB9LCBwcm9wcyk7XG5cbiAgICAvLyBSZWFkIHN0YXRlIG9ubHkgZnJvbSBpbml0aWFsIG1vdW50IGJlY2F1c2UgPHNlbGVjdD4gdXBkYXRlcyB2YWx1ZVxuICAgIC8vIG1hbnVhbGx5OyB3ZSBuZWVkIHRoZSBpbml0aWFsIHN0YXRlIG9ubHkgZm9yIHNlcnZlciByZW5kZXJpbmdcbiAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgIGhvc3RQcm9wcy5zZWxlY3RlZCA9IGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01PcHRpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NT3B0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEICYmIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlKSB7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnModGhpcywgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcykge1xuICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3NlbGVjdCcsIHByb3BzLCBvd25lcik7XG5cbiAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGBzZWxlY3RgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG4gICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gaW5zdFxuICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBsZVxuICogQHBhcmFtIHsqfSBwcm9wVmFsdWUgQSBzdHJpbmdhYmxlICh3aXRoIGBtdWx0aXBsZWAsIGEgbGlzdCBvZiBzdHJpbmdhYmxlcykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKGluc3QsIG11bHRpcGxlLCBwcm9wVmFsdWUpIHtcbiAgdmFyIHNlbGVjdGVkVmFsdWUsIGk7XG4gIHZhciBvcHRpb25zID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJyArIHByb3BWYWx1ZVtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShvcHRpb25zW2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW2ldLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICBzZWxlY3RlZFZhbHVlID0gJycgKyBwcm9wVmFsdWU7XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvcHRpb25zW2ldLnZhbHVlID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxlbmd0aCkge1xuICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG52YXIgUmVhY3RET01TZWxlY3QgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBwZW5kaW5nVXBkYXRlOiBmYWxzZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KSxcbiAgICAgIHdhc011bHRpcGxlOiBCb29sZWFuKHByb3BzLm11bHRpcGxlKVxuICAgIH07XG5cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJykgOiB2b2lkIDA7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBnZXRTZWxlY3RWYWx1ZUNvbnRleHQ6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gUmVhY3RET01PcHRpb24gbG9va3MgYXQgdGhpcyBpbml0aWFsIHZhbHVlIHNvIHRoZSBpbml0aWFsIGdlbmVyYXRlZFxuICAgIC8vIG1hcmt1cCBoYXMgY29ycmVjdCBgc2VsZWN0ZWRgIGF0dHJpYnV0ZXNcbiAgICByZXR1cm4gaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgfSxcblxuICBwb3N0VXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIEFmdGVyIHRoZSBpbml0aWFsIG1vdW50LCB3ZSBjb250cm9sIHNlbGVjdGVkLW5lc3MgbWFudWFsbHkgc28gZG9uJ3QgcGFzc1xuICAgIC8vIHRoaXMgdmFsdWUgZG93blxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgd2FzTXVsdGlwbGUgPSBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSk7XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSBCb29sZWFuKHByb3BzLm11bHRpcGxlKSkge1xuICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLm11bHRpcGxlID8gW10gOiAnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSB0cnVlO1xuICB9XG4gIFJlYWN0VXBkYXRlcy5hc2FwKHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkLCB0aGlzKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogX3Byb2RJbnZhcmlhbnQoJzkxJykgOiB2b2lkIDA7XG5cbiAgICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAgIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuICAgIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gICAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK0JlbiBzZWVtZWQgdG8gbGlrZSB0aGlzIHNvbHV0aW9uLlxuICAgIC8vIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkIHRvIGJlIGEgc3RyaW5nLlxuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgY2hpbGRyZW46ICcnICsgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYHRleHRhcmVhYCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIHZhciBpbml0aWFsVmFsdWUgPSB2YWx1ZTtcblxuICAgIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogX3Byb2RJbnZhcmlhbnQoJzkyJykgOiB2b2lkIDA7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5MycpIDogdm9pZCAwO1xuICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWUsXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIHZhciBuZXdWYWx1ZSA9ICcnICsgdmFsdWU7XG5cbiAgICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAgIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAgIC8vIE9ubHkgc2V0IG5vZGUudmFsdWUgaWYgdGV4dENvbnRlbnQgaXMgZXF1YWwgdG8gdGhlIGV4cGVjdGVkXG4gICAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAxNTI1L1xuICAgIGlmICh0ZXh0Q29udGVudCA9PT0gaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0YXJlYTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01UZXh0YXJlYS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkUmVjb25jaWxlcicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW5DaGlsZHJlbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBtYXJrdXAgdG8gYmUgcmVuZGVyZWQgYW5kIGluc2VydGVkIGF0IGEgc3VwcGxpZWQgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZUluc2VydE1hcmt1cChtYXJrdXAsIGFmdGVyTm9kZSwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0lOU0VSVF9NQVJLVVAnLFxuICAgIGNvbnRlbnQ6IG1hcmt1cCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG9JbmRleDogdG9JbmRleCxcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBtb3ZpbmcgYW4gZXhpc3RpbmcgZWxlbWVudCB0byBhbm90aGVyIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggU291cmNlIGluZGV4IG9mIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlTW92ZShjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTU9WRV9FWElTVElORycsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGNoaWxkLl9tb3VudEluZGV4LFxuICAgIGZyb21Ob2RlOiBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUoY2hpbGQpLFxuICAgIHRvSW5kZXg6IHRvSW5kZXgsXG4gICAgYWZ0ZXJOb2RlOiBhZnRlck5vZGVcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgcmVtb3ZpbmcgYW4gZWxlbWVudCBhdCBhbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VSZW1vdmUoY2hpbGQsIG5vZGUpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdSRU1PVkVfTk9ERScsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGNoaWxkLl9tb3VudEluZGV4LFxuICAgIGZyb21Ob2RlOiBub2RlLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIG1hcmt1cCBvZiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VTZXRNYXJrdXAobWFya3VwKSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnU0VUX01BUktVUCcsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlVGV4dENvbnRlbnQodGV4dENvbnRlbnQpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdURVhUX0NPTlRFTlQnLFxuICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIFB1c2ggYW4gdXBkYXRlLCBpZiBhbnksIG9udG8gdGhlIHF1ZXVlLiBDcmVhdGVzIGEgbmV3IHF1ZXVlIGlmIG5vbmUgaXNcbiAqIHBhc3NlZCBhbmQgYWx3YXlzIHJldHVybnMgdGhlIHF1ZXVlLiBNdXRhdGl2ZS5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIGlmICh1cGRhdGUpIHtcbiAgICBxdWV1ZSA9IHF1ZXVlIHx8IFtdO1xuICAgIHF1ZXVlLnB1c2godXBkYXRlKTtcbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NRdWV1ZShpbnN0LCB1cGRhdGVRdWV1ZSkge1xuICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMoaW5zdCwgdXBkYXRlUXVldWUpO1xufVxuXG52YXIgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBlbXB0eUZ1bmN0aW9uO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGdldERlYnVnSUQgPSBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGlmICghaW5zdC5fZGVidWdJRCkge1xuICAgICAgLy8gQ2hlY2sgZm9yIEFSVC1saWtlIGluc3RhbmNlcy4gVE9ETzogVGhpcyBpcyBzaWxseS9ncm9zcy5cbiAgICAgIHZhciBpbnRlcm5hbDtcbiAgICAgIGlmIChpbnRlcm5hbCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGluc3QpKSB7XG4gICAgICAgIGluc3QgPSBpbnRlcm5hbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3QuX2RlYnVnSUQ7XG4gIH07XG4gIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgdmFyIGRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgIC8vIFRPRE86IFJlYWN0IE5hdGl2ZSBlbXB0eSBjb21wb25lbnRzIGFyZSBhbHNvIG11bHRpY2hpbGQuXG4gICAgLy8gVGhpcyBtZWFucyB0aGV5IHN0aWxsIGdldCBpbnRvIHRoaXMgbWV0aG9kIGJ1dCBkb24ndCBoYXZlIF9kZWJ1Z0lELlxuICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZHJlbiA/IE9iamVjdC5rZXlzKGNoaWxkcmVuKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5ba2V5XS5fZGVidWdJRDtcbiAgICAgIH0pIDogW10pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZWFjdE11bHRpQ2hpbGQgYXJlIGNhcGFibGUgb2YgcmVjb25jaWxpbmcgbXVsdGlwbGUgY2hpbGRyZW4uXG4gKlxuICogQGNsYXNzIFJlYWN0TXVsdGlDaGlsZFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGQgPSB7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICBfcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbmV4dENoaWxkcmVuO1xuICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBtb3VudGVkIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBtb3VudENoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25hbWVdO1xuICAgICAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICBtb3VudEltYWdlcy5wdXNoKG1vdW50SW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW91bnRJbWFnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0Q29udGVudCBTdHJpbmcgb2YgY29udGVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0Q29udGVudDogZnVuY3Rpb24gKG5leHRDb250ZW50KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVRleHRDb250ZW50IGNhbGxlZCBvbiBub24tZW1wdHkgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzExOCcpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgbmV3IHRleHQgY29udGVudC5cbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VUZXh0Q29udGVudChuZXh0Q29udGVudCldO1xuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG1hcmt1cCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dE1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZU1hcmt1cDogZnVuY3Rpb24gKG5leHRNYXJrdXApIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIGZhbHNlKTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlVGV4dENvbnRlbnQgY2FsbGVkIG9uIG5vbi1lbXB0eSBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMTE4JykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VTZXRNYXJrdXAobmV4dE1hcmt1cCldO1xuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIG5ldyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIC8vIEhvb2sgdXNlZCBieSBSZWFjdCBBUlRcbiAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICB2YXIgcmVtb3ZlZE5vZGVzID0ge307XG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlcyA9IG51bGw7XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIC8vIGBuZXh0SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIGNoaWxkIGluIGBuZXh0Q2hpbGRyZW5gLCBidXRcbiAgICAgIC8vIGBsYXN0SW5kZXhgIHdpbGwgYmUgdGhlIGxhc3QgaW5kZXggdmlzaXRlZCBpbiBgcHJldkNoaWxkcmVuYC5cbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICAvLyBgbmV4dE1vdW50SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIG5ld2x5IG1vdW50ZWQgY2hpbGQuXG4gICAgICB2YXIgbmV4dE1vdW50SW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RQbGFjZWROb2RlID0gbnVsbDtcbiAgICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgaWYgKHByZXZDaGlsZCA9PT0gbmV4dENoaWxkKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5tb3ZlQ2hpbGQocHJldkNoaWxkLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCBsYXN0SW5kZXgpKTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgcHJldkNoaWxkLl9tb3VudEluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBgbGFzdEluZGV4YCBiZWZvcmUgYF9tb3VudEluZGV4YCBnZXRzIHVuc2V0IGJ5IHVubW91bnRpbmcuXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICAvLyBUaGUgYHJlbW92ZWROb2Rlc2AgbG9vcCBiZWxvdyB3aWxsIGFjdHVhbGx5IHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMuX21vdW50Q2hpbGRBdEluZGV4KG5leHRDaGlsZCwgbW91bnRJbWFnZXNbbmV4dE1vdW50SW5kZXhdLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkpO1xuICAgICAgICAgIG5leHRNb3VudEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgIGxhc3RQbGFjZWROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKG5leHRDaGlsZCk7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgICBmb3IgKG5hbWUgaW4gcmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdLCByZW1vdmVkTm9kZXNbbmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbjtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC4gSXQgZG9lcyBub3QgYWN0dWFsbHkgcGVyZm9ybSBhbnlcbiAgICAgKiBiYWNrZW5kIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY2hpbGQgY29tcG9uZW50IHRvIHRoZSBzdXBwbGllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0SW5kZXggTGFzdCBpbmRleCB2aXNpdGVkIG9mIHRoZSBzaWJsaW5ncyBvZiBgY2hpbGRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4LCBsYXN0SW5kZXgpIHtcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiBgY2hpbGRgIGlzIGxlc3MgdGhhbiBgbGFzdEluZGV4YCwgdGhlbiBpdCBuZWVkcyB0b1xuICAgICAgLy8gYmUgbW92ZWQuIE90aGVyd2lzZSwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSBpdCBiZWNhdXNlIGEgY2hpbGQgd2lsbCBiZVxuICAgICAgLy8gaW5zZXJ0ZWQgb3IgbW92ZWQgYmVmb3JlIGBjaGlsZGAuXG4gICAgICBpZiAoY2hpbGQuX21vdW50SW5kZXggPCBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW91bnRJbWFnZSBNYXJrdXAgdG8gaW5zZXJ0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBhZnRlck5vZGUsIG1vdW50SW1hZ2UpIHtcbiAgICAgIHJldHVybiBtYWtlSW5zZXJ0TWFya3VwKG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ2hpbGQgdG8gcmVtb3ZlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBub2RlKSB7XG4gICAgICByZXR1cm4gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBhIGNoaWxkIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW91bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdW50Q2hpbGRBdEluZGV4OiBmdW5jdGlvbiAoY2hpbGQsIG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgaW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2hpbGQoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bm1vdW50Q2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQsIG5vZGUpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZTtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHN3YXBwaW5nIG91dCBtb3VudCBpbWFnZXMgaW4gdGhlIG1pZGRsZSBvZlxuICAgKiB0aGUgdHJlZS5cbiAgICovXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXG4gICAqIGxhdGVyIG1vdmUgaW50byBNdWx0aUNoaWxkQ29tcG9uZW50cy5cbiAgICovXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgISFpbmplY3RlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDQnKSA6IHZvaWQgMDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzID0gZW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcztcbiAgICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqL1xuXG4vLyBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCBFUzY6IHZhciBSZWFjdEluc3RhbmNlTWFwID0gbmV3IE1hcCgpO1xuXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHtcblxuICAvKipcbiAgICogVGhpcyBBUEkgc2hvdWxkIGJlIGNhbGxlZCBgZGVsZXRlYCBidXQgd2UnZCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBhbHdheXNcbiAgICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAgICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2U7XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdmFsdWU7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluc3RhbmNlTWFwO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEluc3RhbmNlTWFwLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGVDaGlsZChjaGlsZEluc3RhbmNlcywgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICB2YXIga2V5VW5pcXVlID0gY2hpbGRJbnN0YW5jZXNbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgIH1cbiAgICBpZiAoIWtleVVuaXF1ZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4lcycsIEtleUVzY2FwZVV0aWxzLnVuZXNjYXBlKG5hbWUpLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKHNlbGZEZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGlmIChjaGlsZCAhPSBudWxsICYmIGtleVVuaXF1ZSkge1xuICAgIGNoaWxkSW5zdGFuY2VzW25hbWVdID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChjaGlsZCwgdHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFjdENoaWxkUmVjb25jaWxlciBwcm92aWRlcyBoZWxwZXJzIGZvciBpbml0aWFsaXppbmcgb3IgdXBkYXRpbmcgYSBzZXQgb2ZcbiAqIGNoaWxkcmVuLiBJdHMgb3V0cHV0IGlzIHN1aXRhYmxlIGZvciBwYXNzaW5nIGl0IG9udG8gUmVhY3RNdWx0aUNoaWxkIHdoaWNoXG4gKiBkb2VzIGRpZmZlZCByZW9yZGVyaW5nIGFuZCBpbnNlcnRpb24uXG4gKi9cbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkTm9kZXMgTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBpbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXG4gICkge1xuICAgIGlmIChuZXN0ZWRDaGlsZE5vZGVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0YW5jZXMgPSB7fTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKG5lc3RlZENoaWxkTm9kZXMsIGZ1bmN0aW9uIChjaGlsZEluc3RzLCBjaGlsZCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFudGlhdGVDaGlsZChjaGlsZEluc3RzLCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpO1xuICAgICAgfSwgY2hpbGRJbnN0YW5jZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKG5lc3RlZENoaWxkTm9kZXMsIGluc3RhbnRpYXRlQ2hpbGQsIGNoaWxkSW5zdGFuY2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkSW5zdGFuY2VzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiBhbmQgcmV0dXJucyBhIG5ldyBzZXQgb2YgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDaGlsZHJlbiBGbGF0IGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIG5ldyBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IGRvbid0IGhhdmUgYSB3YXkgdG8gdHJhY2sgbW92ZXMgaGVyZSBidXQgaWYgd2UgdXNlIGl0ZXJhdG9yc1xuICAgIC8vIGluc3RlYWQgb2YgZm9yLi5pbiB3ZSBjYW4gemlwIHRoZSBpdGVyYXRvcnMgYW5kIGNoZWNrIGlmIGFuIGl0ZW0gaGFzXG4gICAgLy8gbW92ZWQuXG4gICAgLy8gVE9ETzogSWYgbm90aGluZyBoYXMgY2hhbmdlZCwgcmV0dXJuIHRoZSBwcmV2Q2hpbGRyZW4gb2JqZWN0IHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gcXVpY2tseSBiYWlsb3V0IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWQuXG4gICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgcHJldkNoaWxkO1xuICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZDaGlsZCAmJiBwcmV2Q2hpbGQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIG5leHRFbGVtZW50ID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgaWYgKHByZXZDaGlsZCAhPSBudWxsICYmIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNoaWxkLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBwcmV2Q2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzW25hbWVdID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDaGlsZCk7XG4gICAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIHRydWUpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBuZXh0Q2hpbGRJbnN0YW5jZTtcbiAgICAgICAgLy8gQ3JlYXRpbmcgbW91bnQgaW1hZ2Ugbm93IGVuc3VyZXMgcmVmcyBhcmUgcmVzb2x2ZWQgaW4gcmlnaHQgb3JkZXJcbiAgICAgICAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTAxIGZvciBleHBsYW5hdGlvbikuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRNb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KG5leHRDaGlsZEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgbW91bnRJbWFnZXMucHVzaChuZXh0Q2hpbGRNb3VudEltYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVW5tb3VudCBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICBmb3IgKG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcbiAgICAgICAgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgICByZW1vdmVkTm9kZXNbbmFtZV0gPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNoaWxkKTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcmVuZGVyZWRDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChyZW5kZXJlZENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHZhciByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocmVuZGVyZWRDaGlsZCwgc2FmZWx5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkUmVjb25jaWxlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEhvc3RDb21wb25lbnQnKTtcblxudmFyIGdldE5leHREZWJ1Z0lEID0gcmVxdWlyZSgnLi9nZXROZXh0RGVidWdJRCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8vIFRvIGF2b2lkIGEgY3ljbGljIGRlcGVuZGVuY3ksIHdlIGNyZWF0ZSB0aGUgZmluYWwgY2xhc3MgaW4gdGhpcyBtb2R1bGVcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB0aGlzLmNvbnN0cnVjdChlbGVtZW50KTtcbn07XG5fYXNzaWduKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUsIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LCB7XG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG59KTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHR5cGUgcmVmZXJlbmNlIGlzIGEga25vd24gaW50ZXJuYWwgdHlwZS4gSS5lLiBub3QgYSB1c2VyXG4gKiBwcm92aWRlZCBjb21wb3NpdGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHZhbGlkIGludGVybmFsIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3ROb2RlLCBjcmVhdGUgYW4gaW5zdGFuY2UgdGhhdCB3aWxsIGFjdHVhbGx5IGJlIG1vdW50ZWQuXG4gKlxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkSGF2ZURlYnVnSURcbiAqIEByZXR1cm4ge29iamVjdH0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQncyBjb25zdHJ1Y3Rvci5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChub2RlLCBzaG91bGRIYXZlRGVidWdJRCkge1xuICB2YXIgaW5zdGFuY2U7XG5cbiAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gZmFsc2UpIHtcbiAgICBpbnN0YW5jZSA9IFJlYWN0RW1wdHlDb21wb25lbnQuY3JlYXRlKGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBlbGVtZW50ID0gbm9kZTtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArICdpdFxcJ3MgZGVmaW5lZCBpbi4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShlbGVtZW50Ll9vd25lcik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbykgOiBfcHJvZEludmFyaWFudCgnMTMwJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2Ugc3RyaW5nIHZhbHVlc1xuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuXG4gICAgICAvLyBXZSByZW5hbWVkIHRoaXMuIEFsbG93IHRoZSBvbGQgbmFtZSBmb3IgY29tcGF0LiA6KFxuICAgICAgaWYgKCFpbnN0YW5jZS5nZXRIb3N0Tm9kZSkge1xuICAgICAgICBpbnN0YW5jZS5nZXRIb3N0Tm9kZSA9IGluc3RhbmNlLmdldE5hdGl2ZU5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlID0gbmV3IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlcihlbGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3RIb3N0Q29tcG9uZW50LmNyZWF0ZUluc3RhbmNlRm9yVGV4dChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMTMxJywgdHlwZW9mIG5vZGUpIDogdm9pZCAwO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdGFuY2UubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldEhvc3ROb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdm9pZCAwO1xuICB9XG5cbiAgLy8gVGhlc2UgdHdvIGZpZWxkcyBhcmUgdXNlZCBieSB0aGUgRE9NIGFuZCBBUlQgZGlmZmluZyBhbGdvcml0aG1zXG4gIC8vIHJlc3BlY3RpdmVseS4gSW5zdGVhZCBvZiB1c2luZyBleHBhbmRvcyBvbiBjb21wb25lbnRzLCB3ZSBzaG91bGQgYmVcbiAgLy8gc3RvcmluZyB0aGUgc3RhdGUgbmVlZGVkIGJ5IHRoZSBkaWZmaW5nIGFsZ29yaXRobXMgZWxzZXdoZXJlLlxuICBpbnN0YW5jZS5fbW91bnRJbmRleCA9IDA7XG4gIGluc3RhbmNlLl9tb3VudEltYWdlID0gbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluc3RhbmNlLl9kZWJ1Z0lEID0gc2hvdWxkSGF2ZURlYnVnSUQgPyBnZXROZXh0RGVidWdJRCgpIDogMDtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3ROb2RlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0Tm9kZVR5cGVzJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XG59XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIENvbXBvc2l0ZVR5cGVzID0ge1xuICBJbXB1cmVDbGFzczogMCxcbiAgUHVyZUNsYXNzOiAxLFxuICBTdGF0ZWxlc3NGdW5jdGlvbmFsOiAyXG59O1xuXG5mdW5jdGlvbiBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KSB7fVxuU3RhdGVsZXNzQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBDb21wb25lbnQgPSBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKS5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgdmFyIGVsZW1lbnQgPSBDb21wb25lbnQodGhpcy5wcm9wcywgdGhpcy5jb250ZXh0LCB0aGlzLnVwZGF0ZXIpO1xuICB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbmZ1bmN0aW9uIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgZWxlbWVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UgfHwgUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCksICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICsgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBpc1B1cmVDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBTZXBhcmF0ZWQgaW50byBhIGZ1bmN0aW9uIHRvIGNvbnRhaW4gZGVvcHRpbWl6YXRpb25zIGNhdXNlZCBieSB0cnkvZmluYWxseS5cbmZ1bmN0aW9uIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZuLCBkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGRlYnVnSUQgPT09IDApIHtcbiAgICAvLyBUb3AtbGV2ZWwgd3JhcHBlcnMgKHNlZSBSZWFjdE1vdW50KSBhbmQgZW1wdHkgY29tcG9uZW50cyAoc2VlXG4gICAgLy8gUmVhY3RET01FbXB0eUNvbXBvbmVudCkgYXJlIGludmlzaWJsZSB0byBob29rcyBhbmQgZGV2dG9vbHMuXG4gICAgLy8gQm90aCBhcmUgaW1wbGVtZW50YXRpb24gZGV0YWlscyB0aGF0IHNob3VsZCBnbyBhd2F5IGluIHRoZSBmdXR1cmUuXG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLSBUaGUgTGlmZS1DeWNsZSBvZiBhIENvbXBvc2l0ZSBDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogLSBjb25zdHJ1Y3RvcjogSW5pdGlhbGl6YXRpb24gb2Ygc3RhdGUuIFRoZSBpbnN0YW5jZSBpcyBub3cgcmV0YWluZWQuXG4gKiAgIC0gY29tcG9uZW50V2lsbE1vdW50XG4gKiAgIC0gcmVuZGVyXG4gKiAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXJdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnREaWRNb3VudF1cbiAqICAgICAtIGNvbXBvbmVudERpZE1vdW50XG4gKlxuICogICAgICAgVXBkYXRlIFBoYXNlczpcbiAqICAgICAgIC0gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAob25seSBjYWxsZWQgaWYgcGFyZW50IHVwZGF0ZWQpXG4gKiAgICAgICAtIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICogICAgICAgICAtIGNvbXBvbmVudFdpbGxVcGRhdGVcbiAqICAgICAgICAgICAtIHJlbmRlclxuICogICAgICAgICAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzIG9yIHJlY2VpdmUgcHJvcHMgcGhhc2VzXVxuICogICAgICAgICAtIGNvbXBvbmVudERpZFVwZGF0ZVxuICpcbiAqICAgICAtIGNvbXBvbmVudFdpbGxVbm1vdW50XG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsVW5tb3VudF1cbiAqICAgLSBbY2hpbGRyZW4gZGVzdHJveWVkXVxuICogLSAoZGVzdHJveWVkKTogVGhlIGluc3RhbmNlIGlzIG5vdyBibGFuaywgcmVsZWFzZWQgYnkgUmVhY3QgYW5kIHJlYWR5IGZvciBHQy5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQW4gaW5jcmVtZW50aW5nIElEIGFzc2lnbmVkIHRvIGVhY2ggY29tcG9uZW50IHdoZW4gaXQgaXMgbW91bnRlZC4gVGhpcyBpc1xuICogdXNlZCB0byBlbmZvcmNlIHRoZSBvcmRlciBpbiB3aGljaCBgUmVhY3RVcGRhdGVzYCB1cGRhdGVzIGRpcnR5IGNvbXBvbmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG5leHRNb3VudElEID0gMTtcblxuLyoqXG4gKiBAbGVuZHMge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LnByb3RvdHlwZX1cbiAqL1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlUXVldWVcbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMgYW5kIFJlYWN0VXBkYXRlUXVldWUuXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICAvLyBDb21wb25lbnRXaWxsVW5tb3VudCBzaGFsbCBvbmx5IGJlIGNhbGxlZCBvbmNlXG4gICAgdGhpcy5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSBmYWxzZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aGlzLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0UGFyZW50XG4gICAqIEBwYXJhbSB7P29iamVjdH0gaG9zdENvbnRhaW5lckluZm9cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSBuZXh0TW91bnRJRCsrO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgcHVibGljUHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgcHVibGljQ29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICB2YXIgdXBkYXRlUXVldWUgPSB0cmFuc2FjdGlvbi5nZXRVcGRhdGVRdWV1ZSgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHVibGljIGNsYXNzXG4gICAgdmFyIGRvQ29uc3RydWN0ID0gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCk7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnQoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIC8vIFN1cHBvcnQgZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gICAgaWYgKCFkb0NvbnN0cnVjdCAmJiAoaW5zdCA9PSBudWxsIHx8IGluc3QucmVuZGVyID09IG51bGwpKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBpbnN0O1xuICAgICAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCByZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgIShpbnN0ID09PSBudWxsIHx8IGluc3QgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KGluc3QpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDUnLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaW5zdCA9IG5ldyBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KTtcbiAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5JbXB1cmVDbGFzcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGxhdGVyIGluIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQsIGJ1dCBhZGQgYW4gZWFybHlcbiAgICAgIC8vIHdhcm5pbmcgbm93IHRvIGhlbHAgZGVidWdnaW5nXG4gICAgICBpZiAoaW5zdC5yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wc011dGF0ZWQgPSBpbnN0LnByb3BzICE9PSBwdWJsaWNQcm9wcztcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0LnByb3BzID09PSB1bmRlZmluZWQgfHwgIXByb3BzTXV0YXRlZCwgJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyAndXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBzaG91bGQgYmUgc2V0IHVwIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgLy8gc2ltcGxlciBjbGFzcyBhYnN0cmFjdGlvbnMsIHdlIHNldCB0aGVtIHVwIGFmdGVyIHRoZSBmYWN0LlxuICAgIGluc3QucHJvcHMgPSBwdWJsaWNQcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgIGluc3QudXBkYXRlciA9IHVwZGF0ZVF1ZXVlO1xuXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0O1xuXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgYmFjayB0byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICBSZWFjdEluc3RhbmNlTWFwLnNldChpbnN0LCB0aGlzKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBTaW5jZSBwbGFpbiBKUyBjbGFzc2VzIGFyZSBkZWZpbmVkIHdpdGhvdXQgYW55IHNwZWNpYWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIGxvZ2ljLCB3ZSBjYW4gbm90IGNhdGNoIGNvbW1vbiBlcnJvcnMgZWFybHkuIFRoZXJlZm9yZSwgd2UgaGF2ZSB0b1xuICAgICAgLy8gY2F0Y2ggdGhlbSBoZXJlLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lLCBpbnN0ZWFkLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3QuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8IGluc3Quc3RhdGUsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdC5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LnByb3BUeXBlcywgJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuY29udGV4dFR5cGVzLCAnY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSAnICsgJ3N0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0LnN0YXRlID0gaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDYnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgbWFya3VwO1xuICAgIGlmIChpbnN0LnVuc3RhYmxlX2hhbmRsZUVycm9yKSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnRXaXRoRXJyb3JIYW5kbGluZyhyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50RGlkTW91bnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgfSwgX3RoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRNb3VudCwgaW5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBfY29uc3RydWN0Q29tcG9uZW50OiBmdW5jdGlvbiAoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcihkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB9XG4gIH0sXG5cbiAgX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcjogZnVuY3Rpb24gKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIGlmIChkb0NvbnN0cnVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY3RvcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGNhbiBzdGlsbCBiZSBhbiBpbnN0YW5jZSBpbiBjYXNlIG9mIGZhY3RvcnkgY29tcG9uZW50c1xuICAgIC8vIGJ1dCB3ZSdsbCBjb3VudCB0aGlzIGFzIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGFzIHRoZSBtb3JlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB9XG4gIH0sXG5cbiAgcGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nOiBmdW5jdGlvbiAocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbWFya3VwO1xuICAgIHZhciBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xuICAgIHRyeSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFJvbGwgYmFjayB0byBjaGVja3BvaW50LCBoYW5kbGUgZXJyb3IgKHdoaWNoIG1heSBhZGQgaXRlbXMgdG8gdGhlIHRyYW5zYWN0aW9uKSwgYW5kIHRha2UgYSBuZXcgY2hlY2twb2ludFxuICAgICAgdHJhbnNhY3Rpb24ucm9sbGJhY2soY2hlY2twb2ludCk7XG4gICAgICB0aGlzLl9pbnN0YW5jZS51bnN0YWJsZV9oYW5kbGVFcnJvcihlKTtcbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xuICAgICAgICB0aGlzLl9pbnN0YW5jZS5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUodGhpcy5faW5zdGFuY2UucHJvcHMsIHRoaXMuX2luc3RhbmNlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgY2hlY2twb2ludCA9IHRyYW5zYWN0aW9uLmNoZWNrcG9pbnQoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQudW5tb3VudENvbXBvbmVudCh0cnVlKTtcbiAgICAgIHRyYW5zYWN0aW9uLnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuXG4gICAgICAvLyBUcnkgYWdhaW4gLSB3ZSd2ZSBpbmZvcm1lZCB0aGUgY29tcG9uZW50IGFib3V0IHRoZSBlcnJvciwgc28gdGhleSBjYW4gcmVuZGVyIGFuIGVycm9yIG1lc3NhZ2UgdGhpcyB0aW1lLlxuICAgICAgLy8gSWYgdGhpcyB0aHJvd3MgYWdhaW4sIHRoZSBlcnJvciB3aWxsIGJ1YmJsZSB1cCAoYW5kIGNhbiBiZSBjYXVnaHQgYnkgYSBoaWdoZXIgZXJyb3IgYm91bmRhcnkpLlxuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBwZXJmb3JtSW5pdGlhbE1vdW50OiBmdW5jdGlvbiAocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGRlYnVnSUQgPSAwO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgfSwgZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cbiAgICAgIC8vIFdoZW4gbW91bnRpbmcsIGNhbGxzIHRvIGBzZXRTdGF0ZWAgYnkgYGNvbXBvbmVudFdpbGxNb3VudGAgd2lsbCBzZXRcbiAgICAgIC8vIGB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZWAgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyLlxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIGluc3Quc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKGluc3QucHJvcHMsIGluc3QuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90IGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgd2Ugbm93IHJlbmRlclxuICAgIGlmIChyZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShyZW5kZXJlZEVsZW1lbnQpO1xuICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KHJlbmRlcmVkRWxlbWVudCwgbm9kZVR5cGUgIT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZIC8qIHNob3VsZEhhdmVEZWJ1Z0lEICovXG4gICAgKTtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGNoaWxkO1xuXG4gICAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpLCBkZWJ1Z0lEKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZGVidWdJRCAhPT0gMCkge1xuICAgICAgICB2YXIgY2hpbGREZWJ1Z0lEcyA9IGNoaWxkLl9kZWJ1Z0lEICE9PSAwID8gW2NoaWxkLl9kZWJ1Z0lEXSA6IFtdO1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZSh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICBpZiAoIXRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50ICYmICFpbnN0Ll9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCkge1xuICAgICAgaW5zdC5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSB0cnVlO1xuXG4gICAgICBpZiAoc2FmZWx5KSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXROYW1lKCkgKyAnLmNvbXBvbmVudFdpbGxVbm1vdW50KCknO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQuYmluZChpbnN0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgc2FmZWx5KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBudWxsO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHBlbmRpbmcgZmllbGRzXG4gICAgLy8gRXZlbiBpZiB0aGlzIGNvbXBvbmVudCBpcyBzY2hlZHVsZWQgZm9yIGFub3RoZXIgdXBkYXRlIGluIFJlYWN0VXBkYXRlcyxcbiAgICAvLyBpdCB3b3VsZCBzdGlsbCBiZSBpZ25vcmVkIGJlY2F1c2UgdGhlc2UgZmllbGRzIGFyZSByZXNldC5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIC8vIFRoZXNlIGZpZWxkcyBkbyBub3QgcmVhbGx5IG5lZWQgdG8gYmUgcmVzZXQgc2luY2UgdGhpcyBvYmplY3QgaXMgbm9cbiAgICAvLyBsb25nZXIgYWNjZXNzaWJsZS5cbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gRGVsZXRlIHRoZSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgdG8gdGhpcyBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgIC8vIHdoaWNoIGFsbG93IHRoZSBpbnRlcm5hbHMgdG8gYmUgcHJvcGVybHkgY2xlYW5lZCB1cCBldmVuIGlmIHRoZSB1c2VyXG4gICAgLy8gbGVha3MgYSByZWZlcmVuY2UgdG8gdGhlIHB1YmxpYyBpbnN0YW5jZS5cbiAgICBSZWFjdEluc3RhbmNlTWFwLnJlbW92ZShpbnN0KTtcblxuICAgIC8vIFNvbWUgZXhpc3RpbmcgY29tcG9uZW50cyByZWx5IG9uIGluc3QucHJvcHMgZXZlbiBhZnRlciB0aGV5J3ZlIGJlZW5cbiAgICAvLyBkZXN0cm95ZWQgKGluIGV2ZW50IGhhbmRsZXJzKS5cbiAgICAvLyBUT0RPOiBpbnN0LnByb3BzID0gbnVsbDtcbiAgICAvLyBUT0RPOiBpbnN0LnN0YXRlID0gbnVsbDtcbiAgICAvLyBUT0RPOiBpbnN0LmNvbnRleHQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2BcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYXNrQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICAgIH1cbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IHt9O1xuICAgIGZvciAodmFyIGNvbnRleHROYW1lIGluIGNvbnRleHRUeXBlcykge1xuICAgICAgbWFza2VkQ29udGV4dFtjb250ZXh0TmFtZV0gPSBjb250ZXh0W2NvbnRleHROYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYCwgYW5kIGFzc2VydHMgdGhhdCB0aGV5IGFyZSB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IHRoaXMuX21hc2tDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICAgIGlmIChDb21wb25lbnQuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrQ29udGV4dFR5cGVzKENvbXBvbmVudC5jb250ZXh0VHlwZXMsIG1hc2tlZENvbnRleHQsICdjb250ZXh0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY3VycmVudENvbnRleHRcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIChjdXJyZW50Q29udGV4dCkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIGNoaWxkQ29udGV4dDtcblxuICAgIGlmIChpbnN0LmdldENoaWxkQ29udGV4dCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgISh0eXBlb2YgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA3JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aGlzLl9jaGVja0NvbnRleHRUeXBlcyhDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkQ29udGV4dCcpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgIShuYW1lIGluIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTA4JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2Fzc2lnbih7fSwgY3VycmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIGNvbnRleHQgdHlwZXMgYXJlIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIGNvbnRleHQgZmllbGQgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tDb250ZXh0VHlwZXM6IGZ1bmN0aW9uICh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgdGhpcy5nZXROYW1lKCksIG51bGwsIHRoaXMuX2RlYnVnSUQpO1xuICAgIH1cbiAgfSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBuZXh0Q29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBwcmV2Q29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBwcmV2Q29udGV4dCwgbmV4dENvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhbnkgb2YgYF9wZW5kaW5nRWxlbWVudGAsIGBfcGVuZGluZ1N0YXRlUXVldWVgLCBvciBgX3BlbmRpbmdGb3JjZVVwZGF0ZWBcbiAgICogaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHRoaXMsIHRoaXMuX3BlbmRpbmdFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSAhPT0gbnVsbCB8fCB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIHVwZGF0ZSB0byBhIG1vdW50ZWQgY29tcG9uZW50LiBUaGUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBhbmRcbiAgICogc2hvdWxkQ29tcG9uZW50VXBkYXRlIG1ldGhvZHMgYXJlIGNhbGxlZCwgdGhlbiAoYXNzdW1pbmcgdGhlIHVwZGF0ZSBpc24ndFxuICAgKiBza2lwcGVkKSB0aGUgcmVtYWluaW5nIHVwZGF0ZSBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgY2FsbGVkIGFuZCB0aGUgRE9NXG4gICAqIHJlcHJlc2VudGF0aW9uIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldlBhcmVudEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRQYXJlbnRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2UGFyZW50RWxlbWVudCwgbmV4dFBhcmVudEVsZW1lbnQsIHByZXZVbm1hc2tlZENvbnRleHQsIG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdBdHRlbXB0ZWQgdG8gdXBkYXRlIGNvbXBvbmVudCBgJXNgIHRoYXQgaGFzIGFscmVhZHkgYmVlbiB1bm1vdW50ZWQgKG9yIGZhaWxlZCB0byBtb3VudCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTM2JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICB2YXIgd2lsbFJlY2VpdmUgPSBmYWxzZTtcbiAgICB2YXIgbmV4dENvbnRleHQ7XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQgb3Igbm90XG4gICAgaWYgKHRoaXMuX2NvbnRleHQgPT09IG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICAgIG5leHRDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgICAgd2lsbFJlY2VpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcmV2UHJvcHMgPSBwcmV2UGFyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gbmV4dFBhcmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBOb3QgYSBzaW1wbGUgc3RhdGUgdXBkYXRlIGJ1dCBhIHByb3BzIHVwZGF0ZVxuICAgIGlmIChwcmV2UGFyZW50RWxlbWVudCAhPT0gbmV4dFBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBbiB1cGRhdGUgaGVyZSB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSBidXQgaW1tZWRpYXRlbHkgc2V0XG4gICAgLy8gX3BlbmRpbmdTdGF0ZVF1ZXVlIHdoaWNoIHdpbGwgZW5zdXJlIHRoYXQgYW55IHN0YXRlIHVwZGF0ZXMgZ2V0c1xuICAgIC8vIGltbWVkaWF0ZWx5IHJlY29uY2lsZWQgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciB0aGUgbmV4dCBiYXRjaC5cbiAgICBpZiAod2lsbFJlY2VpdmUgJiYgaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICBpZiAoaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlID0gaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvc2l0ZVR5cGUgPT09IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcykge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9ICFzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwoaW5zdC5zdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IF9hc3NpZ24oe30sIHJlcGxhY2UgPyBxdWV1ZVswXSA6IGluc3Quc3RhdGUpO1xuICAgIGZvciAodmFyIGkgPSByZXBsYWNlID8gMSA6IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnRpYWwgPSBxdWV1ZVtpXTtcbiAgICAgIF9hc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyBuZXcgcHJvcHMgYW5kIHN0YXRlLCBub3RpZmllcyBkZWxlZ2F0ZSBtZXRob2RzIG9mIHVwZGF0ZSBhbmRcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgTmV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHQgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICB2YXIgaGFzQ29tcG9uZW50RGlkVXBkYXRlID0gQm9vbGVhbihpbnN0LmNvbXBvbmVudERpZFVwZGF0ZSk7XG4gICAgdmFyIHByZXZQcm9wcztcbiAgICB2YXIgcHJldlN0YXRlO1xuICAgIHZhciBwcmV2Q29udGV4dDtcbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBwcmV2UHJvcHMgPSBpbnN0LnByb3BzO1xuICAgICAgcHJldlN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICAgIHByZXZDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMuX2NvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRDb21wb25lbnQodHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIF90aGlzMi5fZGVidWdJRCwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRVcGRhdGUuYmluZChpbnN0LCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIGNvbXBvbmVudCdzIGByZW5kZXJgIG1ldGhvZCBhbmQgdXBkYXRlIHRoZSBET00gYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBfdXBkYXRlUmVuZGVyZWRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2Q29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB2YXIgcHJldlJlbmRlcmVkRWxlbWVudCA9IHByZXZDb21wb25lbnRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIG5leHRSZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcblxuICAgIHZhciBkZWJ1Z0lEID0gMDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZSZW5kZXJlZEVsZW1lbnQsIG5leHRSZW5kZXJlZEVsZW1lbnQpKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIG5leHRSZW5kZXJlZEVsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9sZEhvc3ROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIGZhbHNlKTtcblxuICAgICAgdmFyIG5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShuZXh0UmVuZGVyZWRFbGVtZW50KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dFJlbmRlcmVkRWxlbWVudCwgbm9kZVR5cGUgIT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZIC8qIHNob3VsZEhhdmVEZWJ1Z0lEICovXG4gICAgICApO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBjaGlsZDtcblxuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLl9ob3N0UGFyZW50LCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgZGVidWdJRCk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgdmFyIGNoaWxkRGVidWdJRHMgPSBjaGlsZC5fZGVidWdJRCAhPT0gMCA/IFtjaGlsZC5fZGVidWdJRF0gOiBbXTtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZDb21wb25lbnRJbnN0YW5jZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZGVuIGluIHNoYWxsb3cgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2SW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluc3QucmVuZGVyKCk7XG4gICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3QucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICByZW5kZXJlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZEVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyB8fCB0aGlzLl9jb21wb3NpdGVUeXBlICE9PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgIH1cbiAgICAhKFxuICAgIC8vIFRPRE86IEFuIGBpc1ZhbGlkTm9kZWAgZnVuY3Rpb24gd291bGQgcHJvYmFibHkgYmUgbW9yZSBhcHByb3ByaWF0ZVxuICAgIHJlbmRlcmVkRWxlbWVudCA9PT0gbnVsbCB8fCByZW5kZXJlZEVsZW1lbnQgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KHJlbmRlcmVkRWxlbWVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnJlbmRlcigpOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA5JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMYXppbHkgYWxsb2NhdGVzIHRoZSByZWZzIG9iamVjdCBhbmQgc3RvcmVzIGBjb21wb25lbnRgIGFzIGByZWZgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxuICAgKiBAcGFyYW0ge2NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBzdG9yZSBhcyBgcmVmYC5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hSZWY6IGZ1bmN0aW9uIChyZWYsIGNvbXBvbmVudCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogX3Byb2RJbnZhcmlhbnQoJzExMCcpIDogdm9pZCAwO1xuICAgIHZhciBwdWJsaWNDb21wb25lbnRJbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudCAmJiBjb21wb25lbnQuZ2V0TmFtZSA/IGNvbXBvbmVudC5nZXROYW1lKCkgOiAnYSBjb21wb25lbnQnO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHVibGljQ29tcG9uZW50SW5zdGFuY2UgIT0gbnVsbCB8fCBjb21wb25lbnQuX2NvbXBvc2l0ZVR5cGUgIT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcyAnICsgJyhTZWUgcmVmIFwiJXNcIiBpbiAlcyBjcmVhdGVkIGJ5ICVzKS4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLicsIHJlZiwgY29tcG9uZW50TmFtZSwgdGhpcy5nZXROYW1lKCkpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICByZWZzW3JlZl0gPSBwdWJsaWNDb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0YWNoZXMgYSByZWZlcmVuY2UgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGFjaFJlZjogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciByZWZzID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnM7XG4gICAgZGVsZXRlIHJlZnNbcmVmXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgaXRcbiAgICogaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb3IgbnVsbC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5uYW1lIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudCAtIGkuZS4gd2hhdFxuICAgKiBpcyBleHBvc2VkIGJ5IHJlZnMgYW5kIHJldHVybmVkIGJ5IHJlbmRlci4gQ2FuIGJlIG51bGwgZm9yIHN0YXRlbGVzc1xuICAgKiBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gdGhlIHB1YmxpYyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLy8gU3R1YlxuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Tm9kZVR5cGVzID0ge1xuICBIT1NUOiAwLFxuICBDT01QT1NJVEU6IDEsXG4gIEVNUFRZOiAyLFxuXG4gIGdldFR5cGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5FTVBUWTtcbiAgICB9IGVsc2UgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICBpZiAodHlwZW9mIG5vZGUudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkhPU1Q7XG4gICAgICB9XG4gICAgfVxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIG5vZGU6ICVzJywgbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMjYnLCBub2RlKSA6IHZvaWQgMDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vZGVUeXBlcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3ROb2RlVHlwZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/b2JqZWN0fSBlbGVtZW50IFRoZSBSZWFjdCBlbGVtZW50IHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0gez9udW1iZXJ9IGRlYnVnSUQgVGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCwgZGVidWdJRCkge1xuICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgISh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzg0JywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpIDogdm9pZCAwO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGNvbXBvbmVudFN0YWNrSW5mbyA9ICcnO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlYnVnSUQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgY29tcG9uZW50U3RhY2tJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1JlYWN0VHlwZVNwZWM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhIGBwcmV2RWxlbWVudGAgYW5kIGBuZXh0RWxlbWVudGAsIGRldGVybWluZXMgaWYgdGhlIGV4aXN0aW5nXG4gKiBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZCBhcyBvcHBvc2VkIHRvIGJlaW5nIGRlc3Ryb3llZCBvciByZXBsYWNlZCBieSBhIG5ld1xuICogaW5zdGFuY2UuIEJvdGggYXJndW1lbnRzIGFyZSBlbGVtZW50cy4gVGhpcyBlbnN1cmVzIHRoYXQgdGhpcyBsb2dpYyBjYW5cbiAqIG9wZXJhdGUgb24gc3RhdGVsZXNzIHRyZWVzIHdpdGhvdXQgYW55IGJhY2tpbmcgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2RWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0RWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XG4gIHZhciBwcmV2RW1wdHkgPSBwcmV2RWxlbWVudCA9PT0gbnVsbCB8fCBwcmV2RWxlbWVudCA9PT0gZmFsc2U7XG4gIHZhciBuZXh0RW1wdHkgPSBuZXh0RWxlbWVudCA9PT0gbnVsbCB8fCBuZXh0RWxlbWVudCA9PT0gZmFsc2U7XG4gIGlmIChwcmV2RW1wdHkgfHwgbmV4dEVtcHR5KSB7XG4gICAgcmV0dXJuIHByZXZFbXB0eSA9PT0gbmV4dEVtcHR5O1xuICB9XG5cbiAgdmFyIHByZXZUeXBlID0gdHlwZW9mIHByZXZFbGVtZW50O1xuICB2YXIgbmV4dFR5cGUgPSB0eXBlb2YgbmV4dEVsZW1lbnQ7XG4gIGlmIChwcmV2VHlwZSA9PT0gJ3N0cmluZycgfHwgcHJldlR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnc3RyaW5nJyB8fCBuZXh0VHlwZSA9PT0gJ251bWJlcic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnb2JqZWN0JyAmJiBwcmV2RWxlbWVudC50eXBlID09PSBuZXh0RWxlbWVudC50eXBlICYmIHByZXZFbGVtZW50LmtleSA9PT0gbmV4dEVsZW1lbnQua2V5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5Q29tcG9uZW50RmFjdG9yeTtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeTogZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBlbXB0eUNvbXBvbmVudEZhY3RvcnkgPSBmYWN0b3J5O1xuICB9XG59O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgICByZXR1cm4gZW1wdHlDb21wb25lbnRGYWN0b3J5KGluc3RhbnRpYXRlKTtcbiAgfVxufTtcblxuUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24gPSBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RW1wdHlDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBudWxsO1xudmFyIHRleHRDb21wb25lbnRDbGFzcyA9IG51bGw7XG5cbnZhciBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIC8vIFRoaXMgYWNjZXB0cyBhIGNsYXNzIHRoYXQgcmVjZWl2ZXMgdGhlIHRhZyBzdHJpbmcuIFRoaXMgaXMgYSBjYXRjaCBhbGxcbiAgLy8gdGhhdCBjYW4gcmVuZGVyIGFueSBraW5kIG9mIHRhZy5cbiAgaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEgdGV4dCBjb21wb25lbnQgY2xhc3MgdGhhdCB0YWtlcyB0aGUgdGV4dCBzdHJpbmcgdG8gYmVcbiAgLy8gcmVuZGVyZWQgYXMgcHJvcHMuXG4gIGluamVjdFRleHRDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgdGV4dENvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGEgaG9zdCBpbnRlcm5hbCBjb21wb25lbnQgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNyZWF0ZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgaW50ZXJuYWwgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgIWdlbmVyaWNDb21wb25lbnRDbGFzcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBpcyBubyByZWdpc3RlcmVkIGNvbXBvbmVudCBmb3IgdGhlIHRhZyAlcycsIGVsZW1lbnQudHlwZSkgOiBfcHJvZEludmFyaWFudCgnMTExJywgZWxlbWVudC50eXBlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIG5ldyBnZW5lcmljQ29tcG9uZW50Q2xhc3MoZWxlbWVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdFRleHR9IHRleHRcbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUZvclRleHQodGV4dCkge1xuICByZXR1cm4gbmV3IHRleHRDb21wb25lbnRDbGFzcyh0ZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVGV4dENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIGNvbXBvbmVudCBpbnN0YW5jZW9mIHRleHRDb21wb25lbnRDbGFzcztcbn1cblxudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHtcbiAgY3JlYXRlSW50ZXJuYWxDb21wb25lbnQ6IGNyZWF0ZUludGVybmFsQ29tcG9uZW50LFxuICBjcmVhdGVJbnN0YW5jZUZvclRleHQ6IGNyZWF0ZUluc3RhbmNlRm9yVGV4dCxcbiAgaXNUZXh0Q29tcG9uZW50OiBpc1RleHRDb21wb25lbnQsXG4gIGluamVjdGlvbjogUmVhY3RIb3N0Q29tcG9uZW50SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SG9zdENvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmV4dERlYnVnSUQgPSAxO1xuXG5mdW5jdGlvbiBnZXROZXh0RGVidWdJRCgpIHtcbiAgcmV0dXJuIG5leHREZWJ1Z0lEKys7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmV4dERlYnVnSUQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2dldE5leHREZWJ1Z0lELmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFVuZXNjYXBlIGFuZCB1bndyYXAga2V5IGZvciBodW1hbi1yZWFkYWJsZSBkaXNwbGF5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byB1bmVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHVuZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKGtleSkge1xuICB2YXIgdW5lc2NhcGVSZWdleCA9IC8oPTB8PTIpL2c7XG4gIHZhciB1bmVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0wJzogJz0nLFxuICAgICc9Mic6ICc6J1xuICB9O1xuICB2YXIga2V5U3Vic3RyaW5nID0ga2V5WzBdID09PSAnLicgJiYga2V5WzFdID09PSAnJCcgPyBrZXkuc3Vic3RyaW5nKDIpIDoga2V5LnN1YnN0cmluZygxKTtcblxuICByZXR1cm4gKCcnICsga2V5U3Vic3RyaW5nKS5yZXBsYWNlKHVuZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiB1bmVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbn1cblxudmFyIEtleUVzY2FwZVV0aWxzID0ge1xuICBlc2NhcGU6IGVzY2FwZSxcbiAgdW5lc2NhcGU6IHVuZXNjYXBlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleUVzY2FwZVV0aWxzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50U3ltYm9sJyk7XG5cbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVGhpcyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50IHNpbmNlIHRoaXMgZmlsZSBpcyBzaGFyZWQgYmV0d2VlblxuICogaXNvbW9ycGhpYyBhbmQgcmVuZGVyZXJzLiBXZSBjb3VsZCBleHRyYWN0IHRoaXMgdG8gYVxuICpcbiAqL1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBLZXlFc2NhcGVVdGlscy5lc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8XG4gIC8vIFRoZSBmb2xsb3dpbmcgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudC4gVGhpcyBtZWFucyB3ZSBjYW4gb3B0aW1pemVcbiAgLy8gc29tZSBjaGVja3MuIFJlYWN0IEZpYmVyIGFsc28gaW5saW5lcyB0aGlzIGxvZ2ljIGZvciBzaW1pbGFyIHB1cnBvc2VzLlxuICB0eXBlID09PSAnb2JqZWN0JyAmJiBjaGlsZHJlbi4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyc7XG4gICAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgaWYgKG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lKSB7XG4gICAgICAgICAgICAgIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3QgeWV0IGZ1bGx5IHN1cHBvcnRlZC4gSXQgaXMgYW4gJyArICdleHBlcmltZW50YWwgZmVhdHVyZSB0aGF0IG1pZ2h0IGJlIHJlbW92ZWQuIENvbnZlcnQgaXQgdG8gYSAnICsgJ3NlcXVlbmNlIC8gaXRlcmFibGUgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBLZXlFc2NhcGVVdGlscy5lc2NhcGUoZW50cnlbMF0pICsgU1VCU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCAwKTtcbiAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkIG9yIHdyYXAgdGhlIG9iamVjdCB1c2luZyBjcmVhdGVGcmFnbWVudChvYmplY3QpIGZyb20gdGhlICcgKyAnUmVhY3QgYWRkLW9ucy4nO1xuICAgICAgICBpZiAoY2hpbGRyZW4uX2lzUmVhY3RFbGVtZW50KSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEl0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYW4gZWxlbWVudCBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50ICcgKyAndmVyc2lvbiBvZiBSZWFjdC4gTWFrZSBzdXJlIHRvIHVzZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSArPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiBfcHJvZEludmFyaWFudCgnMzEnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudCB0eXBlLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcblxubW9kdWxlLmV4cG9ydHMgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RWxlbWVudFN5bWJvbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gKlxuICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICogICAgICAgLi4uXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvckZuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9nZXRJdGVyYXRvckZuLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBwYXNzZWQgdGhyb3VnaCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0gez9SZWFjdENvbXBvbmVudH0gY2hpbGQgUmVhY3QgY2hpbGQgY29tcG9uZW50LlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFN0cmluZyBuYW1lIG9mIGtleSBwYXRoIHRvIGNoaWxkLlxuICogQHBhcmFtIHtudW1iZXI9fSBzZWxmRGVidWdJRCBPcHRpb25hbCBkZWJ1Z0lEIG9mIHRoZSBjdXJyZW50IGludGVybmFsIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgaWYgKHRyYXZlcnNlQ29udGV4dCAmJiB0eXBlb2YgdHJhdmVyc2VDb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXN1bHQgPSB0cmF2ZXJzZUNvbnRleHQ7XG4gICAgdmFyIGtleVVuaXF1ZSA9IHJlc3VsdFtuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWtleVVuaXF1ZSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleVVuaXF1ZSAmJiBjaGlsZCAhPSBudWxsKSB7XG4gICAgICByZXN1bHRbbmFtZV0gPSBjaGlsZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGbGF0dGVucyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuIEFueSBudWxsXG4gKiBjaGlsZHJlbiB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm4geyFvYmplY3R9IGZsYXR0ZW5lZCBjaGlsZHJlbiBrZXllZCBieSBuYW1lLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4sIHNlbGZEZWJ1Z0lEKSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gICAgICByZXR1cm4gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpO1xuICAgIH0sIHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuQ2hpbGRyZW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2ZsYXR0ZW5DaGlsZHJlbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbXTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XG4gICAgaW5pdGlhbGl6ZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCxcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcbiAgfSk7XG59XG5cbnZhciBub29wQ2FsbGJhY2tRdWV1ZSA9IHtcbiAgZW5xdWV1ZTogZnVuY3Rpb24gKCkge31cbn07XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyVG9TdGF0aWNNYXJrdXBcbiAqL1xuZnVuY3Rpb24gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbihyZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gZmFsc2U7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBuZXcgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSh0aGlzKTtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5fSBFbXB0eSBsaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBub29wQ2FsbGJhY2tRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBSZWFjdCBhc3luYyBldmVudHMuXG4gICAqL1xuICBnZXRVcGRhdGVRdWV1ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVF1ZXVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7fSxcblxuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7fSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKCkge31cbn07XG5cbl9hc3NpZ24oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHVwZGF0ZSBxdWV1ZSB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuICogSXQgZGVsZWdhdGVzIHRvIFJlYWN0VXBkYXRlUXVldWUgd2hpbGUgc2VydmVyIHJlbmRlcmluZyBpcyBpbiBwcm9ncmVzcyBhbmRcbiAqIHN3aXRjaGVzIHRvIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgY29tcGxldGVkLlxuICogQGNsYXNzIFJlYWN0U2VydmVyVXBkYXRlUXVldWVcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKi9cblxudmFyIFJlYWN0U2VydmVyVXBkYXRlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlYWN0U2VydmVyVXBkYXRlUXVldWUodHJhbnNhY3Rpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSk7XG5cbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmlzTW91bnRlZCA9IGZ1bmN0aW9uIGlzTW91bnRlZChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVDYWxsYmFjayA9IGZ1bmN0aW9uIGVucXVldWVDYWxsYmFjayhwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2socHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVGb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVSZXBsYWNlU3RhdGUocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVN0YXRlKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVNldFN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVNldFN0YXRlKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0U2VydmVyVXBkYXRlUXVldWU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIFJlYWN0VXBkYXRlcy5lbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoYXJnKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGFyZztcbiAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgdmFyIGRpc3BsYXlOYW1lID0gYXJnLmNvbnN0cnVjdG9yICYmIGFyZy5jb25zdHJ1Y3Rvci5uYW1lIHx8IHR5cGU7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYXJnKTtcbiAgaWYgKGtleXMubGVuZ3RoID4gMCAmJiBrZXlzLmxlbmd0aCA8IDIwKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lICsgJyAoa2V5czogJyArIGtleXMuam9pbignLCAnKSArICcpJztcbiAgfVxuICByZXR1cm4gZGlzcGxheU5hbWU7XG59XG5cbmZ1bmN0aW9uIGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgICAvLyBPbmx5IHdhcm4gd2hlbiB3ZSBoYXZlIGEgY2FsbGVyTmFtZS4gT3RoZXJ3aXNlIHdlIHNob3VsZCBiZSBzaWxlbnQuXG4gICAgICAvLyBXZSdyZSBwcm9iYWJseSBjYWxsaW5nIGZyb20gZW5xdWV1ZUNhbGxiYWNrLiBXZSBkb24ndCB3YW50IHRvIHdhcm5cbiAgICAgIC8vIHRoZXJlIGJlY2F1c2Ugd2UgYWxyZWFkeSB3YXJuZWQgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGxpZmVjeWNsZSBtZXRob2QuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY2FsbGVyTmFtZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjdG9yICYmIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJyVzKC4uLik6IENhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgJyArICd3aXRoaW4gYHJlbmRlcmAgb3IgYW5vdGhlciBjb21wb25lbnRcXCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgJyArICdzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgY29uc3RydWN0b3IgJyArICdzaWRlLWVmZmVjdHMgYXJlIGFuIGFudGktcGF0dGVybiwgYnV0IGNhbiBiZSBtb3ZlZCB0byAnICsgJ2Bjb21wb25lbnRXaWxsTW91bnRgLicsIGNhbGxlck5hbWUpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIGludGVybmFsSW5zdGFuY2U7XG59XG5cbi8qKlxuICogUmVhY3RVcGRhdGVRdWV1ZSBhbGxvd3MgZm9yIHN0YXRlIHVwZGF0ZXMgdG8gYmUgc2NoZWR1bGVkIGludG8gYSBsYXRlclxuICogcmVjb25jaWxpYXRpb24gc3RlcC5cbiAqL1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSB7XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgLy8gRHVyaW5nIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyIHRoaXMgd2lsbCBzdGlsbCBiZSBudWxsIGJ1dCBhZnRlclxuICAgICAgLy8gdGhhdCB3aWxsIGFsd2F5cyByZW5kZXIgdG8gc29tZXRoaW5nLiBBdCBsZWFzdCBmb3Igbm93LiBTbyB3ZSBjYW4gdXNlXG4gICAgICAvLyB0aGlzIGhhY2suXG4gICAgICByZXR1cm4gISFpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWxsZXJOYW1lIE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBjYWxsZXJOYW1lKTtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG5cbiAgICAvLyBQcmV2aW91c2x5IHdlIHdvdWxkIHRocm93IGFuIGVycm9yIGlmIHdlIGRpZG4ndCBoYXZlIGFuIGludGVybmFsXG4gICAgLy8gaW5zdGFuY2UuIFNpbmNlIHdlIHdhbnQgdG8gbWFrZSBpdCBhIG5vLW9wIGluc3RlYWQsIHdlIG1pcnJvciB0aGUgc2FtZVxuICAgIC8vIGJlaGF2aW9yIHdlIGhhdmUgaW4gb3RoZXIgZW5xdWV1ZSogbWV0aG9kcy5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gaWdub3JlIGNhbGxiYWNrcyBpbiBjb21wb25lbnRXaWxsTW91bnQuIFNlZVxuICAgIC8vIGVucXVldWVVcGRhdGVzLlxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBUaGUgY2FsbGJhY2sgaGVyZSBpcyBpZ25vcmVkIHdoZW4gc2V0U3RhdGUgaXMgY2FsbGVkIGZyb21cbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQuIEVpdGhlciBmaXggaXQgb3IgZGlzYWxsb3cgZG9pbmcgc28gY29tcGxldGVseSBpblxuICAgIC8vIGZhdm9yIG9mIGdldEluaXRpYWxTdGF0ZS4gQWx0ZXJuYXRpdmVseSwgd2UgY2FuIGRpc2FsbG93XG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGR1cmluZyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICBlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbY29tcGxldGVTdGF0ZV07XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRTdGF0ZSgpO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocGFydGlhbFN0YXRlICE9IG51bGwsICdzZXRTdGF0ZSguLi4pOiBZb3UgcGFzc2VkIGFuIHVuZGVmaW5lZCBvciBudWxsIHN0YXRlIG9iamVjdDsgJyArICdpbnN0ZWFkLCB1c2UgZm9yY2VVcGRhdGUoKS4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSB8fCAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbXSk7XG4gICAgcXVldWUucHVzaChwYXJ0aWFsU3RhdGUpO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICBlbnF1ZXVlRWxlbWVudEludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0KSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0VsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICAvLyBUT0RPOiBpbnRyb2R1Y2UgX3BlbmRpbmdDb250ZXh0IGluc3RlYWQgb2Ygc2V0dGluZyBpdCBkaXJlY3RseS5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICB2YWxpZGF0ZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICAhKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50KGNhbGxiYWNrKSkgOiBfcHJvZEludmFyaWFudCgnMTIyJywgY2FsbGVyTmFtZSwgZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50KGNhbGxiYWNrKSkgOiB2b2lkIDA7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZVF1ZXVlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdFVwZGF0ZVF1ZXVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIGN1cnJlbnQ6IG51bGwsXG5cbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG5cbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBfYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG5cbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcblxuICAgICAgY2FzZSAndGFibGUnOlxuXG4gICAgICBjYXNlICdocic6XG5cbiAgICAgIGNhc2UgJ3htcCc6XG5cbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IGluc3RhbmNlLCByZXR1cm4gYSBsaXN0IG9mIGl0cyByZWN1cnNpdmVcbiAgICogb3duZXJzLCBzdGFydGluZyBhdCB0aGUgcm9vdCBhbmQgZW5kaW5nIHdpdGggdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHZhciBmaW5kT3duZXJTdGFjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICBkbyB7XG4gICAgICBzdGFjay5wdXNoKGluc3RhbmNlKTtcbiAgICB9IHdoaWxlIChpbnN0YW5jZSA9IGluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIHN0YWNrLnJldmVyc2UoKTtcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgY2hpbGRJbnN0YW5jZSwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNoaWxkVGFnID09IG51bGwsICd2YWxpZGF0ZURPTU5lc3Rpbmc6IHdoZW4gY2hpbGRUZXh0IGlzIHBhc3NlZCwgY2hpbGRUYWcgc2hvdWxkIGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgICAgIGNoaWxkVGFnID0gJyN0ZXh0JztcbiAgICB9XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgcHJvYmxlbWF0aWMgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcblxuICAgIGlmIChwcm9ibGVtYXRpYykge1xuICAgICAgdmFyIGFuY2VzdG9yVGFnID0gcHJvYmxlbWF0aWMudGFnO1xuICAgICAgdmFyIGFuY2VzdG9ySW5zdGFuY2UgPSBwcm9ibGVtYXRpYy5pbnN0YW5jZTtcblxuICAgICAgdmFyIGNoaWxkT3duZXIgPSBjaGlsZEluc3RhbmNlICYmIGNoaWxkSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyID0gYW5jZXN0b3JJbnN0YW5jZSAmJiBhbmNlc3Rvckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIHZhciBjaGlsZE93bmVycyA9IGZpbmRPd25lclN0YWNrKGNoaWxkT3duZXIpO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJzID0gZmluZE93bmVyU3RhY2soYW5jZXN0b3JPd25lcik7XG5cbiAgICAgIHZhciBtaW5TdGFja0xlbiA9IE1hdGgubWluKGNoaWxkT3duZXJzLmxlbmd0aCwgYW5jZXN0b3JPd25lcnMubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuXG4gICAgICB2YXIgZGVlcGVzdENvbW1vbiA9IC0xO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1pblN0YWNrTGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkT3duZXJzW2ldID09PSBhbmNlc3Rvck93bmVyc1tpXSkge1xuICAgICAgICAgIGRlZXBlc3RDb21tb24gPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBVTktOT1dOID0gJyh1bmtub3duKSc7XG4gICAgICB2YXIgY2hpbGRPd25lck5hbWVzID0gY2hpbGRPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJOYW1lcyA9IGFuY2VzdG9yT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBvd25lckluZm8gPSBbXS5jb25jYXQoXG4gICAgICAvLyBJZiB0aGUgcGFyZW50IGFuZCBjaGlsZCBpbnN0YW5jZXMgaGF2ZSBhIGNvbW1vbiBvd25lciBhbmNlc3Rvciwgc3RhcnRcbiAgICAgIC8vIHdpdGggdGhhdCAtLSBvdGhlcndpc2Ugd2UganVzdCBzdGFydCB3aXRoIHRoZSBwYXJlbnQncyBvd25lcnMuXG4gICAgICBkZWVwZXN0Q29tbW9uICE9PSAtMSA/IGNoaWxkT3duZXJzW2RlZXBlc3RDb21tb25dLmdldE5hbWUoKSB8fCBVTktOT1dOIDogW10sIGFuY2VzdG9yT3duZXJOYW1lcywgYW5jZXN0b3JUYWcsXG4gICAgICAvLyBJZiB3ZSdyZSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgKG5vbi1wYXJlbnQpIGFuY2VzdHJ5LCBhZGQgJy4uLidcbiAgICAgIGludmFsaWRBbmNlc3RvciA/IFsnLi4uJ10gOiBbXSwgY2hpbGRPd25lck5hbWVzLCBjaGlsZFRhZykuam9pbignID4gJyk7XG5cbiAgICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIG93bmVySW5mbztcbiAgICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgICB2YXIgdGFnRGlzcGxheU5hbWUgPSBjaGlsZFRhZztcbiAgICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICAgIGlmICgvXFxTLy50ZXN0KGNoaWxkVGV4dCkpIHtcbiAgICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdXaGl0ZXNwYWNlIHRleHQgbm9kZXMnO1xuICAgICAgICAgIHdoaXRlc3BhY2VJbmZvID0gJyBNYWtlIHN1cmUgeW91IGRvblxcJ3QgaGF2ZSBhbnkgZXh0cmEgd2hpdGVzcGFjZSBiZXR3ZWVuIHRhZ3Mgb24gJyArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMgJyArICdTZWUgJXMuJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIHdoaXRlc3BhY2VJbmZvLCBvd25lckluZm8sIGluZm8pIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiBTZWUgJXMuJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBvd25lckluZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm87XG5cbiAgLy8gRm9yIHRlc3RpbmdcbiAgdmFsaWRhdGVET01OZXN0aW5nLmlzVGFnVmFsaWRJbkNvbnRleHQgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL3ZhbGlkYXRlRE9NTmVzdGluZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIFJlYWN0RE9NRW1wdHlDb21wb25lbnQgPSBmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgLy8gUmVhY3RDb21wb3NpdGVDb21wb25lbnQgdXNlcyB0aGlzOlxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIC8vIFJlYWN0RE9NQ29tcG9uZW50VHJlZSB1c2VzIHRoZXNlOlxuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG4gIHRoaXMuX2RvbUlEID0gMDtcbn07XG5fYXNzaWduKFJlYWN0RE9NRW1wdHlDb21wb25lbnQucHJvdG90eXBlLCB7XG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdmFyIGRvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX2RvbUlEID0gZG9tSUQ7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBub2RlVmFsdWUgPSAnIHJlYWN0LWVtcHR5OiAnICsgdGhpcy5fZG9tSUQgKyAnICc7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgbm9kZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChub2RlVmFsdWUpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBub2RlKTtcbiAgICAgIHJldHVybiBET01MYXp5VHJlZShub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlJ2QgaW5zZXJ0IGEgY29tbWVudCBub2RlLCBidXQgc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvblxuICAgICAgICAvLyB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksIHdlIGNhbiBzaW1wbHkgcmV0dXJuXG4gICAgICAgIC8vIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnPCEtLScgKyBub2RlVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHt9LFxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01FbXB0eUNvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01FbXB0eUNvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgQSBhbmQgQiwgb3IgbnVsbCBpZiB0aGV5IGFyZSBpblxuICogZGlmZmVyZW50IHRyZWVzLlxuICovXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzMzJykgOiB2b2lkIDA7XG5cbiAgdmFyIGRlcHRoQSA9IDA7XG4gIGZvciAodmFyIHRlbXBBID0gaW5zdEE7IHRlbXBBOyB0ZW1wQSA9IHRlbXBBLl9ob3N0UGFyZW50KSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IHRlbXBCLl9ob3N0UGFyZW50KSB7XG4gICAgZGVwdGhCKys7XG4gIH1cblxuICAvLyBJZiBBIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEEgLSBkZXB0aEIgPiAwKSB7XG4gICAgaW5zdEEgPSBpbnN0QS5faG9zdFBhcmVudDtcbiAgICBkZXB0aEEtLTtcbiAgfVxuXG4gIC8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBpbnN0QiA9IGluc3RCLl9ob3N0UGFyZW50O1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCKSB7XG4gICAgICByZXR1cm4gaW5zdEE7XG4gICAgfVxuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5mdW5jdGlvbiBpc0FuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RBKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2lzQW5jZXN0b3I6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzUnKSA6IHZvaWQgMDtcblxuICB3aGlsZSAoaW5zdEIpIHtcbiAgICBpZiAoaW5zdEIgPT09IGluc3RBKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwYXJlbnQgaW5zdGFuY2Ugb2YgdGhlIHBhc3NlZC1pbiBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCkge1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3QpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldFBhcmVudEluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM2JykgOiB2b2lkIDA7XG5cbiAgcmV0dXJuIGluc3QuX2hvc3RQYXJlbnQ7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIGk7XG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhbaV0sICdjYXB0dXJlZCcsIGFyZyk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoW2ldLCAnYnViYmxlZCcsIGFyZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAqXG4gKiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlIG5vdGhpbmdcbiAqIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuICB2YXIgcGF0aEZyb20gPSBbXTtcbiAgd2hpbGUgKGZyb20gJiYgZnJvbSAhPT0gY29tbW9uKSB7XG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcbiAgICBmcm9tID0gZnJvbS5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0byAmJiB0byAhPT0gY29tbW9uKSB7XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gdG8uX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoRnJvbS5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhGcm9tW2ldLCAnYnViYmxlZCcsIGFyZ0Zyb20pO1xuICB9XG4gIGZvciAoaSA9IHBhdGhUby5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFRvW2ldLCAnY2FwdHVyZWQnLCBhcmdUbyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQW5jZXN0b3I6IGlzQW5jZXN0b3IsXG4gIGdldExvd2VzdENvbW1vbkFuY2VzdG9yOiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcixcbiAgZ2V0UGFyZW50SW5zdGFuY2U6IGdldFBhcmVudEluc3RhbmNlLFxuICB0cmF2ZXJzZVR3b1BoYXNlOiB0cmF2ZXJzZVR3b1BoYXNlLFxuICB0cmF2ZXJzZUVudGVyTGVhdmU6IHRyYXZlcnNlRW50ZXJMZWF2ZVxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGJldHdlZW4gY29tbWVudCBub2RlcyBzbyB0aGF0IHRoZXlcbiAqIGNhbiB1bmRlcmdvIHRoZSBzYW1lIHJlY29uY2lsaWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlbGVtZW50cy5cbiAqXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSByZXByZXNlbnRpbmcgUmVhY3QgY29tcG9uZW50cyBpbiB0aGUgRE9NIHdpdGggdGV4dCBub2Rlcy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdENvbXBvbmVudFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gdGV4dDtcbiAgdGhpcy5fc3RyaW5nVGV4dCA9ICcnICsgdGV4dDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG5cbiAgLy8gUHJvcGVydGllc1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX21vdW50SW5kZXggPSAwO1xuICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG51bGw7XG4gIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG59O1xuXG5fYXNzaWduKFJlYWN0RE9NVGV4dENvbXBvbmVudC5wcm90b3R5cGUsIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS4gVGhpcyBub2RlIGlzIG5vdCBpbnRlbmRlZCB0byBoYXZlXG4gICAqIGFueSBmZWF0dXJlcyBiZXNpZGVzIGNvbnRhaW5pbmcgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xuICAgICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudEluZm8pIHtcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIHRoaXMuX3N0cmluZ1RleHQsIHRoaXMsIHBhcmVudEluZm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB2YXIgb3BlbmluZ1ZhbHVlID0gJyByZWFjdC10ZXh0OiAnICsgZG9tSUQgKyAnICc7XG4gICAgdmFyIGNsb3NpbmdWYWx1ZSA9ICcgL3JlYWN0LXRleHQgJztcbiAgICB0aGlzLl9kb21JRCA9IGRvbUlEO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KG9wZW5pbmdWYWx1ZSk7XG4gICAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY2xvc2luZ1ZhbHVlKTtcbiAgICAgIHZhciBsYXp5VHJlZSA9IERPTUxhenlUcmVlKG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKTtcbiAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIERPTUxhenlUcmVlKG9wZW5pbmdDb21tZW50KSk7XG4gICAgICBpZiAodGhpcy5fc3RyaW5nVGV4dCkge1xuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuX3N0cmluZ1RleHQpKSk7XG4gICAgICB9XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShjbG9zaW5nQ29tbWVudCkpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBvcGVuaW5nQ29tbWVudCk7XG4gICAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IGNsb3NpbmdDb21tZW50O1xuICAgICAgcmV0dXJuIGxhenlUcmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXNjYXBlZFRleHQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGhpcy5fc3RyaW5nVGV4dCk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgZm9yIHRoZSByZWFzb25zIHN0YXRlZFxuICAgICAgICAvLyBhYm92ZSwgYnV0IHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb24gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyXG4gICAgICAgIC8vIChzdGF0aWMgcGFnZXMpLCB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGUgdGV4dCBhcyBpdCBpcy5cbiAgICAgICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzwhLS0nICsgb3BlbmluZ1ZhbHVlICsgJy0tPicgKyBlc2NhcGVkVGV4dCArICc8IS0tJyArIGNsb3NpbmdWYWx1ZSArICctLT4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGNvbXBvbmVudCBieSB1cGRhdGluZyB0aGUgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gbmV4dFRleHQgVGhlIG5leHQgdGV4dCBjb250ZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dFRleHQsIHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKG5leHRUZXh0ICE9PSB0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0VGV4dDtcbiAgICAgIHZhciBuZXh0U3RyaW5nVGV4dCA9ICcnICsgbmV4dFRleHQ7XG4gICAgICBpZiAobmV4dFN0cmluZ1RleHQgIT09IHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgLy8gVE9ETzogU2F2ZSB0aGlzIGFzIHBlbmRpbmcgcHJvcHMgYW5kIHVzZSBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnlcbiAgICAgICAgLy8gYW5kL29yIHVwZGF0ZUNvbXBvbmVudCB0byBkbyB0aGUgYWN0dWFsIHVwZGF0ZSBmb3IgY29uc2lzdGVuY3kgd2l0aFxuICAgICAgICAvLyBvdGhlciBjb21wb25lbnQgdHlwZXM/XG4gICAgICAgIHRoaXMuX3N0cmluZ1RleHQgPSBuZXh0U3RyaW5nVGV4dDtcbiAgICAgICAgdmFyIGNvbW1lbnROb2RlcyA9IHRoaXMuZ2V0SG9zdE5vZGUoKTtcbiAgICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnJlcGxhY2VEZWxpbWl0ZWRUZXh0KGNvbW1lbnROb2Rlc1swXSwgY29tbWVudE5vZGVzWzFdLCBuZXh0U3RyaW5nVGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvc3ROb2RlID0gdGhpcy5fY29tbWVudE5vZGVzO1xuICAgIGlmIChob3N0Tm9kZSkge1xuICAgICAgcmV0dXJuIGhvc3ROb2RlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Nsb3NpbmdDb21tZW50KSB7XG4gICAgICB2YXIgb3BlbmluZ0NvbW1lbnQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICAgIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAhKG5vZGUgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBjbG9zaW5nIGNvbW1lbnQgZm9yIHRleHQgY29tcG9uZW50ICVzJywgdGhpcy5fZG9tSUQpIDogX3Byb2RJbnZhcmlhbnQoJzY3JywgdGhpcy5fZG9tSUQpIDogdm9pZCAwO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyAvcmVhY3QtdGV4dCAnKSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBub2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBob3N0Tm9kZSA9IFt0aGlzLl9ob3N0Tm9kZSwgdGhpcy5fY2xvc2luZ0NvbW1lbnRdO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IGhvc3ROb2RlO1xuICAgIHJldHVybiBob3N0Tm9kZTtcbiAgfSxcblxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dENvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcblxudmFyIFJFU0VUX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBGTFVTSF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBSZWFjdFVwZGF0ZXMuZmx1c2hCYXRjaGVkVXBkYXRlcy5iaW5kKFJlYWN0VXBkYXRlcylcbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtGTFVTSF9CQVRDSEVEX1VQREFURVMsIFJFU0VUX0JBVENIRURfVVBEQVRFU107XG5cbmZ1bmN0aW9uIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xufVxuXG5fYXNzaWduKFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH1cbn0pO1xuXG52YXIgdHJhbnNhY3Rpb24gPSBuZXcgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCk7XG5cbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0ge1xuICBpc0JhdGNoaW5nVXBkYXRlczogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGluIGEgY29udGV4dCB3aXRoaW4gd2hpY2ggY2FsbHMgdG8gYHNldFN0YXRlYFxuICAgKiBhbmQgZnJpZW5kcyBhcmUgYmF0Y2hlZCBzdWNoIHRoYXQgY29tcG9uZW50cyBhcmVuJ3QgdXBkYXRlZCB1bm5lY2Vzc2FyaWx5LlxuICAgKi9cbiAgYmF0Y2hlZFVwZGF0ZXM6IGZ1bmN0aW9uIChjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICAgIHZhciBhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcztcblxuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuXG4gICAgLy8gVGhlIGNvZGUgaXMgd3JpdHRlbiB0aGlzIHdheSB0byBhdm9pZCBleHRyYSBhbGxvY2F0aW9uc1xuICAgIGlmIChhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soYSwgYiwgYywgZCwgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbi5wZXJmb3JtKGNhbGxiYWNrLCBudWxsLCBhLCBiLCBjLCBkLCBlKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbicpO1xuXG4vKipcbiAqIEZpbmQgdGhlIGRlZXBlc3QgUmVhY3QgY29tcG9uZW50IGNvbXBsZXRlbHkgY29udGFpbmluZyB0aGUgcm9vdCBvZiB0aGVcbiAqIHBhc3NlZC1pbiBpbnN0YW5jZSAoZm9yIHVzZSB3aGVuIGVudGlyZSBSZWFjdCB0cmVlcyBhcmUgbmVzdGVkIHdpdGhpbiBlYWNoXG4gKiBvdGhlcikuIElmIFJlYWN0IHRyZWVzIGFyZSBub3QgbmVzdGVkLCByZXR1cm5zIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnQoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdC5faG9zdFBhcmVudCkge1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciByb290Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICB2YXIgY29udGFpbmVyID0gcm9vdE5vZGUucGFyZW50Tm9kZTtcbiAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIpO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHRoaXMudG9wTGV2ZWxUeXBlID0gdG9wTGV2ZWxUeXBlO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gIHRoaXMuYW5jZXN0b3JzID0gW107XG59XG5fYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gYW5jZXN0b3IgJiYgZmluZFBhcmVudChhbmNlc3Rvcik7XG4gIH0gd2hpbGUgKGFuY2VzdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldEluc3QgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkID0gISFlbmFibGVkO1xuICB9LFxuXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3RlbihlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIG1vbml0b3JTY3JvbGxWYWx1ZTogZnVuY3Rpb24gKHJlZnJlc2gpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY3JvbGxWYWx1ZU1vbml0b3IuYmluZChudWxsLCByZWZyZXNoKTtcbiAgICBFdmVudExpc3RlbmVyLmxpc3Rlbih3aW5kb3csICdzY3JvbGwnLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIVJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib29rS2VlcGluZyA9IFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5nZXRQb29sZWQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5yZWxlYXNlKGJvb2tLZWVwaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudExpc3RlbmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50TGlzdGVuZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXG4gKiBuYXR1cmUgb2YgcGxhdGZvcm0uXG4gKi9cbnZhciBFdmVudExpc3RlbmVyID0ge1xuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBidWJibGUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGNhcHR1cmU6IGZ1bmN0aW9uIGNhcHR1cmUodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHQoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHN1cHBsaWVkIGVsZW1lbnQgb3Igd2luZG93LlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWVzIGFyZSB1bmJvdW5kZWQsIHVubGlrZSBgZ2V0U2Nyb2xsUG9zaXRpb25gLiBUaGlzIG1lYW5zIHRoZXlcbiAqIG1heSBiZSBuZWdhdGl2ZSBvciBleGNlZWQgdGhlIGVsZW1lbnQgYm91bmRhcmllcyAod2hpY2ggaXMgcG9zc2libGUgdXNpbmdcbiAqIGluZXJ0aWFsIHNjcm9sbGluZykuXG4gKlxuICogQHBhcmFtIHtET01XaW5kb3d8RE9NRWxlbWVudH0gc2Nyb2xsYWJsZVxuICogQHJldHVybiB7b2JqZWN0fSBNYXAgd2l0aCBgeGAgYW5kIGB5YCBrZXlzLlxuICovXG5cbmZ1bmN0aW9uIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGUpIHtcbiAgaWYgKHNjcm9sbGFibGUgPT09IHdpbmRvdykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBzY3JvbGxhYmxlLnNjcm9sbExlZnQsXG4gICAgeTogc2Nyb2xsYWJsZS5zY3JvbGxUb3BcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEhvc3RDb21wb25lbnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgUmVhY3RJbmplY3Rpb24gPSB7XG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5pbmplY3Rpb24sXG4gIERPTVByb3BlcnR5OiBET01Qcm9wZXJ0eS5pbmplY3Rpb24sXG4gIEVtcHR5Q29tcG9uZW50OiBSZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5VdGlsczogRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24sXG4gIEV2ZW50RW1pdHRlcjogUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmluamVjdGlvbixcbiAgSG9zdENvbXBvbmVudDogUmVhY3RIb3N0Q29tcG9uZW50LmluamVjdGlvbixcbiAgVXBkYXRlczogUmVhY3RVcGRhdGVzLmluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluamVjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbmplY3Rpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0LCB3aGVuIHBvc3NpYmxlLCB0aGUgc2VsZWN0aW9uIHJhbmdlIChjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dFxuICogaW5wdXQpIGlzIG5vdCBkaXN0dXJiZWQgYnkgcGVyZm9ybWluZyB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBTRUxFQ1RJT05fUkVTVE9SQVRJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFNlbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24sXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsIFNlbGVjdGlvbiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGBpbml0aWFsaXplYC5cbiAgICovXG4gIGNsb3NlOiBSZWFjdElucHV0U2VsZWN0aW9uLnJlc3RvcmVTZWxlY3Rpb25cbn07XG5cbi8qKlxuICogU3VwcHJlc3NlcyBldmVudHMgKGJsdXIvZm9jdXMpIHRoYXQgY291bGQgYmUgaW5hZHZlcnRlbnRseSBkaXNwYXRjaGVkIGR1ZSB0b1xuICogaGlnaCBsZXZlbCBET00gbWFuaXB1bGF0aW9ucyAobGlrZSB0ZW1wb3JhcmlseSByZW1vdmluZyBhIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAqIERPTSkuXG4gKi9cbnZhciBFVkVOVF9TVVBQUkVTU0lPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbmFibGVkIHN0YXR1cyBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmVcbiAgICogdGhlIHJlY29uY2lsaWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50bHlFbmFibGVkID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmlzRW5hYmxlZCgpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICByZXR1cm4gY3VycmVudGx5RW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2aW91c2x5RW5hYmxlZCBFbmFibGVkIHN0YXR1cyBvZlxuICAgKiAgIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZSB0aGUgcmVjb25jaWxpYXRpb24gb2NjdXJyZWQuIGBjbG9zZWBcbiAgICogICByZXN0b3JlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKHByZXZpb3VzbHlFbmFibGVkKSB7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQocHJldmlvdXNseUVuYWJsZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgcXVldWUgZm9yIGNvbGxlY3RpbmcgYGNvbXBvbmVudERpZE1vdW50YCBhbmRcbiAqIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZnRlciBET00gaXMgZmx1c2hlZCwgaW52b2tlIGFsbCByZWdpc3RlcmVkIGBvbkRPTVJlYWR5YCBjYWxsYmFja3MuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5Lm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbU0VMRUNUSU9OX1JFU1RPUkFUSU9OLCBFVkVOVF9TVVBQUkVTU0lPTiwgT05fRE9NX1JFQURZX1FVRVVFSU5HXTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XG4gICAgaW5pdGlhbGl6ZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCxcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcbiAgfSk7XG59XG5cbi8qKlxuICogQ3VycmVudGx5OlxuICogLSBUaGUgb3JkZXIgdGhhdCB0aGVzZSBhcmUgbGlzdGVkIGluIHRoZSB0cmFuc2FjdGlvbiBpcyBjcml0aWNhbDpcbiAqIC0gU3VwcHJlc3NlcyBldmVudHMuXG4gKiAtIFJlc3RvcmVzIHNlbGVjdGlvbiByYW5nZS5cbiAqXG4gKiBGdXR1cmU6XG4gKiAtIFJlc3RvcmUgZG9jdW1lbnQvb3ZlcmZsb3cgc2Nyb2xsIHBvc2l0aW9ucyB0aGF0IHdlcmUgdW5pbnRlbnRpb25hbGx5XG4gKiAgIG1vZGlmaWVkIHZpYSBET00gaW5zZXJ0aW9ucyBhYm92ZSB0aGUgdG9wIHZpZXdwb3J0IGJvdW5kYXJ5LlxuICogLSBJbXBsZW1lbnQvaW50ZWdyYXRlIHdpdGggY3VzdG9taXplZCBjb25zdHJhaW50IGJhc2VkIGxheW91dCBzeXN0ZW0gYW5kIGtlZXBcbiAqICAgdHJhY2sgb2Ygd2hpY2ggZGltZW5zaW9ucyBtdXN0IGJlIHJlbWVhc3VyZWQuXG4gKlxuICogQGNsYXNzIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbih1c2VDcmVhdGVFbGVtZW50KSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgLy8gT25seSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcmVhbGx5IG5lZWRzIHRoaXMgb3B0aW9uIChzZWVcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nYCksIGJ1dCBzZXJ2ZXItc2lkZSB1c2VzXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uYCBpbnN0ZWFkLiBUaGlzIG9wdGlvbiBpcyBoZXJlIHNvIHRoYXQgaXQnc1xuICAvLyBhY2Nlc3NpYmxlIGFuZCBkZWZhdWx0cyB0byBmYWxzZSB3aGVuIGBSZWFjdERPTUNvbXBvbmVudGAgYW5kXG4gIC8vIGBSZWFjdERPTVRleHRDb21wb25lbnRgIGNoZWNrcyBpdCBpbiBgbW91bnRDb21wb25lbnRgLmBcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZhbHNlO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSB1c2VDcmVhdGVFbGVtZW50O1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXk8b2JqZWN0Pn0gTGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKiAgIFRPRE86IGNvbnZlcnQgdG8gYXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgUmVhY3QgYXN5bmMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0VXBkYXRlUXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RVcGRhdGVRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU2F2ZSBjdXJyZW50IHRyYW5zYWN0aW9uIHN0YXRlIC0tIGlmIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGlzIG1ldGhvZCBpc1xuICAgKiBwYXNzZWQgdG8gYHJvbGxiYWNrYCwgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcmVzZXQgdG8gdGhhdCBzdGF0ZS5cbiAgICovXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZWFjdE1vdW50UmVhZHkgaXMgdGhlIG91ciBvbmx5IHN0YXRlZnVsIHdyYXBwZXJcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHkuY2hlY2twb2ludCgpO1xuICB9LFxuXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAoY2hlY2twb2ludCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbl9hc3NpZ24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdGlvbicpO1xuXG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSB7XG5cbiAgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbiAgfSxcblxuICBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgICAgc2VsZWN0aW9uUmFuZ2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAgICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gICAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICAgKi9cbiAgcmVzdG9yZVNlbGVjdGlvbjogZnVuY3Rpb24gKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICAgIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBpZiAoUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5zZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgICB9XG4gICAgICBmb2N1c05vZGUocHJpb3JGb2N1c2VkRWxlbSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAgICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gICAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gICAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgc2VsZWN0aW9uO1xuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgLy8gSUU4IGlucHV0LlxuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAvLyBUaGVyZSBjYW4gb25seSBiZSBvbmUgc2VsZWN0aW9uIHBlciBkb2N1bWVudCBpbiBJRSwgc28gaXQgbXVzdFxuICAgICAgLy8gYmUgaW4gb3VyIGVsZW1lbnQuXG4gICAgICBpZiAocmFuZ2UucGFyZW50RWxlbWVudCgpID09PSBpbnB1dCkge1xuICAgICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgICAgc3RhcnQ6IC1yYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpLFxuICAgICAgICAgIGVuZDogLXJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0gUmVhY3RET01TZWxlY3Rpb24uZ2V0T2Zmc2V0cyhpbnB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gICAqIHRoZSBpbnB1dC5cbiAgICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICAgKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gICAqL1xuICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCwgb2Zmc2V0cykge1xuICAgIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IG9mZnNldHMuZW5kO1xuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RE9NU2VsZWN0aW9uLnNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdElucHV0U2VsZWN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKCcuL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQnKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogV2hpbGUgYGlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgb24gdGhlIFNlbGVjdGlvbiBvYmplY3QgYW5kIGBjb2xsYXBzZWRgXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIFJhbmdlIG9iamVjdCwgSUUxMSBzb21ldGltZXMgZ2V0cyB0aGVtIHdyb25nLlxuICogSWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhbmQgb2Zmc2V0cyBhcmUgdGhlIHNhbWUsIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGFwc2VkKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICByZXR1cm4gYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvck9mZnNldCA9PT0gZm9jdXNPZmZzZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhcHByb3ByaWF0ZSBhbmNob3IgYW5kIGZvY3VzIG5vZGUvb2Zmc2V0IHBhaXJzIGZvciBJRS5cbiAqXG4gKiBUaGUgY2F0Y2ggaGVyZSBpcyB0aGF0IElFJ3Mgc2VsZWN0aW9uIEFQSSBkb2Vzbid0IHByb3ZpZGUgaW5mb3JtYXRpb25cbiAqIGFib3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBmb3J3YXJkIG9yIGJhY2t3YXJkLCBzbyB3ZSBoYXZlIHRvXG4gKiBiZWhhdmUgYXMgdGhvdWdoIGl0J3MgYWx3YXlzIGZvcndhcmQuXG4gKlxuICogSUUgdGV4dCBkaWZmZXJzIGZyb20gbW9kZXJuIHNlbGVjdGlvbiBpbiB0aGF0IGl0IGJlaGF2ZXMgYXMgdGhvdWdoXG4gKiBibG9jayBlbGVtZW50cyBlbmQgd2l0aCBhIG5ldyBsaW5lLiBUaGlzIG1lYW5zIGNoYXJhY3RlciBvZmZzZXRzIHdpbGxcbiAqIGRpZmZlciBiZXR3ZWVuIHRoZSB0d28gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SUVPZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LnNlbGVjdGlvbjtcbiAgdmFyIHNlbGVjdGVkUmFuZ2UgPSBzZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIHNlbGVjdGVkTGVuZ3RoID0gc2VsZWN0ZWRSYW5nZS50ZXh0Lmxlbmd0aDtcblxuICAvLyBEdXBsaWNhdGUgc2VsZWN0aW9uIHNvIHdlIGNhbiBtb3ZlIHJhbmdlIHdpdGhvdXQgYnJlYWtpbmcgdXNlciBzZWxlY3Rpb24uXG4gIHZhciBmcm9tU3RhcnQgPSBzZWxlY3RlZFJhbmdlLmR1cGxpY2F0ZSgpO1xuICBmcm9tU3RhcnQubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIGZyb21TdGFydC5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHNlbGVjdGVkUmFuZ2UpO1xuXG4gIHZhciBzdGFydE9mZnNldCA9IGZyb21TdGFydC50ZXh0Lmxlbmd0aDtcbiAgdmFyIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgc2VsZWN0ZWRMZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnRPZmZzZXQsXG4gICAgZW5kOiBlbmRPZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIHZhciBjdXJyZW50UmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICAvLyBJbiBGaXJlZm94LCByYW5nZS5zdGFydENvbnRhaW5lciBhbmQgcmFuZ2UuZW5kQ29udGFpbmVyIGNhbiBiZSBcImFub255bW91c1xuICAvLyBkaXZzXCIsIGUuZy4gdGhlIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzXG4gIC8vIGRpdnMgZG8gbm90IHNlZW0gdG8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkXG4gIC8vIGVycm9yXCIgaWYgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlXG4gIC8vIHdheSB0byBhdm9pZCBlcnJvcmluZyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3JcbiAgLy8gbm9uLWFub255bW91cyBkaXZzIGFuZCBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlO1xuICAgIGN1cnJlbnRSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XG5cbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcblxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRTdGFydChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZHVwbGljYXRlKCk7XG4gIHZhciBzdGFydCwgZW5kO1xuXG4gIGlmIChvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKG9mZnNldHMuc3RhcnQgPiBvZmZzZXRzLmVuZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gIH1cblxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gIHJhbmdlLnNlbGVjdCgpO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZXJuT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VJRU9mZnNldHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ3NlbGVjdGlvbicgaW4gZG9jdW1lbnQgJiYgISgnZ2V0U2VsZWN0aW9uJyBpbiB3aW5kb3cpO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIGdldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IGdldElFT2Zmc2V0cyA6IGdldE1vZGVybk9mZnNldHMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICAgKi9cbiAgc2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gc2V0SUVPZmZzZXRzIDogc2V0TW9kZXJuT2Zmc2V0c1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2libGluZ05vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbnZhciBpc1RleHROb2RlID0gcmVxdWlyZSgnLi9pc1RleHROb2RlJyk7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZSkge1xuICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xuICAgIHJldHVybiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJ2NvbnRhaW5zJyBpbiBvdXRlck5vZGUpIHtcbiAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL2lzTm9kZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KCkgLyo/RE9NRWxlbWVudCove1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTlMgPSB7XG4gIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gIHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbn07XG5cbi8vIFdlIHVzZSBhdHRyaWJ1dGVzIGZvciBldmVyeXRoaW5nIFNWRyBzbyBsZXQncyBhdm9pZCBzb21lIGR1cGxpY2F0aW9uIGFuZCBydW5cbi8vIGNvZGUgaW5zdGVhZC5cbi8vIFRoZSBmb2xsb3dpbmcgYXJlIGFsbCBzcGVjaWZpZWQgaW4gdGhlIEhUTUwgY29uZmlnIGFscmVhZHkgc28gd2UgZXhjbHVkZSBoZXJlLlxuLy8gLSBjbGFzcyAoYXMgY2xhc3NOYW1lKVxuLy8gLSBjb2xvclxuLy8gLSBoZWlnaHRcbi8vIC0gaWRcbi8vIC0gbGFuZ1xuLy8gLSBtYXhcbi8vIC0gbWVkaWFcbi8vIC0gbWV0aG9kXG4vLyAtIG1pblxuLy8gLSBuYW1lXG4vLyAtIHN0eWxlXG4vLyAtIHRhcmdldFxuLy8gLSB0eXBlXG4vLyAtIHdpZHRoXG52YXIgQVRUUlMgPSB7XG4gIGFjY2VudEhlaWdodDogJ2FjY2VudC1oZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAwLFxuICBhZGRpdGl2ZTogMCxcbiAgYWxpZ25tZW50QmFzZWxpbmU6ICdhbGlnbm1lbnQtYmFzZWxpbmUnLFxuICBhbGxvd1Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAwLFxuICBhbXBsaXR1ZGU6IDAsXG4gIGFyYWJpY0Zvcm06ICdhcmFiaWMtZm9ybScsXG4gIGFzY2VudDogMCxcbiAgYXR0cmlidXRlTmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGVUeXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9SZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAwLFxuICBiYXNlRnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VQcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYXNlbGluZVNoaWZ0OiAnYmFzZWxpbmUtc2hpZnQnLFxuICBiYm94OiAwLFxuICBiZWdpbjogMCxcbiAgYmlhczogMCxcbiAgYnk6IDAsXG4gIGNhbGNNb2RlOiAnY2FsY01vZGUnLFxuICBjYXBIZWlnaHQ6ICdjYXAtaGVpZ2h0JyxcbiAgY2xpcDogMCxcbiAgY2xpcFBhdGg6ICdjbGlwLXBhdGgnLFxuICBjbGlwUnVsZTogJ2NsaXAtcnVsZScsXG4gIGNsaXBQYXRoVW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY29sb3JJbnRlcnBvbGF0aW9uOiAnY29sb3ItaW50ZXJwb2xhdGlvbicsXG4gIGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnM6ICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLFxuICBjb2xvclByb2ZpbGU6ICdjb2xvci1wcm9maWxlJyxcbiAgY29sb3JSZW5kZXJpbmc6ICdjb2xvci1yZW5kZXJpbmcnLFxuICBjb250ZW50U2NyaXB0VHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudFN0eWxlVHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6IDAsXG4gIGN4OiAwLFxuICBjeTogMCxcbiAgZDogMCxcbiAgZGVjZWxlcmF0ZTogMCxcbiAgZGVzY2VudDogMCxcbiAgZGlmZnVzZUNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAwLFxuICBkaXNwbGF5OiAwLFxuICBkaXZpc29yOiAwLFxuICBkb21pbmFudEJhc2VsaW5lOiAnZG9taW5hbnQtYmFzZWxpbmUnLFxuICBkdXI6IDAsXG4gIGR4OiAwLFxuICBkeTogMCxcbiAgZWRnZU1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogMCxcbiAgZW5hYmxlQmFja2dyb3VuZDogJ2VuYWJsZS1iYWNrZ3JvdW5kJyxcbiAgZW5kOiAwLFxuICBleHBvbmVudDogMCxcbiAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAwLFxuICBmaWxsT3BhY2l0eTogJ2ZpbGwtb3BhY2l0eScsXG4gIGZpbGxSdWxlOiAnZmlsbC1ydWxlJyxcbiAgZmlsdGVyOiAwLFxuICBmaWx0ZXJSZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJVbml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RDb2xvcjogJ2Zsb29kLWNvbG9yJyxcbiAgZmxvb2RPcGFjaXR5OiAnZmxvb2Qtb3BhY2l0eScsXG4gIGZvY3VzYWJsZTogMCxcbiAgZm9udEZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgZm9udFNpemU6ICdmb250LXNpemUnLFxuICBmb250U2l6ZUFkanVzdDogJ2ZvbnQtc2l6ZS1hZGp1c3QnLFxuICBmb250U3RyZXRjaDogJ2ZvbnQtc3RyZXRjaCcsXG4gIGZvbnRTdHlsZTogJ2ZvbnQtc3R5bGUnLFxuICBmb250VmFyaWFudDogJ2ZvbnQtdmFyaWFudCcsXG4gIGZvbnRXZWlnaHQ6ICdmb250LXdlaWdodCcsXG4gIGZvcm1hdDogMCxcbiAgZnJvbTogMCxcbiAgZng6IDAsXG4gIGZ5OiAwLFxuICBnMTogMCxcbiAgZzI6IDAsXG4gIGdseXBoTmFtZTogJ2dseXBoLW5hbWUnLFxuICBnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbDogJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLFxuICBnbHlwaE9yaWVudGF0aW9uVmVydGljYWw6ICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsXG4gIGdseXBoUmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudFRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnRVbml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAwLFxuICBob3JpekFkdlg6ICdob3Jpei1hZHYteCcsXG4gIGhvcml6T3JpZ2luWDogJ2hvcml6LW9yaWdpbi14JyxcbiAgaWRlb2dyYXBoaWM6IDAsXG4gIGltYWdlUmVuZGVyaW5nOiAnaW1hZ2UtcmVuZGVyaW5nJyxcbiAgJ2luJzogMCxcbiAgaW4yOiAwLFxuICBpbnRlcmNlcHQ6IDAsXG4gIGs6IDAsXG4gIGsxOiAwLFxuICBrMjogMCxcbiAgazM6IDAsXG4gIGs0OiAwLFxuICBrZXJuZWxNYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWxVbml0TGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6IDAsXG4gIGtleVBvaW50czogJ2tleVBvaW50cycsXG4gIGtleVNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5VGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aEFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlclNwYWNpbmc6ICdsZXR0ZXItc3BhY2luZycsXG4gIGxpZ2h0aW5nQ29sb3I6ICdsaWdodGluZy1jb2xvcicsXG4gIGxpbWl0aW5nQ29uZUFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogMCxcbiAgbWFya2VyRW5kOiAnbWFya2VyLWVuZCcsXG4gIG1hcmtlck1pZDogJ21hcmtlci1taWQnLFxuICBtYXJrZXJTdGFydDogJ21hcmtlci1zdGFydCcsXG4gIG1hcmtlckhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlclVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJXaWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogMCxcbiAgbWFza0NvbnRlbnRVbml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrVW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6IDAsXG4gIG1vZGU6IDAsXG4gIG51bU9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAwLFxuICBvcGFjaXR5OiAwLFxuICBvcGVyYXRvcjogMCxcbiAgb3JkZXI6IDAsXG4gIG9yaWVudDogMCxcbiAgb3JpZW50YXRpb246IDAsXG4gIG9yaWdpbjogMCxcbiAgb3ZlcmZsb3c6IDAsXG4gIG92ZXJsaW5lUG9zaXRpb246ICdvdmVybGluZS1wb3NpdGlvbicsXG4gIG92ZXJsaW5lVGhpY2tuZXNzOiAnb3ZlcmxpbmUtdGhpY2tuZXNzJyxcbiAgcGFpbnRPcmRlcjogJ3BhaW50LW9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZS0xJyxcbiAgcGF0aExlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuQ29udGVudFVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm5UcmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVyblVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlckV2ZW50czogJ3BvaW50ZXItZXZlbnRzJyxcbiAgcG9pbnRzOiAwLFxuICBwb2ludHNBdFg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNBdFk6ICdwb2ludHNBdFknLFxuICBwb2ludHNBdFo6ICdwb2ludHNBdFonLFxuICBwcmVzZXJ2ZUFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlQXNwZWN0UmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZlVW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHI6IDAsXG4gIHJhZGl1czogMCxcbiAgcmVmWDogJ3JlZlgnLFxuICByZWZZOiAncmVmWScsXG4gIHJlbmRlcmluZ0ludGVudDogJ3JlbmRlcmluZy1pbnRlbnQnLFxuICByZXBlYXRDb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0RHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRFeHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRGZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXN0YXJ0OiAwLFxuICByZXN1bHQ6IDAsXG4gIHJvdGF0ZTogMCxcbiAgcng6IDAsXG4gIHJ5OiAwLFxuICBzY2FsZTogMCxcbiAgc2VlZDogMCxcbiAgc2hhcGVSZW5kZXJpbmc6ICdzaGFwZS1yZW5kZXJpbmcnLFxuICBzbG9wZTogMCxcbiAgc3BhY2luZzogMCxcbiAgc3BlY3VsYXJDb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhckV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAwLFxuICBzcHJlYWRNZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydE9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkRGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6IDAsXG4gIHN0ZW12OiAwLFxuICBzdGl0Y2hUaWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcENvbG9yOiAnc3RvcC1jb2xvcicsXG4gIHN0b3BPcGFjaXR5OiAnc3RvcC1vcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaFBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2hUaGlja25lc3M6ICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsXG4gIHN0cmluZzogMCxcbiAgc3Ryb2tlOiAwLFxuICBzdHJva2VEYXNoYXJyYXk6ICdzdHJva2UtZGFzaGFycmF5JyxcbiAgc3Ryb2tlRGFzaG9mZnNldDogJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgc3Ryb2tlTGluZWNhcDogJ3N0cm9rZS1saW5lY2FwJyxcbiAgc3Ryb2tlTGluZWpvaW46ICdzdHJva2UtbGluZWpvaW4nLFxuICBzdHJva2VNaXRlcmxpbWl0OiAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCcsXG4gIHN1cmZhY2VTY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbUxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZVZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0WDogJ3RhcmdldFgnLFxuICB0YXJnZXRZOiAndGFyZ2V0WScsXG4gIHRleHRBbmNob3I6ICd0ZXh0LWFuY2hvcicsXG4gIHRleHREZWNvcmF0aW9uOiAndGV4dC1kZWNvcmF0aW9uJyxcbiAgdGV4dFJlbmRlcmluZzogJ3RleHQtcmVuZGVyaW5nJyxcbiAgdGV4dExlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0bzogMCxcbiAgdHJhbnNmb3JtOiAwLFxuICB1MTogMCxcbiAgdTI6IDAsXG4gIHVuZGVybGluZVBvc2l0aW9uOiAndW5kZXJsaW5lLXBvc2l0aW9uJyxcbiAgdW5kZXJsaW5lVGhpY2tuZXNzOiAndW5kZXJsaW5lLXRoaWNrbmVzcycsXG4gIHVuaWNvZGU6IDAsXG4gIHVuaWNvZGVCaWRpOiAndW5pY29kZS1iaWRpJyxcbiAgdW5pY29kZVJhbmdlOiAndW5pY29kZS1yYW5nZScsXG4gIHVuaXRzUGVyRW06ICd1bml0cy1wZXItZW0nLFxuICB2QWxwaGFiZXRpYzogJ3YtYWxwaGFiZXRpYycsXG4gIHZIYW5naW5nOiAndi1oYW5naW5nJyxcbiAgdklkZW9ncmFwaGljOiAndi1pZGVvZ3JhcGhpYycsXG4gIHZNYXRoZW1hdGljYWw6ICd2LW1hdGhlbWF0aWNhbCcsXG4gIHZhbHVlczogMCxcbiAgdmVjdG9yRWZmZWN0OiAndmVjdG9yLWVmZmVjdCcsXG4gIHZlcnNpb246IDAsXG4gIHZlcnRBZHZZOiAndmVydC1hZHYteScsXG4gIHZlcnRPcmlnaW5YOiAndmVydC1vcmlnaW4teCcsXG4gIHZlcnRPcmlnaW5ZOiAndmVydC1vcmlnaW4teScsXG4gIHZpZXdCb3g6ICd2aWV3Qm94JyxcbiAgdmlld1RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAwLFxuICB3aWR0aHM6IDAsXG4gIHdvcmRTcGFjaW5nOiAnd29yZC1zcGFjaW5nJyxcbiAgd3JpdGluZ01vZGU6ICd3cml0aW5nLW1vZGUnLFxuICB4OiAwLFxuICB4SGVpZ2h0OiAneC1oZWlnaHQnLFxuICB4MTogMCxcbiAgeDI6IDAsXG4gIHhDaGFubmVsU2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGxpbmtBY3R1YXRlOiAneGxpbms6YWN0dWF0ZScsXG4gIHhsaW5rQXJjcm9sZTogJ3hsaW5rOmFyY3JvbGUnLFxuICB4bGlua0hyZWY6ICd4bGluazpocmVmJyxcbiAgeGxpbmtSb2xlOiAneGxpbms6cm9sZScsXG4gIHhsaW5rU2hvdzogJ3hsaW5rOnNob3cnLFxuICB4bGlua1RpdGxlOiAneGxpbms6dGl0bGUnLFxuICB4bGlua1R5cGU6ICd4bGluazp0eXBlJyxcbiAgeG1sQmFzZTogJ3htbDpiYXNlJyxcbiAgeG1sbnM6IDAsXG4gIHhtbG5zWGxpbms6ICd4bWxuczp4bGluaycsXG4gIHhtbExhbmc6ICd4bWw6bGFuZycsXG4gIHhtbFNwYWNlOiAneG1sOnNwYWNlJyxcbiAgeTogMCxcbiAgeTE6IDAsXG4gIHkyOiAwLFxuICB5Q2hhbm5lbFNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6IDAsXG4gIHpvb21BbmRQYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7fSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge31cbn07XG5cbk9iamVjdC5rZXlzKEFUVFJTKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1trZXldID0gMDtcbiAgaWYgKEFUVFJTW2tleV0pIHtcbiAgICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc1trZXldID0gQVRUUlNba2V5XTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHRE9NUHJvcGVydHlDb25maWc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1NWR0RPTVByb3BlcnR5Q29uZmlnLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvblNlbGVjdCcsXG4gICAgICBjYXB0dXJlZDogJ29uU2VsZWN0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbnRleHRNZW51JywgJ3RvcEZvY3VzJywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJywgJ3RvcE1vdXNlVXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLy8gVHJhY2sgd2hldGhlciBhIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4vLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbnZhciBoYXNMaXN0ZW5lciA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyZW50RWxlbWVudDogcmFuZ2UucGFyZW50RWxlbWVudCgpLFxuICAgICAgdGV4dDogcmFuZ2UudGV4dCxcbiAgICAgIHRvcDogcmFuZ2UuYm91bmRpbmdUb3AsXG4gICAgICBsZWZ0OiByYW5nZS5ib3VuZGluZ0xlZnRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50ID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50O1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICghaGFzTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlICd0b3BTZWxlY3Rpb25DaGFuZ2UnOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvblNlbGVjdCcpIHtcbiAgICAgIGhhc0xpc3RlbmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0RXZlbnRQbHVnaW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQW5pbWF0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNGb2N1c0V2ZW50Jyk7XG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljS2V5Ym9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0RyYWdFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RvdWNoRXZlbnQnKTtcbnZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNXaGVlbEV2ZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFsndG9wQWJvcnQnXSxcbiAqICAgfSxcbiAqICAgLi4uXG4gKiB9O1xuICogdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICogICAndG9wQWJvcnQnOiB7IHNhbWVDb25maWcgfVxuICogfTtcbiAqL1xudmFyIGV2ZW50VHlwZXMgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnY2xpY2snLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnZG91YmxlQ2xpY2snLCAnZHJhZycsICdkcmFnRW5kJywgJ2RyYWdFbnRlcicsICdkcmFnRXhpdCcsICdkcmFnTGVhdmUnLCAnZHJhZ092ZXInLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHVyYXRpb25DaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnZm9jdXMnLCAnaW5wdXQnLCAnaW52YWxpZCcsICdrZXlEb3duJywgJ2tleVByZXNzJywgJ2tleVVwJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbW91c2VEb3duJywgJ21vdXNlTW92ZScsICdtb3VzZU91dCcsICdtb3VzZU92ZXInLCAnbW91c2VVcCcsICdwYXN0ZScsICdwYXVzZScsICdwbGF5JywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncmF0ZUNoYW5nZScsICdyZXNldCcsICdzY3JvbGwnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoRW5kJywgJ3RvdWNoTW92ZScsICd0b3VjaFN0YXJ0JywgJ3RyYW5zaXRpb25FbmQnLCAndm9sdW1lQ2hhbmdlJywgJ3dhaXRpbmcnLCAnd2hlZWwnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgY2FwaXRhbGl6ZWRFdmVudCA9IGV2ZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zbGljZSgxKTtcbiAgdmFyIG9uRXZlbnQgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcbiAgdmFyIHRvcEV2ZW50ID0gJ3RvcCcgKyBjYXBpdGFsaXplZEV2ZW50O1xuXG4gIHZhciB0eXBlID0ge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBvbkV2ZW50LFxuICAgICAgY2FwdHVyZWQ6IG9uRXZlbnQgKyAnQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcEV2ZW50XVxuICB9O1xuICBldmVudFR5cGVzW2V2ZW50XSA9IHR5cGU7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BFdmVudF0gPSB0eXBlO1xufSk7XG5cbnZhciBvbkNsaWNrTGlzdGVuZXJzID0ge307XG5cbmZ1bmN0aW9uIGdldERpY3Rpb25hcnlLZXkoaW5zdCkge1xuICAvLyBQcmV2ZW50cyBWOCBwZXJmb3JtYW5jZSBpc3N1ZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuICByZXR1cm4gJy4nICsgaW5zdC5fcm9vdE5vZGVJRDtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEV2ZW50Q29uc3RydWN0b3I7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgJ3RvcEFib3J0JzpcbiAgICAgIGNhc2UgJ3RvcENhblBsYXknOlxuICAgICAgY2FzZSAndG9wQ2FuUGxheVRocm91Z2gnOlxuICAgICAgY2FzZSAndG9wRHVyYXRpb25DaGFuZ2UnOlxuICAgICAgY2FzZSAndG9wRW1wdGllZCc6XG4gICAgICBjYXNlICd0b3BFbmNyeXB0ZWQnOlxuICAgICAgY2FzZSAndG9wRW5kZWQnOlxuICAgICAgY2FzZSAndG9wRXJyb3InOlxuICAgICAgY2FzZSAndG9wSW5wdXQnOlxuICAgICAgY2FzZSAndG9wSW52YWxpZCc6XG4gICAgICBjYXNlICd0b3BMb2FkJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRlZERhdGEnOlxuICAgICAgY2FzZSAndG9wTG9hZGVkTWV0YWRhdGEnOlxuICAgICAgY2FzZSAndG9wTG9hZFN0YXJ0JzpcbiAgICAgIGNhc2UgJ3RvcFBhdXNlJzpcbiAgICAgIGNhc2UgJ3RvcFBsYXknOlxuICAgICAgY2FzZSAndG9wUGxheWluZyc6XG4gICAgICBjYXNlICd0b3BQcm9ncmVzcyc6XG4gICAgICBjYXNlICd0b3BSYXRlQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcFJlc2V0JzpcbiAgICAgIGNhc2UgJ3RvcFNlZWtlZCc6XG4gICAgICBjYXNlICd0b3BTZWVraW5nJzpcbiAgICAgIGNhc2UgJ3RvcFN0YWxsZWQnOlxuICAgICAgY2FzZSAndG9wU3VibWl0JzpcbiAgICAgIGNhc2UgJ3RvcFN1c3BlbmQnOlxuICAgICAgY2FzZSAndG9wVGltZVVwZGF0ZSc6XG4gICAgICBjYXNlICd0b3BWb2x1bWVDaGFuZ2UnOlxuICAgICAgY2FzZSAndG9wV2FpdGluZyc6XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDbGljayc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wRG91YmxlQ2xpY2snOlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlTW92ZSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3V0JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3Zlcic6XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcERyYWcnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VuZCc6XG4gICAgICBjYXNlICd0b3BEcmFnRW50ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ0V4aXQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0xlYXZlJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdTdGFydCc6XG4gICAgICBjYXNlICd0b3BEcm9wJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUb3VjaENhbmNlbCc6XG4gICAgICBjYXNlICd0b3BUb3VjaEVuZCc6XG4gICAgICBjYXNlICd0b3BUb3VjaE1vdmUnOlxuICAgICAgY2FzZSAndG9wVG91Y2hTdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkVuZCc6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25JdGVyYXRpb24nOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVHJhbnNpdGlvbkVuZCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wU2Nyb2xsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wV2hlZWwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb3B5JzpcbiAgICAgIGNhc2UgJ3RvcEN1dCc6XG4gICAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICFFdmVudENvbnN0cnVjdG9yID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4nLCB0b3BMZXZlbFR5cGUpIDogX3Byb2RJbnZhcmlhbnQoJzg2JywgdG9wTGV2ZWxUeXBlKSA6IHZvaWQgMDtcbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gICAgLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuICAgIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25DbGljaycgJiYgIWlzSW50ZXJhY3RpdmUoaW5zdC5fdGFnKSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgICAgaWYgKCFvbkNsaWNrTGlzdGVuZXJzW2tleV0pIHtcbiAgICAgICAgb25DbGlja0xpc3RlbmVyc1trZXldID0gRXZlbnRMaXN0ZW5lci5saXN0ZW4obm9kZSwgJ2NsaWNrJywgZW1wdHlGdW5jdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHdpbGxEZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uQ2xpY2snICYmICFpc0ludGVyYWN0aXZlKGluc3QuX3RhZykpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgb25DbGlja0xpc3RlbmVyc1trZXldLnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudFBsdWdpbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xudmFyIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBhbmltYXRpb25OYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/IGV2ZW50LmNsaXBib2FyZERhdGEgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBnZXRFdmVudEtleSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRLZXknKTtcbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG5cbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJDb2RlO1xuICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBjaGFyQ29kZSA9IG5hdGl2ZUV2ZW50LmNoYXJDb2RlO1xuXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH1cblxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50Q2hhckNvZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gICdFc2MnOiAnRXNjYXBlJyxcbiAgJ1NwYWNlYmFyJzogJyAnLFxuICAnTGVmdCc6ICdBcnJvd0xlZnQnLFxuICAnVXAnOiAnQXJyb3dVcCcsXG4gICdSaWdodCc6ICdBcnJvd1JpZ2h0JyxcbiAgJ0Rvd24nOiAnQXJyb3dEb3duJyxcbiAgJ0RlbCc6ICdEZWxldGUnLFxuICAnV2luJzogJ09TJyxcbiAgJ01lbnUnOiAnQ29udGV4dE1lbnUnLFxuICAnQXBwcyc6ICdDb250ZXh0TWVudScsXG4gICdTY3JvbGwnOiAnU2Nyb2xsTG9jaycsXG4gICdNb3pQcmludGFibGVLZXknOiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgODogJ0JhY2tzcGFjZScsXG4gIDk6ICdUYWInLFxuICAxMjogJ0NsZWFyJyxcbiAgMTM6ICdFbnRlcicsXG4gIDE2OiAnU2hpZnQnLFxuICAxNzogJ0NvbnRyb2wnLFxuICAxODogJ0FsdCcsXG4gIDE5OiAnUGF1c2UnLFxuICAyMDogJ0NhcHNMb2NrJyxcbiAgMjc6ICdFc2NhcGUnLFxuICAzMjogJyAnLFxuICAzMzogJ1BhZ2VVcCcsXG4gIDM0OiAnUGFnZURvd24nLFxuICAzNTogJ0VuZCcsXG4gIDM2OiAnSG9tZScsXG4gIDM3OiAnQXJyb3dMZWZ0JyxcbiAgMzg6ICdBcnJvd1VwJyxcbiAgMzk6ICdBcnJvd1JpZ2h0JyxcbiAgNDA6ICdBcnJvd0Rvd24nLFxuICA0NTogJ0luc2VydCcsXG4gIDQ2OiAnRGVsZXRlJyxcbiAgMTEyOiAnRjEnLCAxMTM6ICdGMicsIDExNDogJ0YzJywgMTE1OiAnRjQnLCAxMTY6ICdGNScsIDExNzogJ0Y2JyxcbiAgMTE4OiAnRjcnLCAxMTk6ICdGOCcsIDEyMDogJ0Y5JywgMTIxOiAnRjEwJywgMTIyOiAnRjExJywgMTIzOiAnRjEyJyxcbiAgMTQ0OiAnTnVtTG9jaycsXG4gIDE0NTogJ1Njcm9sbExvY2snLFxuICAyMjQ6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpO1xuXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50S2V5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9nZXRFdmVudEtleS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0RyYWdFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LCBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01Db250YWluZXJJbmZvID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbnRhaW5lckluZm8nKTtcbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01GZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIFJPT1RfQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICogdGhhdCdzIG5vdCBjb21tb24gYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3MuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciB3aGVyZSB0aGUgc3RyaW5ncyBkaXZlcmdlXG4gKi9cbmZ1bmN0aW9uIGZpcnN0RGlmZmVyZW5jZUluZGV4KHN0cmluZzEsIHN0cmluZzIpIHtcbiAgdmFyIG1pbkxlbiA9IE1hdGgubWluKHN0cmluZzEubGVuZ3RoLCBzdHJpbmcyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluTGVuOyBpKyspIHtcbiAgICBpZiAoc3RyaW5nMS5jaGFyQXQoaSkgIT09IHN0cmluZzIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZzEubGVuZ3RoID09PSBzdHJpbmcyLmxlbmd0aCA/IC0xIDogbWluTGVuO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01Eb2N1bWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW5cbiAqIGEgUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/Kn0gRE9NIGVsZW1lbnQgdGhhdCBtYXkgaGF2ZSB0aGUgcmVhY3RSb290IElELCBvciBudWxsLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SUQobm9kZSkge1xuICAvLyBJZiBub2RlIGlzIHNvbWV0aGluZyBsaWtlIGEgd2luZG93LCBkb2N1bWVudCwgb3IgdGV4dCBub2RlLCBub25lIG9mXG4gIC8vIHdoaWNoIHN1cHBvcnQgYXR0cmlidXRlcyBvciBhIC5nZXRBdHRyaWJ1dGUgbWV0aG9kLCBncmFjZWZ1bGx5IHJldHVyblxuICAvLyB0aGUgZW1wdHkgc3RyaW5nLCBhcyBpZiB0aGUgYXR0cmlidXRlIHdlcmUgbWlzc2luZy5cbiAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgfHwgJyc7XG59XG5cbi8qKlxuICogTW91bnRzIHRoaXMgY29tcG9uZW50IGFuZCBpbnNlcnRzIGl0IGludG8gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudEludG9Ob2RlKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIG1hcmtlck5hbWU7XG4gIGlmIChSZWFjdEZlYXR1cmVGbGFncy5sb2dUb3BMZXZlbFJlbmRlcnMpIHtcbiAgICB2YXIgd3JhcHBlZEVsZW1lbnQgPSB3cmFwcGVySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnByb3BzLmNoaWxkO1xuICAgIHZhciB0eXBlID0gd3JhcHBlZEVsZW1lbnQudHlwZTtcbiAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IG1vdW50OiAnICsgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSk7XG4gICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xuICB9XG5cbiAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh3cmFwcGVySW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBudWxsLCBSZWFjdERPTUNvbnRhaW5lckluZm8od3JhcHBlckluc3RhbmNlLCBjb250YWluZXIpLCBjb250ZXh0LCAwIC8qIHBhcmVudERlYnVnSUQgKi9cbiAgKTtcblxuICBpZiAobWFya2VyTmFtZSkge1xuICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcbiAgfVxuXG4gIHdyYXBwZXJJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX3RvcExldmVsV3JhcHBlciA9IHdyYXBwZXJJbnN0YW5jZTtcbiAgUmVhY3RNb3VudC5fbW91bnRJbWFnZUludG9Ob2RlKG1hcmt1cCwgY29udGFpbmVyLCB3cmFwcGVySW5zdGFuY2UsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogQmF0Y2hlZCBtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi9cbiAgIXNob3VsZFJldXNlTWFya3VwICYmIFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQpO1xuICB0cmFuc2FjdGlvbi5wZXJmb3JtKG1vdW50Q29tcG9uZW50SW50b05vZGUsIG51bGwsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG4gIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIFVubW91bnRzIGEgY29tcG9uZW50IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnN0YW5jZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byB1bm1vdW50IGZyb20uXG4gKiBAZmluYWxcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7UmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlfVxuICovXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lciwgc2FmZWx5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCgpO1xuICB9XG4gIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KGluc3RhbmNlLCBzYWZlbHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoKCk7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5aW5nLWEtbm9kZVxuICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGhhcyBhIGRpcmVjdCBSZWFjdC1yZW5kZXJlZCBjaGlsZCB0aGF0IGlzXG4gKiBub3QgYSBSZWFjdCByb290IGVsZW1lbnQuIFVzZWZ1bCBmb3Igd2FybmluZyBpbiBgcmVuZGVyYCxcbiAqIGB1bm1vdW50Q29tcG9uZW50QXROb2RlYCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGNvbnRhaW5zIGEgZGlyZWN0IGNoaWxkIHRoYXQgd2FzXG4gKiByZW5kZXJlZCBieSBSZWFjdCBidXQgaXMgbm90IGEgcm9vdCBlbGVtZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIGlmIChyb290RWwpIHtcbiAgICB2YXIgaW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG4gICAgcmV0dXJuICEhKGluc3QgJiYgaW5zdC5faG9zdFBhcmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIFJlYWN0IERPTSBlbGVtZW50IGFuZFxuICogaXQgaGFzIGJlZW4gcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBoYXMgYmVlbiByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3RcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsICYmIGlzUmVhY3ROb2RlKHJvb3RFbCkgJiYgIVJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCkpO1xufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIFJlYWN0IG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBSZWFjdCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1JlYWN0Tm9kZShub2RlKSB7XG4gIHJldHVybiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpICYmIChub2RlLmhhc0F0dHJpYnV0ZShST09UX0FUVFJfTkFNRSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RSb290SW5zdGFuY2VJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICB2YXIgcHJldkhvc3RJbnN0YW5jZSA9IHJvb3RFbCAmJiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICByZXR1cm4gcHJldkhvc3RJbnN0YW5jZSAmJiAhcHJldkhvc3RJbnN0YW5jZS5faG9zdFBhcmVudCA/IHByZXZIb3N0SW5zdGFuY2UgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3QgPSBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuIHJvb3QgPyByb290Ll9ob3N0Q29udGFpbmVySW5mby5fdG9wTGV2ZWxXcmFwcGVyIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUZW1wb3JhcnkgKD8pIGhhY2sgc28gdGhhdCB3ZSBjYW4gc3RvcmUgYWxsIHRvcC1sZXZlbCBwZW5kaW5nIHVwZGF0ZXMgb25cbiAqIGNvbXBvc2l0ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gd29ycnkgYWJvdXQgZGlmZmVyZW50IHR5cGVzIG9mIGNvbXBvbmVudHNcbiAqIGhlcmUuXG4gKi9cbnZhciB0b3BMZXZlbFJvb3RDb3VudGVyID0gMTtcbnZhciBUb3BMZXZlbFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucm9vdElEID0gdG9wTGV2ZWxSb290Q291bnRlcisrO1xufTtcblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVG9wTGV2ZWxXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ1RvcExldmVsV3JhcHBlcic7XG59XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGQ7XG59O1xuVG9wTGV2ZWxXcmFwcGVyLmlzUmVhY3RUb3BMZXZlbFdyYXBwZXIgPSB0cnVlO1xuXG4vKipcbiAqIE1vdW50aW5nIGlzIHRoZSBwcm9jZXNzIG9mIGluaXRpYWxpemluZyBhIFJlYWN0IGNvbXBvbmVudCBieSBjcmVhdGluZyBpdHNcbiAqIHJlcHJlc2VudGF0aXZlIERPTSBlbGVtZW50cyBhbmQgaW5zZXJ0aW5nIHRoZW0gaW50byBhIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICogQW55IHByaW9yIGNvbnRlbnQgaW5zaWRlIGBjb250YWluZXJgIGlzIGRlc3Ryb3llZCBpbiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiAgIFJlYWN0TW91bnQucmVuZGVyKFxuICogICAgIGNvbXBvbmVudCxcbiAqICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJylcbiAqICAgKTtcbiAqXG4gKiAgIDxkaXYgaWQ9XCJjb250YWluZXJcIj4gICAgICAgICAgICAgICAgICAgPC0tIFN1cHBsaWVkIGBjb250YWluZXJgLlxuICogICAgIDxkaXYgZGF0YS1yZWFjdGlkPVwiLjNcIj4gICAgICAgICAgICAgIDwtLSBSZW5kZXJlZCByZWFjdFJvb3Qgb2YgUmVhY3RcbiAqICAgICAgIC8vIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKlxuICogSW5zaWRlIG9mIGBjb250YWluZXJgLCB0aGUgZmlyc3QgZWxlbWVudCByZW5kZXJlZCBpcyB0aGUgXCJyZWFjdFJvb3RcIi5cbiAqL1xudmFyIFJlYWN0TW91bnQgPSB7XG5cbiAgVG9wTGV2ZWxXcmFwcGVyOiBUb3BMZXZlbFdyYXBwZXIsXG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgZGV2dG9vbHMuIFRoZSBrZXlzIGFyZSBub3QgaW1wb3J0YW50LlxuICAgKi9cbiAgX2luc3RhbmNlc0J5UmVhY3RSb290SUQ6IGluc3RhbmNlc0J5UmVhY3RSb290SUQsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBob29rIHByb3ZpZGVkIHRvIHN1cHBvcnQgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgd2hpbGVcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYXBwYXJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIGl0cyBgY29udGFpbmVyYCBkb2VzIG5vdFxuICAgKiBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIFRoZSBgY29udGFpbmVyYCBiZWluZyByZW5kZXJlZCBpbnRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJDYWxsYmFjayBUaGlzIG11c3QgYmUgY2FsbGVkIG9uY2UgdG8gZG8gdGhlIHJlbmRlci5cbiAgICovXG4gIHNjcm9sbE1vbml0b3I6IGZ1bmN0aW9uIChjb250YWluZXIsIHJlbmRlckNhbGxiYWNrKSB7XG4gICAgcmVuZGVyQ2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFrZSBhIGNvbXBvbmVudCB0aGF0J3MgYWxyZWFkeSBtb3VudGVkIGludG8gdGhlIERPTSBhbmQgcmVwbGFjZSBpdHMgcHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcHJldkNvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgYWxyZWFkeSBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICovXG4gIF91cGRhdGVSb290Q29tcG9uZW50OiBmdW5jdGlvbiAocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RNb3VudC5zY3JvbGxNb25pdG9yKGNvbnRhaW5lciwgZnVuY3Rpb24gKCkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRWxlbWVudEludGVybmFsKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJldkNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGNvbXBvbmVudCBpbnRvIHRoZSBET00uIEhvb2tlZCBieSBob29rcyFcbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGVsZW1lbnQgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIGlmIHdlIHNob3VsZCBza2lwIHRoZSBtYXJrdXAgaW5zZXJ0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50XG4gICAqL1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ19yZW5kZXJOZXdSb290Q29tcG9uZW50KCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gJyArICdyZW5kZXIgaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzcnKSA6IHZvaWQgMDtcblxuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5lbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmcoKTtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBmYWxzZSk7XG5cbiAgICAvLyBUaGUgaW5pdGlhbCByZW5kZXIgaXMgc3luY2hyb25vdXMgYnV0IGFueSB1cGRhdGVzIHRoYXQgaGFwcGVuIGR1cmluZ1xuICAgIC8vIHJlbmRlcmluZywgaW4gY29tcG9uZW50V2lsbE1vdW50IG9yIGNvbXBvbmVudERpZE1vdW50LCB3aWxsIGJlIGJhdGNoZWRcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgYmF0Y2hpbmcgc3RyYXRlZ3kuXG5cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcblxuICAgIHZhciB3cmFwcGVySUQgPSBjb21wb25lbnRJbnN0YW5jZS5faW5zdGFuY2Uucm9vdElEO1xuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbd3JhcHBlcklEXSA9IGNvbXBvbmVudEluc3RhbmNlO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwYXJlbnRDb21wb25lbnQgVGhlIGNvbmNlcHR1YWwgcGFyZW50IG9mIHRoaXMgcmVuZGVyIHRyZWUuXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgUmVhY3RJbnN0YW5jZU1hcC5oYXMocGFyZW50Q29tcG9uZW50KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCczOCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCAnUmVhY3RET00ucmVuZGVyJyk7XG4gICAgIVJlYWN0LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTS5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlIFxcJ2RpdlxcJywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoXFwnZGl2XFwnKSBvciA8ZGl2IC8+LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6XG4gICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYW4gZWxlbWVudFxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzM5JywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgXFwnZGl2XFwnLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChcXCdkaXZcXCcpIG9yIDxkaXYgLz4uJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDogbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiB2b2lkIDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVyIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIG5leHRXcmFwcGVkRWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9wTGV2ZWxXcmFwcGVyLCB7IGNoaWxkOiBuZXh0RWxlbWVudCB9KTtcblxuICAgIHZhciBuZXh0Q29udGV4dDtcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcGFyZW50SW5zdCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gICAgICBuZXh0Q29udGV4dCA9IHBhcmVudEluc3QuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50SW5zdC5fY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgaWYgKHByZXZDb21wb25lbnQpIHtcbiAgICAgIHZhciBwcmV2V3JhcHBlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50Ll9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZXcmFwcGVkRWxlbWVudC5wcm9wcy5jaGlsZDtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHZhciBwdWJsaWNJbnN0ID0gcHJldkNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIHVwZGF0ZWRDYWxsYmFjayA9IGNhbGxiYWNrICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHB1YmxpY0luc3QpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KHByZXZDb21wb25lbnQsIG5leHRXcmFwcGVkRWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgdXBkYXRlZENhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJIYXNSZWFjdE1hcmt1cCA9IHJlYWN0Um9vdEVsZW1lbnQgJiYgISFpbnRlcm5hbEdldElEKHJlYWN0Um9vdEVsZW1lbnQpO1xuICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKCFjb250YWluZXJIYXNSZWFjdE1hcmt1cCB8fCByZWFjdFJvb3RFbGVtZW50Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudFNpYmxpbmcgPSByZWFjdFJvb3RFbGVtZW50O1xuICAgICAgICB3aGlsZSAocm9vdEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgaWYgKGludGVybmFsR2V0SUQocm9vdEVsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdEVsZW1lbnRTaWJsaW5nID0gcm9vdEVsZW1lbnRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFJldXNlTWFya3VwID0gY29udGFpbmVySGFzUmVhY3RNYXJrdXAgJiYgIXByZXZDb21wb25lbnQgJiYgIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkO1xuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgbmV4dENvbnRleHQpLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5yZW5kZXJcbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20udW5tb3VudGNvbXBvbmVudGF0bm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgY29tcG9uZW50IHdhcyBmb3VuZCBpbiBhbmQgdW5tb3VudGVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcbiAgICovXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChTdHJpY3RseSBzcGVha2luZywgdW5tb3VudGluZyB3b24ndCBjYXVzZSBhXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyICcgKyAnaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQwJykgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIW5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlKGNvbnRhaW5lciksICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGlmICghcHJldkNvbXBvbmVudCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5vZGUgYmVpbmcgdW5tb3VudGVkIHdhcyByZW5kZXJlZCBieSBSZWFjdCwgYnV0IGlzbid0IGFcbiAgICAgIC8vIHJvb3Qgbm9kZS5cbiAgICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGNvbnRhaW5lci5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RSb290SURbcHJldkNvbXBvbmVudC5faW5zdGFuY2Uucm9vdElEXTtcbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXModW5tb3VudENvbXBvbmVudEZyb21Ob2RlLCBwcmV2Q29tcG9uZW50LCBjb250YWluZXIsIGZhbHNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfbW91bnRJbWFnZUludG9Ob2RlOiBmdW5jdGlvbiAobWFya3VwLCBjb250YWluZXIsIGluc3RhbmNlLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBfcHJvZEludmFyaWFudCgnNDEnKSA6IHZvaWQgMDtcblxuICAgIGlmIChzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICBpZiAoUmVhY3RNYXJrdXBDaGVja3N1bS5jYW5SZXVzZU1hcmt1cChtYXJrdXAsIHJvb3RFbGVtZW50KSkge1xuICAgICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCByb290RWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHJvb3RFbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG5cbiAgICAgICAgdmFyIHJvb3RNYXJrdXAgPSByb290RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSwgY2hlY2tzdW0pO1xuXG4gICAgICAgIHZhciBub3JtYWxpemVkTWFya3VwID0gbWFya3VwO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8vIGJlY2F1c2Ugcm9vdE1hcmt1cCBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLCB2YXJpb3VzIG5vcm1hbGl6YXRpb25zXG4gICAgICAgICAgLy8gd2lsbCBoYXZlIG9jY3VycmVkIHdoaWNoIHdpbGwgbm90IGJlIHByZXNlbnQgaW4gYG1hcmt1cGAuIEhlcmUsXG4gICAgICAgICAgLy8gaW5zZXJ0IG1hcmt1cCBpbnRvIGEgPGRpdj4gb3IgPGlmcmFtZT4gZGVwZW5kaW5nIG9uIHRoZSBjb250YWluZXJcbiAgICAgICAgICAvLyB0eXBlIHRvIHBlcmZvcm0gdGhlIHNhbWUgbm9ybWFsaXphdGlvbnMgYmVmb3JlIGNvbXBhcmluZy5cbiAgICAgICAgICB2YXIgbm9ybWFsaXplcjtcbiAgICAgICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSkge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5pbm5lckhUTUwgPSBtYXJrdXA7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5pbm5lckhUTUw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgICBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC53cml0ZShtYXJrdXApO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmSW5kZXggPSBmaXJzdERpZmZlcmVuY2VJbmRleChub3JtYWxpemVkTWFya3VwLCByb290TWFya3VwKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAnIChjbGllbnQpICcgKyBub3JtYWxpemVkTWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApICsgJ1xcbiAoc2VydmVyKSAnICsgcm9vdE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKTtcblxuICAgICAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBidXQgdGhlIGNoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uIHRoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgbWV0aG9kcyBhcmUgaW1wdXJlLiBSZWFjdCBjYW5ub3QgaGFuZGxlIHRoaXMgY2FzZSBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3Ugc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyBhbmQgZW5zdXJlIHRoZSBwcm9wcyBhcmUgdGhlIHNhbWUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZTpcXG4lcycsIGRpZmZlcmVuY2UpIDogX3Byb2RJbnZhcmlhbnQoJzQyJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0IGF0dGVtcHRlZCB0byByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICsgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICsgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgKyAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgKyAnb3Igc2VydmVyOlxcbiVzJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0IHlvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzIHdpdGhvdXQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzQzJykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShjb250YWluZXIsIG1hcmt1cCwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElubmVySFRNTChjb250YWluZXIsIG1hcmt1cCk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBob3N0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgIGlmIChob3N0Tm9kZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICBpbnN0YW5jZUlEOiBob3N0Tm9kZS5fZGVidWdJRCxcbiAgICAgICAgICB0eXBlOiAnbW91bnQnLFxuICAgICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdE1vdW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG5cbnZhciBET0NfTk9ERV9UWVBFID0gOTtcblxuZnVuY3Rpb24gUmVhY3RET01Db250YWluZXJJbmZvKHRvcExldmVsV3JhcHBlciwgbm9kZSkge1xuICB2YXIgaW5mbyA9IHtcbiAgICBfdG9wTGV2ZWxXcmFwcGVyOiB0b3BMZXZlbFdyYXBwZXIsXG4gICAgX2lkQ291bnRlcjogMSxcbiAgICBfb3duZXJEb2N1bWVudDogbm9kZSA/IG5vZGUubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgPyBub2RlIDogbm9kZS5vd25lckRvY3VtZW50IDogbnVsbCxcbiAgICBfbm9kZTogbm9kZSxcbiAgICBfdGFnOiBub2RlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbCxcbiAgICBfbmFtZXNwYWNlVVJJOiBub2RlID8gbm9kZS5uYW1lc3BhY2VVUkkgOiBudWxsXG4gIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5mby5fYW5jZXN0b3JJbmZvID0gbm9kZSA/IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIGluZm8uX3RhZywgbnVsbCkgOiBudWxsO1xuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29udGFpbmVySW5mbztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0ge1xuICB1c2VDcmVhdGVFbGVtZW50OiB0cnVlLFxuICB1c2VGaWJlcjogZmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GZWF0dXJlRmxhZ3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcblxudmFyIFRBR19FTkQgPSAvXFwvPz4vO1xudmFyIENPTU1FTlRfU1RBUlQgPSAvXjxcXCFcXC1cXC0vO1xuXG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHtcbiAgQ0hFQ0tTVU1fQVRUUl9OQU1FOiAnZGF0YS1yZWFjdC1jaGVja3N1bScsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcgd2l0aCBjaGVja3N1bSBhdHRyaWJ1dGUgYXR0YWNoZWRcbiAgICovXG4gIGFkZENoZWNrc3VtVG9NYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgY2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG5cbiAgICAvLyBBZGQgY2hlY2tzdW0gKGhhbmRsZSBib3RoIHBhcmVudCB0YWdzLCBjb21tZW50cyBhbmQgc2VsZi1jbG9zaW5nIHRhZ3MpXG4gICAgaWYgKENPTU1FTlRfU1RBUlQudGVzdChtYXJrdXApKSB7XG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWFya3VwLnJlcGxhY2UoVEFHX0VORCwgJyAnICsgUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUgKyAnPVwiJyArIGNoZWNrc3VtICsgJ1wiJCYnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgdG8gdXNlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCByb290IFJlYWN0IGVsZW1lbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBtYXJrdXAgaXMgdGhlIHNhbWVcbiAgICovXG4gIGNhblJldXNlTWFya3VwOiBmdW5jdGlvbiAobWFya3VwLCBlbGVtZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nQ2hlY2tzdW0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgZXhpc3RpbmdDaGVja3N1bSA9IGV4aXN0aW5nQ2hlY2tzdW0gJiYgcGFyc2VJbnQoZXhpc3RpbmdDaGVja3N1bSwgMTApO1xuICAgIHZhciBtYXJrdXBDaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcbiAgICByZXR1cm4gbWFya3VwQ2hlY2tzdW0gPT09IGV4aXN0aW5nQ2hlY2tzdW07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNYXJrdXBDaGVja3N1bTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE1PRCA9IDY1NTIxO1xuXG4vLyBhZGxlcjMyIGlzIG5vdCBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcsIGFuZCBpcyBvbmx5IHVzZWQgdG8gc2FuaXR5IGNoZWNrIHRoYXRcbi8vIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIHNlcnZlciBtYXRjaGVzIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBjbGllbnQuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIChhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIFNoZWV0SlMgdmVyc2lvbikgaGFzIGJlZW4gb3B0aW1pemVkXG4vLyBmb3Igb3VyIHVzZSBjYXNlLCBhdCB0aGUgZXhwZW5zZSBvZiBjb25mb3JtaW5nIHRvIHRoZSBhZGxlcjMyIHNwZWNpZmljYXRpb25cbi8vIGZvciBub24tYXNjaWkgaW5wdXRzLlxuZnVuY3Rpb24gYWRsZXIzMihkYXRhKSB7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0gZGF0YS5sZW5ndGg7XG4gIHZhciBtID0gbCAmIH4weDM7XG4gIHdoaWxlIChpIDwgbSkge1xuICAgIHZhciBuID0gTWF0aC5taW4oaSArIDQwOTYsIG0pO1xuICAgIGZvciAoOyBpIDwgbjsgaSArPSA0KSB7XG4gICAgICBiICs9IChhICs9IGRhdGEuY2hhckNvZGVBdChpKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDEpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMikpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgfVxuICAgIGEgJT0gTU9EO1xuICAgIGIgJT0gTU9EO1xuICB9XG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgYiArPSBhICs9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgfVxuICBhICU9IE1PRDtcbiAgYiAlPSBNT0Q7XG4gIHJldHVybiBhIHwgYiA8PCAxNjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9hZGxlcjMyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMTUuNC4yJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RWZXJzaW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG5cbnZhciBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgZWxlbWVudC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20uZmluZGRvbW5vZGVcbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fERPTUVsZW1lbnR9IGNvbXBvbmVudE9yRWxlbWVudFxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgfVxuXG4gIHZhciBpbnN0ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XG4gICAgcmV0dXJuIGluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSA6IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZmluZERPTU5vZGUgd2FzIGNhbGxlZCBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQ0JykgOiB2b2lkIDA7XG4gIH0gZWxzZSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlIChrZXlzOiAlcyknLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IF9wcm9kSW52YXJpYW50KCc0NScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogdm9pZCAwO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZERPTU5vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2ZpbmRET01Ob2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xuXG5mdW5jdGlvbiBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KSB7XG4gIHZhciB0eXBlO1xuXG4gIHdoaWxlICgodHlwZSA9IGluc3QuX3JlbmRlcmVkTm9kZVR5cGUpID09PSBSZWFjdE5vZGVUeXBlcy5DT01QT1NJVEUpIHtcbiAgICBpbnN0ID0gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuSE9TVCkge1xuICAgIHJldHVybiBpbnN0Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50LnJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcmVhY3RQcm9wcyA9IHtcbiAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAgcmVmOiB0cnVlLFxuXG4gICAgYXV0b0ZvY3VzOiB0cnVlLFxuICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICB2YWx1ZUxpbms6IHRydWUsXG4gICAgZGVmYXVsdENoZWNrZWQ6IHRydWUsXG4gICAgY2hlY2tlZExpbms6IHRydWUsXG4gICAgaW5uZXJIVE1MOiB0cnVlLFxuICAgIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgICBvbkZvY3VzSW46IHRydWUsXG4gICAgb25Gb2N1c091dDogdHJ1ZVxuICB9O1xuICB2YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIGRlYnVnSUQpIHtcbiAgICBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHwgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBkYXRhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIGlmIChzdGFuZGFyZE5hbWUgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIERPTSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3ZXJlIHVuYWJsZSB0byBndWVzcyB3aGljaCBwcm9wIHRoZSB1c2VyIGludGVuZGVkLlxuICAgICAgLy8gSXQgaXMgbGlrZWx5IHRoYXQgdGhlIHVzZXIgd2FzIGp1c3QgYmxpbmRseSBzcHJlYWRpbmcvZm9yd2FyZGluZyBwcm9wc1xuICAgICAgLy8gQ29tcG9uZW50cyBzaG91bGQgYmUgY2FyZWZ1bCB0byBvbmx5IHJlbmRlciB2YWxpZCBwcm9wcy9hdHRyaWJ1dGVzLlxuICAgICAgLy8gV2FybmluZyB3aWxsIGJlIGludm9rZWQgaW4gd2FyblVua25vd25Qcm9wZXJ0aWVzIHRvIGFsbG93IGdyb3VwaW5nLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIGVsZW1lbnQucHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkoZWxlbWVudC50eXBlLCBrZXksIGRlYnVnSUQpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gcHJvcCAlcyBvbiA8JXM+IHRhZy4gUmVtb3ZlIHRoaXMgcHJvcCBmcm9tIHRoZSBlbGVtZW50LiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC11bmtub3duLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3BzICVzIG9uIDwlcz4gdGFnLiBSZW1vdmUgdGhlc2UgcHJvcHMgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZS5pbmRleE9mKCctJykgPj0gMCB8fCBlbGVtZW50LnByb3BzLmlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyhkZWJ1Z0lELCBlbGVtZW50KTtcbn1cblxudmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ2lucHV0JyAmJiBlbGVtZW50LnR5cGUgIT09ICd0ZXh0YXJlYScgJiYgZWxlbWVudC50eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5wcm9wcyAhPSBudWxsICYmIGVsZW1lbnQucHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyB0aGUgZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuXG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUsIGRlYnVnSUQpIHtcbiAgaWYgKHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIEFSSUEgYXR0cmlidXRlICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHMoZGVidWdJRCwgZWxlbWVudCkge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIGVsZW1lbnQucHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkoZWxlbWVudC50eXBlLCBrZXksIGRlYnVnSUQpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnR5cGUuaW5kZXhPZignLScpID49IDAgfHwgZWxlbWVudC5wcm9wcy5pcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKGRlYnVnSUQsIGVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RET01JbnZhbGlkQVJJQUhvb2sgPSB7XG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gICAgfVxuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnZhbGlkQVJJQUhvb2s7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW52YWxpZEFSSUFIb29rLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==